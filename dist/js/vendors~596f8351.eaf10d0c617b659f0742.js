(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{31:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {/* unused harmony export Breadcrumb */\n/* unused harmony export BreadcrumbItem */\n/* unused harmony export Button */\n/* unused harmony export ButtonLink */\n/* unused harmony export ButtonGroup */\n/* unused harmony export Card */\n/* unused harmony export CardTitle */\n/* unused harmony export Drop */\n/* unused harmony export Dropdown */\n/* unused harmony export Grid */\n/* unused harmony export Icon */\n/* unused harmony export IconLink */\n/* unused harmony export IconButton */\n/* unused harmony export IconImage */\n/* unused harmony export Iconnav */\n/* unused harmony export IconnavVertical */\n/* unused harmony export IconnavItem */\n/* unused harmony export Label */\n/* unused harmony export Modal */\n/* unused harmony export ModalFull */\n/* unused harmony export ModalClose */\n/* unused harmony export ModalFullClose */\n/* unused harmony export ModalTitle */\n/* unused harmony export Nav */\n/* unused harmony export NavDropdown */\n/* unused harmony export NavItem */\n/* unused harmony export NavItemDivider */\n/* unused harmony export NavItemHeader */\n/* unused harmony export NavItemParent */\n/* unused harmony export Navbar */\n/* unused harmony export NavbarFull */\n/* unused harmony export NavbarDropbar */\n/* unused harmony export NavbarItem */\n/* unused harmony export NavbarLogo */\n/* unused harmony export NavbarToggle */\n/* unused harmony export NavbarNav */\n/* unused harmony export NavbarNavItem */\n/* unused harmony export NavbarNavDropdown */\n/* unused harmony export NavbarNavDropdownNav */\n/* unused harmony export Notification */\n/* unused harmony export Offcanvas */\n/* unused harmony export OffcanvasContent */\n/* unused harmony export OffcanvasBar */\n/* unused harmony export OffcanvasClose */\n/* unused harmony export Pagination */\n/* unused harmony export PaginationPages */\n/* unused harmony export PaginationPageFirst */\n/* unused harmony export PaginationPagePrev */\n/* unused harmony export PaginationPageNext */\n/* unused harmony export PaginationPageLast */\n/* unused harmony export Scrollspy */\n/* unused harmony export ScrollspyNav */\n/* unused harmony export SkeletonImage */\n/* unused harmony export SkeletonText */\n/* unused harmony export SkeletonTitle */\n/* unused harmony export Spinner */\n/* unused harmony export Sticky */\n/* unused harmony export Subnav */\n/* unused harmony export SubnavItem */\n/* unused harmony export SubnavItemDropdown */\n/* unused harmony export Table */\n/* unused harmony export TableTree */\n/* unused harmony export TableColumn */\n/* unused harmony export TableColumnSort */\n/* unused harmony export TableColumnSelect */\n/* unused harmony export TableColumnTree */\n/* unused harmony export Tabs */\n/* unused harmony export TabsVertical */\n/* unused harmony export TabsItem */\n/* unused harmony export Margin */\n/* unused harmony export Scroll */\n/* unused harmony export Tooltip */\n/* unused harmony export HeightMatch */\n/* unused harmony export HeightViewport */\n/**\n * Vuikit 0.8.10\n * (c) 2018 Miljan Aleksic\n * @license MIT\n**/\n\n/* Substantial part of the code is adapted from UIkit,\n  Copyright (c) 2013-2018 YOOtheme GmbH, getuikit.com */\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\nvar hyphenateRe = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n  return str.replace(hyphenateRe, '$1-$2').toLowerCase();\n}\n\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : '';\n}\n\nfunction ucfirst(str) {\n  return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '';\n}\n\nvar strPrototype = String.prototype;\n\nvar startsWithFn = strPrototype.startsWith || function (search) {\n  return this.lastIndexOf(search, 0) === 0;\n};\n\nfunction startsWith(str, search) {\n  return startsWithFn.call(str, search);\n}\n\nvar endsWithFn = strPrototype.endsWith || function (search) {\n  return this.substr(-search.length) === search;\n};\n\nfunction endsWith(str, search) {\n  return endsWithFn.call(str, search);\n}\n\nvar includesFn = function (search) {\n  return ~this.indexOf(search);\n};\n\nvar includesStr = strPrototype.includes || includesFn;\nvar includesArray = Array.prototype.includes || includesFn;\n\nfunction includes(obj, search) {\n  return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);\n}\n\nvar isArray = Array.isArray;\n\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n  return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n}\n\nfunction isWindow(obj) {\n  return isObject(obj) && obj === obj.window;\n}\n\nfunction isDocument(obj) {\n  return isObject(obj) && obj.nodeType === 9;\n}\n\nfunction isJQuery(obj) {\n  return isObject(obj) && !!obj.jquery;\n}\n\nfunction isNode(element) {\n  return typeof Node !== 'undefined' && element instanceof Node || isObject(element) && element.nodeType === 1;\n}\n\nfunction isNodeCollection(element) {\n  return typeof NodeList !== 'undefined' && element instanceof NodeList || typeof HTMLCollection !== 'undefined' && element instanceof HTMLCollection;\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\nfunction isNumeric(value) {\n  return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n}\n\nfunction isUndefined(value) {\n  return value === void 0;\n}\n\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\n\nfunction toNode(element) {\n  return isNode(element) || isWindow(element) || isDocument(element) ? element : isNodeCollection(element) || isJQuery(element) ? element[0] : isArray(element) ? toNode(element[0]) : null;\n}\n\nvar arrayProto = Array.prototype;\n\nfunction toNodes(element) {\n  return isNode(element) ? [element] : isNodeCollection(element) ? arrayProto.slice.call(element) : isArray(element) ? element.map(toNode).filter(Boolean) : isJQuery(element) ? element.toArray() : [];\n}\n\nvar assign = Object.assign || function (target) {\n  var args = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) args[len] = arguments[len + 1];\n\n  target = Object(target);\n\n  for (var i = 0; i < args.length; i++) {\n    var source = args[i];\n\n    if (source !== null) {\n      for (var key in source) {\n        if (hasOwn(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction each(obj, cb) {\n  for (var key in obj) {\n    if (cb.call(obj[key], obj[key], key) === false) {\n      break;\n    }\n  }\n}\n\nfunction clamp(number, min, max) {\n  if (min === void 0) min = 0;\n  if (max === void 0) max = 1;\n  return Math.min(Math.max(number, min), max);\n}\n\nfunction noop() {}\n\nfunction intersectRect(r1, r2) {\n  return r1.left <= r2.right && r2.left <= r1.right && r1.top <= r2.bottom && r2.top <= r1.bottom;\n}\n\nfunction attr(element, name, value) {\n  if (isObject(name)) {\n    for (var key in name) {\n      attr(element, key, name[key]);\n    }\n\n    return;\n  }\n\n  if (isUndefined(value)) {\n    element = toNode(element);\n    return element && element.getAttribute(name);\n  } else {\n    toNodes(element).forEach(function (element) {\n      if (isFunction(value)) {\n        value = value.call(element, attr(element, name));\n      }\n\n      if (value === null) {\n        removeAttr(element, name);\n      } else {\n        element.setAttribute(name, value);\n      }\n    });\n  }\n}\n\nfunction hasAttr(element, name) {\n  return toNodes(element).some(function (element) {\n    return element.hasAttribute(name);\n  });\n}\n\nfunction removeAttr(element, name) {\n  element = toNodes(element);\n  name.split(' ').forEach(function (name) {\n    return element.forEach(function (element) {\n      return element.removeAttribute(name);\n    });\n  });\n}\n\nfunction filterAttr(element, attribute, pattern, replacement) {\n  attr(element, attribute, function (value) {\n    return value ? value.replace(pattern, replacement) : value;\n  });\n}\n\nfunction data(element, attribute) {\n  for (var i = 0, attrs = [attribute, \"data-\" + attribute]; i < attrs.length; i++) {\n    if (hasAttr(element, attrs[i])) {\n      return attr(element, attrs[i]);\n    }\n  }\n}\n\nfunction query(selector, context) {\n  return toNode(selector) || find(selector, isContextSelector(selector) ? context : document);\n}\n\nfunction find(selector, context) {\n  return toNode(_query(selector, context, 'querySelector'));\n}\n\nfunction findAll(selector, context) {\n  return toNodes(_query(selector, context, 'querySelectorAll'));\n}\n\nfunction _query(selector, context, queryFn) {\n  if (context === void 0) context = document;\n\n  if (!selector || !isString(selector)) {\n    return null;\n  }\n\n  selector = selector.replace(contextSanitizeRe, '$1 *');\n  var removes;\n\n  if (isContextSelector(selector)) {\n    removes = [];\n    selector = selector.split(',').map(function (selector, i) {\n      var ctx = context;\n      selector = selector.trim();\n\n      if (selector[0] === '!') {\n        var selectors = selector.substr(1).trim().split(' ');\n        ctx = closest(context.parentNode, selectors[0]);\n        selector = selectors.slice(1).join(' ');\n      }\n\n      if (!ctx) {\n        return null;\n      }\n\n      if (!ctx.id) {\n        ctx.id = \"uk-\" + Date.now() + i;\n        removes.push(function () {\n          return removeAttr(ctx, 'id');\n        });\n      }\n\n      return \"#\" + escape(ctx.id) + \" \" + selector;\n    }).filter(Boolean).join(',');\n    context = document;\n  }\n\n  try {\n    return context[queryFn](selector);\n  } catch (e) {\n    return null;\n  } finally {\n    removes && removes.forEach(function (remove) {\n      return remove();\n    });\n  }\n}\n\nvar contextSelectorRe = /(^|,)\\s*[!>+~]/;\nvar contextSanitizeRe = /([!>+~])(?=\\s+[!>+~]|\\s*$)/g;\n\nfunction isContextSelector(selector) {\n  return isString(selector) && selector.match(contextSelectorRe);\n}\n\nfunction matches(element, selector) {\n  var elProto = window.Element.prototype;\n  var matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;\n  return toNodes(element).some(function (element) {\n    return matchesFn.call(element, selector);\n  });\n}\n\nfunction closest(element, selector) {\n  var elProto = window.Element.prototype;\n\n  var closestFn = elProto.closest || function (selector) {\n    var ancestor = this;\n\n    do {\n      if (matches(ancestor, selector)) {\n        return ancestor;\n      }\n\n      ancestor = ancestor.parentNode;\n    } while (ancestor && ancestor.nodeType === 1);\n  };\n\n  if (startsWith(selector, '>')) {\n    selector = selector.slice(1);\n  }\n\n  return isNode(element) ? element.parentNode && closestFn.call(element, selector) : toNodes(element).map(function (element) {\n    return element.parentNode && closestFn.call(element, selector);\n  }).filter(Boolean);\n}\n\nfunction escape(css) {\n  var escapeFn = window.CSS && CSS.escape || function (css) {\n    return css.replace(/([^\\x7f-\\uFFFF\\w-])/g, function (match) {\n      return \"\\\\\" + match;\n    });\n  };\n\n  return isString(css) ? escapeFn.call(null, css) : '';\n}\n\nfunction isVisible(element) {\n  return toNodes(element).some(function (element) {\n    return element.offsetHeight || element.getBoundingClientRect().height;\n  });\n}\n\nfunction filter(element, selector) {\n  return toNodes(element).filter(function (element) {\n    return matches(element, selector);\n  });\n}\n\nfunction within(element, selector) {\n  return !isString(selector) ? element === selector || (isDocument(selector) ? selector.documentElement : toNode(selector)).contains(toNode(element)) : matches(element, selector) || closest(element, selector);\n}\n\nfunction on() {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) args[len] = arguments[len];\n\n  var ref = getArgs(args);\n  var target = ref[0];\n  var type = ref[1];\n  var selector = ref[2];\n  var listener = ref[3];\n  var useCapture = ref[4];\n  target = toEventTarget(target);\n\n  if (selector) {\n    listener = delegate(target, selector, listener);\n  }\n\n  if (listener.length > 1) {\n    listener = detail(listener);\n  }\n\n  type.split(' ').forEach(function (type) {\n    return target && target.addEventListener(type, listener, useCapture);\n  });\n  return function () {\n    return off(target, type, listener, useCapture);\n  };\n}\n\nfunction off(target, type, listener, useCapture) {\n  if (useCapture === void 0) useCapture = false;\n  target = toEventTarget(target);\n  target && type.split(' ').forEach(function (type) {\n    return target.removeEventListener(type, listener, useCapture);\n  });\n}\n\nfunction once() {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) args[len] = arguments[len];\n\n  var ref = getArgs(args);\n  var element = ref[0];\n  var type = ref[1];\n  var selector = ref[2];\n  var listener = ref[3];\n  var useCapture = ref[4];\n  var condition = ref[5];\n  var off = on(element, type, selector, function (e) {\n    var result = !condition || condition(e);\n\n    if (result) {\n      off();\n      listener(e, result);\n    }\n  }, useCapture);\n  return off;\n}\n\nfunction trigger(target, event, detail) {\n  return toEventTargets(target).reduce(function (notCanceled, target) {\n    return notCanceled && target.dispatchEvent(createEvent(event, true, true, detail));\n  }, true);\n}\n\nfunction createEvent(e, bubbles, cancelable, detail) {\n  if (bubbles === void 0) bubbles = true;\n  if (cancelable === void 0) cancelable = false;\n\n  if (isString(e)) {\n    var event = document.createEvent('CustomEvent');\n    event.initCustomEvent(e, bubbles, cancelable, detail);\n    e = event;\n  }\n\n  return e;\n}\n\nfunction getArgs(args) {\n  if (isString(args[0])) {\n    args[0] = find(args[0]);\n  }\n\n  if (isFunction(args[2])) {\n    args.splice(2, 0, false);\n  }\n\n  return args;\n}\n\nfunction delegate(element, selector, listener) {\n  var this$1 = this;\n  return function (e) {\n    var target = e.target;\n    var current = selector[0] === '>' ? findAll(selector, element).reverse().filter(function (element) {\n      return within(target, element);\n    })[0] : closest(target, selector);\n\n    if (current) {\n      e.delegate = element;\n      e.current = current;\n      listener.call(this$1, e);\n    }\n  };\n}\n\nfunction detail(listener) {\n  return function (e) {\n    return isArray(e.detail) ? listener.apply(listener, [e].concat(e.detail)) : listener(e);\n  };\n}\n\nfunction isEventTarget(target) {\n  return typeof window !== 'undefined' && 'EventTarget' in window ? target instanceof window.EventTarget : target && 'addEventListener' in target;\n}\n\nfunction toEventTarget(target) {\n  return isEventTarget(target) ? target : toNode(target);\n}\n\nfunction toEventTargets(target) {\n  return isEventTarget(target) ? [target] : isArray(target) ? target.map(toEventTarget).filter(Boolean) : toNodes(target);\n}\n\nvar doc = typeof document !== 'undefined' && document;\n\nfunction isReady() {\n  return doc && (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll);\n}\n\nfunction ready(fn) {\n  if (!doc) {\n    return;\n  }\n\n  if (isReady()) {\n    fn();\n    return;\n  }\n\n  var handle = function () {\n    unbind1();\n    unbind2();\n    fn();\n  };\n\n  var unbind1 = on(document, 'DOMContentLoaded', handle);\n  var unbind2 = on(window, 'load', handle);\n}\n\nfunction append(parent, element) {\n  parent = toNode(parent);\n  return insertNodes(element, function (element) {\n    return parent.appendChild(element);\n  });\n}\n\nfunction before(ref, element) {\n  ref = toNode(ref);\n  return insertNodes(element, function (element) {\n    return ref.parentNode.insertBefore(element, ref);\n  });\n}\n\nfunction after(ref, element) {\n  ref = toNode(ref);\n  return insertNodes(element, function (element) {\n    return ref.nextSibling ? before(ref.nextSibling, element) : append(ref.parentNode, element);\n  });\n}\n\nfunction insertNodes(element, fn) {\n  element = isString(element) ? fragment(element) : element;\n  return element ? 'length' in element ? toNodes(element).map(fn) : fn(element) : null;\n}\n\nfunction remove(element) {\n  toNodes(element).map(function (element) {\n    return element.parentNode && element.parentNode.removeChild(element);\n  });\n}\n\nvar fragmentRE = /^\\s*<(\\w+|!)[^>]*>/;\nvar singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\nfunction fragment(html) {\n  var matches = singleTagRE.exec(html);\n\n  if (matches) {\n    return document.createElement(matches[1]);\n  }\n\n  var container = document.createElement('div');\n\n  if (fragmentRE.test(html)) {\n    container.insertAdjacentHTML('beforeend', html.trim());\n  } else {\n    container.textContent = html;\n  }\n\n  return container.childNodes.length > 1 ? toNodes(container.childNodes) : container.firstChild;\n}\n\nfunction addClass(element) {\n  var args = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) args[len] = arguments[len + 1];\n\n  apply$1(element, args, 'add');\n}\n\nfunction removeClass(element) {\n  var args = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) args[len] = arguments[len + 1];\n\n  apply$1(element, args, 'remove');\n}\n\nfunction removeClasses(element, cls) {\n  filterAttr(element, 'class', new RegExp(\"(^|\\\\s)\" + cls + \"(?!\\\\S)\", 'g'), '');\n}\n\nfunction replaceClass(element) {\n  var args = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) args[len] = arguments[len + 1];\n\n  args[0] && removeClass(element, args[0]);\n  args[1] && addClass(element, args[1]);\n}\n\nfunction hasClass(element, cls) {\n  return toNodes(element).some(function (element) {\n    return element.classList.contains(cls);\n  });\n}\n\nfunction toggleClass(element) {\n  var args = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) args[len] = arguments[len + 1];\n\n  if (!args.length) {\n    return;\n  }\n\n  args = getArgs$1(args);\n  var force = !isString(args[args.length - 1]) ? args.pop() : [];\n  args = args.filter(Boolean);\n  toNodes(element).forEach(function (ref) {\n    var classList = ref.classList;\n\n    for (var i = 0; i < args.length; i++) {\n      supports.Force ? classList.toggle.apply(classList, [args[i]].concat(force)) : classList[(!isUndefined(force) ? force : !classList.contains(args[i])) ? 'add' : 'remove'](args[i]);\n    }\n  });\n}\n\nfunction apply$1(element, args, fn) {\n  args = getArgs$1(args).filter(Boolean);\n  args.length && toNodes(element).forEach(function (ref) {\n    var classList = ref.classList;\n    supports.Multiple ? classList[fn].apply(classList, args) : args.forEach(function (cls) {\n      return classList[fn](cls);\n    });\n  });\n}\n\nfunction getArgs$1(args) {\n  return args.reduce(function (args, arg) {\n    return args.concat.call(args, isString(arg) && includes(arg, ' ') ? arg.trim().split(' ') : arg);\n  }, []);\n}\n\nvar supports = {};\n\n(function () {\n  if (typeof document !== 'undefined' && document.createElement('_').classList) {\n    var list = document.createElement('_').classList;\n    list.add('a', 'b');\n    list.toggle('c', false);\n    supports.Multiple = list.contains('b');\n    supports.Force = !list.contains('c');\n    list = null;\n  }\n})();\n\nvar cssNumber = {\n  'animation-iteration-count': true,\n  'column-count': true,\n  'fill-opacity': true,\n  'flex-grow': true,\n  'flex-shrink': true,\n  'font-weight': true,\n  'line-height': true,\n  'opacity': true,\n  'order': true,\n  'orphans': true,\n  'widows': true,\n  'z-index': true,\n  'zoom': true\n};\n\nfunction css(element, property, value) {\n  return toNodes(element).map(function (element) {\n    if (isString(property)) {\n      property = propName(property);\n\n      if (isUndefined(value)) {\n        return getStyle(element, property);\n      } else if (!value && value !== 0) {\n        element.style.removeProperty(property);\n      } else {\n        element.style[property] = isNumeric(value) && !cssNumber[property] ? value + \"px\" : value;\n      }\n    } else if (isArray(property)) {\n      var styles = getStyles(element);\n      return property.reduce(function (props, property) {\n        props[property] = styles[propName(property)];\n        return props;\n      }, {});\n    } else if (isObject(property)) {\n      each(property, function (value, property) {\n        return css(element, property, value);\n      });\n    }\n\n    return element;\n  })[0];\n}\n\nfunction getStyles(element, pseudoElt) {\n  element = toNode(element);\n  return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElt);\n}\n\nfunction getStyle(element, property, pseudoElt) {\n  return getStyles(element, pseudoElt)[property];\n}\n\nvar vars = {};\n\nfunction getCssVar(name) {\n  if (!(name in vars)) {\n    var element = append(document.documentElement, document.createElement('div'));\n    addClass(element, \"var-\" + name);\n\n    try {\n      vars[name] = getStyle(element, 'content', ':before').replace(/^[\"'](.*)[\"']$/, '$1');\n      vars[name] = JSON.parse(vars[name]);\n    } catch (e) {}\n\n    document.documentElement.removeChild(element);\n  }\n\n  return vars[name];\n}\n\nvar cssProps = {};\n\nfunction propName(name) {\n  var ret = cssProps[name];\n\n  if (!ret) {\n    ret = cssProps[name] = vendorPropName(name) || name;\n  }\n\n  return ret;\n}\n\nvar cssPrefixes = ['webkit', 'moz', 'ms'];\n\nfunction vendorPropName(name) {\n  var ref = document.createElement('_');\n  var style = ref.style;\n  name = hyphenate(name);\n\n  if (name in style) {\n    return name;\n  }\n\n  var i = cssPrefixes.length,\n      prefixedName;\n\n  while (i--) {\n    prefixedName = \"-\" + cssPrefixes[i] + \"-\" + name;\n\n    if (prefixedName in style) {\n      return prefixedName;\n    }\n  }\n}\n\nfunction toMedia(value) {\n  if (isString(value)) {\n    if (value[0] === '@') {\n      var name = \"media-\" + value.substr(1);\n      value = toFloat(getCssVar(name));\n    } else if (isNaN(value)) {\n      return value;\n    }\n  }\n\n  return value && !isNaN(value) ? \"(min-width: \" + value + \"px)\" : false;\n}\n\nfunction get(obj, path, defVal) {\n  var result = isObject(obj) && isString(path) ? _get(obj, path) : undefined;\n  return result === undefined ? defVal : result;\n}\n\nfunction _get(obj, path) {\n  return path.split('.').reduce(function (acc, val) {\n    return acc && acc[val];\n  }, obj);\n}\n\nfunction range(start, stop, step) {\n  if (step === void 0) step = 1;\n\n  if (typeof stop === 'undefined') {\n    stop = start;\n    start = 0;\n  }\n\n  return Array.from(new Array(Math.floor((stop - start) / step)), function (x, i) {\n    return start + i * step;\n  });\n}\n\nfunction findParent(instance) {\n  return findParents(instance).pop();\n}\n\nfunction findParents(instance) {\n  var parents = [];\n  var name = instance.$options.name;\n  var parent = instance.$parent;\n\n  while (parent) {\n    if (parent.$options.name === name) {\n      parents.unshift(parent);\n    }\n\n    parent = parent.$parent;\n  }\n\n  return parents;\n}\n\nfunction apply$2(instance, fn) {\n  if (!instance || !instance._isVue) {\n    return;\n  }\n\n  fn(instance);\n  instance.$children.forEach(function (child) {\n    return apply$2(child, fn);\n  });\n}\n\nfunction filterOutTextNodes(nodes) {\n  return nodes.filter(function (n) {\n    return n.tag || isAsyncPlaceholder(n);\n  });\n}\n\nfunction isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n\nfunction mergeData() {\n  var arguments$1 = arguments;\n\n  for (var e, a, s = {}, t = arguments.length; t--;) {\n    for (var r = 0, c = Object.keys(arguments[t]); r < c.length; r++) {\n      switch (e = c[r]) {\n        case \"class\":\n        case \"style\":\n        case \"directives\":\n          Array.isArray(s[e]) || (s[e] = []), s[e] = s[e].concat(arguments$1[t][e]);\n          break;\n\n        case \"staticClass\":\n          if (!arguments$1[t][e]) {\n            break;\n          }\n\n          void 0 === s[e] && (s[e] = \"\"), s[e] && (s[e] += \" \"), s[e] += arguments$1[t][e].trim();\n          break;\n\n        case \"on\":\n        case \"nativeOn\":\n          s[e] || (s[e] = {});\n\n          for (var o = 0, n = Object.keys(arguments[t][e]); o < n.length; o++) {\n            a = n[o], s[e][a] ? s[e][a] = [].concat(s[e][a], arguments$1[t][e][a]) : s[e][a] = arguments$1[t][e][a];\n          }\n\n          break;\n\n        case \"attrs\":\n        case \"props\":\n        case \"domProps\":\n        case \"scopedSlots\":\n        case \"staticStyle\":\n        case \"hook\":\n        case \"transition\":\n          s[e] || (s[e] = {}), s[e] = __assign({}, arguments$1[t][e], s[e]);\n          break;\n\n        case \"slot\":\n        case \"key\":\n        case \"ref\":\n        case \"tag\":\n        case \"show\":\n        case \"keepAlive\":\n        default:\n          s[e] || (s[e] = arguments$1[t][e]);\n      }\n    }\n  }\n\n  return s;\n}\n\nvar __assign = Object.assign || function (e) {\n  var arguments$1 = arguments;\n\n  for (var a, s = 1, t = arguments.length; s < t; s++) {\n    a = arguments$1[s];\n\n    for (var r in a) {\n      Object.prototype.hasOwnProperty.call(a, r) && (e[r] = a[r]);\n    }\n  }\n\n  return e;\n};\n\nvar ElementBreadcrumb = {\n  functional: true,\n  render: function (h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    return h('ul', mergeData(data, {\n      class: 'uk-breadcrumb'\n    }), children);\n  }\n};\nvar ElementBreadcrumbItem = {\n  functional: true,\n  props: {\n    href: String,\n    target: String,\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function (h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var disabled = props.disabled;\n    var href = props.href;\n    var target = props.target;\n    return h('li', mergeData(data, {\n      class: {\n        'uk-disabled': disabled\n      }\n    }), [isUndefined(href) || disabled ? h('span', children) : h('a', {\n      attrs: {\n        href: href,\n        target: target\n      }\n    }, children)]);\n  }\n};\nvar breadcrumb = {\n  name: 'VkBreadcrumb',\n  functional: true,\n  props: ElementBreadcrumb.props,\n  render: ElementBreadcrumb.render\n};\nvar breadcrumb_Item = {\n  name: 'VkBreadcrumbItem',\n  functional: true,\n  props: ElementBreadcrumbItem.props,\n  render: ElementBreadcrumbItem.render\n};\nvar props = {\n  active: {\n    type: Boolean,\n    default: false\n  },\n  size: {\n    type: String,\n    validator: function (val) {\n      return !val || /^(small|large)$/.test(val);\n    }\n  },\n  type: {\n    type: String,\n    validator: function (val) {\n      return !val || /^(primary|secondary|danger|text|link)$/.test(val);\n    }\n  }\n};\n\nvar def = function (ref) {\n  var obj;\n  var type = ref.type;\n  var active = ref.active;\n  var size = ref.size;\n  return {\n    class: ['uk-button', \"uk-button-\" + (type || 'default'), (obj = {\n      'uk-active': active\n    }, obj[\"uk-button-\" + size] = size, obj)]\n  };\n};\n\nvar ElementButton = {\n  functional: true,\n  props: assign({}, props, {\n    htmlType: {\n      type: String,\n      default: 'button'\n    }\n  }),\n  render: function render(h, ref) {\n    var props$$1 = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var htmlType = props$$1.htmlType;\n    return h('button', mergeData(data, def(props$$1), {\n      attrs: {\n        type: htmlType\n      }\n    }), children);\n  }\n};\nvar ElementButtonLink = {\n  functional: true,\n  props: props,\n  render: function render(h, ref) {\n    var props$$1 = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    return h('a', mergeData(data, def(props$$1)), children);\n  }\n};\nvar ElementButtonGroup = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-button-group'\n    }), children);\n  }\n};\nvar button = {\n  name: 'VkButton',\n  functional: true,\n  props: ElementButton.props,\n  render: ElementButton.render\n};\nvar buttonLink = {\n  name: 'VkButtonLink',\n  functional: true,\n  props: ElementButtonLink.props,\n  render: ElementButtonLink.render\n};\nvar buttonGroup = {\n  name: 'VkButtonGroup',\n  functional: true,\n  props: ElementButtonGroup.props,\n  render: ElementButtonGroup.render\n};\nvar ElementCard = {\n  functional: true,\n  props: {\n    type: {\n      type: String,\n      default: 'default',\n      validator: function (val) {\n        return /^(default|primary|secondary|blank)$/.test(val);\n      }\n    },\n    padding: {\n      type: String,\n      validator: function (val) {\n        return !val || /^(small|large)$/.test(val);\n      }\n    },\n    hover: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var props = ref.props;\n    var data = ref.data;\n    var slots = ref.slots;\n    var type = props.type;\n    var padding = props.padding;\n    var hover = props.hover;\n\n    var _slots = slots();\n\n    var body = _slots.body;\n\n    if (!body || !body.length) {\n      _slots.body = _slots.default;\n      delete _slots.default;\n    }\n\n    return h('div', mergeData(data, {\n      class: ['uk-card', (obj = {\n        'uk-card-hover': hover\n      }, obj[\"uk-card-\" + type] = type, obj[\"uk-card-\" + padding] = padding, obj)]\n    }), [_slots.default && _slots.default, _slots['media-top'] && h('div', {\n      class: 'uk-card-media-top'\n    }, _slots['media-top']), _slots.badge && h('div', {\n      class: 'uk-card-badge'\n    }, _slots.badge), _slots.header && h('div', {\n      class: 'uk-card-header'\n    }, _slots.header), _slots['media'] && h('div', {\n      class: 'uk-card-media'\n    }, _slots['media']), _slots.body && h('div', {\n      class: 'uk-card-body'\n    }, _slots.body), _slots.footer && h('div', {\n      class: 'uk-card-footer'\n    }, _slots.footer), _slots['media-bottom'] && h('div', {\n      class: 'uk-card-media-bottom'\n    }, _slots['media-bottom'])]);\n  }\n};\nvar ElementCardTitle = {\n  functional: true,\n  props: {\n    tag: {\n      type: String,\n      default: 'h3'\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    return h(props.tag, mergeData(data, {\n      class: 'uk-card-title'\n    }), children);\n  }\n};\nvar card = {\n  name: 'VkCard',\n  functional: true,\n  props: ElementCard.props,\n  render: ElementCard.render\n};\nvar card_Title = {\n  name: 'VkCardTitle',\n  functional: true,\n  props: ElementCardTitle.props,\n  render: ElementCardTitle.render\n};\nvar VkRoot = {\n  inserted: function inserted(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      vnode.context.$root.$el.appendChild(el);\n    });\n  }\n};\n\nfunction noop$1() {}\n\nvar warn = noop$1;\nvar tip = noop$1;\n\nif (false) { var generateComponentTrace, repeat, formatComponentName, classify, classifyRE, hasConsole; }\n\nvar dirs = {\n  width: ['x', 'left', 'right'],\n  height: ['y', 'top', 'bottom']\n};\n\nfunction positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {\n  elAttach = getPos(elAttach);\n  targetAttach = getPos(targetAttach);\n  var flipped = {\n    element: elAttach,\n    target: targetAttach\n  };\n\n  if (!element || !target) {\n    return flipped;\n  }\n\n  var dim = getDimensions(element);\n  var targetDim = getDimensions(target);\n  var position = targetDim;\n  moveTo(position, elAttach, dim, -1);\n  moveTo(position, targetAttach, targetDim, 1);\n  elOffset = getOffsets(elOffset, dim.width, dim.height);\n  targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);\n  elOffset['x'] += targetOffset['x'];\n  elOffset['y'] += targetOffset['y'];\n  position.left += elOffset['x'];\n  position.top += elOffset['y'];\n  boundary = getDimensions(boundary || window$1(element));\n\n  if (flip) {\n    each(dirs, function (ref, prop) {\n      var dir = ref[0];\n      var align = ref[1];\n      var alignFlip = ref[2];\n\n      if (!(flip === true || includes(flip, dir))) {\n        return;\n      }\n\n      var elemOffset = elAttach[dir] === align ? -dim[prop] : elAttach[dir] === alignFlip ? dim[prop] : 0;\n      var targetOffset = targetAttach[dir] === align ? targetDim[prop] : targetAttach[dir] === alignFlip ? -targetDim[prop] : 0;\n\n      if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {\n        var centerOffset = dim[prop] / 2;\n        var centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;\n        elAttach[dir] === 'center' && (apply(centerOffset, centerTargetOffset) || apply(-centerOffset, -centerTargetOffset)) || apply(elemOffset, targetOffset);\n      }\n\n      function apply(elemOffset, targetOffset) {\n        var newVal = position[align] + elemOffset + targetOffset - elOffset[dir] * 2;\n\n        if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {\n          position[align] = newVal;\n          ['element', 'target'].forEach(function (el) {\n            flipped[el][dir] = !elemOffset ? flipped[el][dir] : flipped[el][dir] === dirs[prop][1] ? dirs[prop][2] : dirs[prop][1];\n          });\n          return true;\n        }\n      }\n    });\n  }\n\n  offset(element, position);\n  return flipped;\n}\n\nfunction offset(element, coordinates) {\n  element = toNode(element);\n\n  if (coordinates) {\n    var currentOffset = offset(element);\n    var pos = css(element, 'position');\n    ['left', 'top'].forEach(function (prop) {\n      if (prop in coordinates) {\n        var value = css(element, prop);\n        element.style[prop] = coordinates[prop] - currentOffset[prop] + toFloat(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value) + \"px\";\n      }\n    });\n    return;\n  }\n\n  return getDimensions(element);\n}\n\nfunction getDimensions(element) {\n  element = toNode(element);\n  var ref = window$1(element);\n  var top = ref.pageYOffset;\n  var left = ref.pageXOffset;\n\n  if (isWindow(element)) {\n    var height = element.innerHeight;\n    var width = element.innerWidth;\n    return {\n      top: top,\n      left: left,\n      height: height,\n      width: width,\n      bottom: top + height,\n      right: left + width\n    };\n  }\n\n  var display = false;\n\n  if (!isVisible(element)) {\n    display = element.style.display;\n    element.style.display = 'block';\n  }\n\n  var rect = element.getBoundingClientRect();\n\n  if (display !== false) {\n    element.style.display = display;\n  }\n\n  return {\n    height: rect.height,\n    width: rect.width,\n    top: rect.top + top,\n    left: rect.left + left,\n    bottom: rect.bottom + top,\n    right: rect.right + left\n  };\n}\n\nfunction position(element) {\n  element = toNode(element);\n  var parent = offsetParent(element);\n  var parentOffset = parent === docEl(element) ? {\n    top: 0,\n    left: 0\n  } : offset(parent);\n  var ref = ['top', 'left'].reduce(function (props, prop) {\n    var propName$$1 = ucfirst(prop);\n    props[prop] -= parentOffset[prop] + (toFloat(css(element, \"margin\" + propName$$1)) || 0) + (toFloat(css(parent, \"border\" + propName$$1 + \"Width\")) || 0);\n    return props;\n  }, offset(element));\n  var top = ref.top;\n  var left = ref.left;\n  return {\n    top: top,\n    left: left\n  };\n}\n\nfunction offsetParent(element) {\n  var parent = toNode(element).offsetParent;\n\n  while (parent && css(parent, 'position') === 'static') {\n    parent = parent.offsetParent;\n  }\n\n  return parent || docEl(element);\n}\n\nvar height = dimension('height');\nvar width = dimension('width');\n\nfunction dimension(prop) {\n  var propName$$1 = ucfirst(prop);\n  return function (element, value) {\n    element = toNode(element);\n\n    if (isUndefined(value)) {\n      if (isWindow(element)) {\n        return element[\"inner\" + propName$$1];\n      }\n\n      if (isDocument(element)) {\n        var doc = element.documentElement;\n        return Math.max(doc[\"offset\" + propName$$1], doc[\"scroll\" + propName$$1]);\n      }\n\n      value = css(element, prop);\n      value = value === 'auto' ? element[\"offset\" + propName$$1] : toFloat(value) || 0;\n      return getContentSize(prop, element, value);\n    } else {\n      css(element, prop, !value && value !== 0 ? '' : getContentSize(prop, element, value) + 'px');\n    }\n  };\n}\n\nfunction getContentSize(prop, element, value) {\n  return css(element, 'boxSizing') === 'border-box' ? dirs[prop].slice(1).map(ucfirst).reduce(function (value, prop) {\n    return value - toFloat(css(element, \"padding\" + prop)) - toFloat(css(element, \"border\" + prop + \"Width\"));\n  }, value) : value;\n}\n\nfunction moveTo(position, attach, dim, factor) {\n  each(dirs, function (ref, prop) {\n    var dir = ref[0];\n    var align = ref[1];\n    var alignFlip = ref[2];\n\n    if (attach[dir] === alignFlip) {\n      position[align] += dim[prop] * factor;\n    } else if (attach[dir] === 'center') {\n      position[align] += dim[prop] * factor / 2;\n    }\n  });\n}\n\nfunction getPos(pos) {\n  var x = /left|center|right/;\n  var y = /top|center|bottom/;\n  pos = (pos || '').split(' ');\n\n  if (pos.length === 1) {\n    pos = x.test(pos[0]) ? pos.concat(['center']) : y.test(pos[0]) ? ['center'].concat(pos) : ['center', 'center'];\n  }\n\n  return {\n    x: x.test(pos[0]) ? pos[0] : 'center',\n    y: y.test(pos[1]) ? pos[1] : 'center'\n  };\n}\n\nfunction getOffsets(offsets, width, height) {\n  var ref = (offsets || '').split(' ');\n  var x = ref[0];\n  var y = ref[1];\n  return {\n    x: x ? toFloat(x) * (endsWith(x, '%') ? width / 100 : 1) : 0,\n    y: y ? toFloat(y) * (endsWith(y, '%') ? height / 100 : 1) : 0\n  };\n}\n\nfunction flipPosition(pos) {\n  switch (pos) {\n    case 'left':\n      return 'right';\n\n    case 'right':\n      return 'left';\n\n    case 'top':\n      return 'bottom';\n\n    case 'bottom':\n      return 'top';\n\n    default:\n      return pos;\n  }\n}\n\nfunction isInView(element, top, left) {\n  if (top === void 0) top = 0;\n  if (left === void 0) left = 0;\n  element = toNode(element);\n  var win = window$1(element);\n  return intersectRect(element.getBoundingClientRect(), {\n    top: top,\n    left: left,\n    bottom: top + height(win),\n    right: left + width(win)\n  });\n}\n\nfunction window$1(element) {\n  return isWindow(element) ? element : document$1(element).defaultView;\n}\n\nfunction document$1(element) {\n  return toNode(element).ownerDocument;\n}\n\nfunction docEl(element) {\n  return document$1(element).documentElement;\n}\n\nvar BEFORE_POSITION = 'v-vk-position:before';\nvar AFTER_POSITION = 'v-vk-position:after';\nvar Directive = {\n  inserted: function inserted(el, binding, vnode) {\n    var ctx = getContext(el, binding, vnode);\n\n    if (ctx) {\n      position$1(ctx);\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    var ctx = getContext(el, binding, vnode);\n\n    if (ctx) {\n      position$1(ctx);\n    }\n  }\n};\n\nfunction position$1(ctx) {\n  var el = ctx.el;\n  var props = ctx.props;\n  var vnode = ctx.vnode;\n  var target = props.target;\n  var position$$1 = props.position;\n  var offset$$1 = props.offset;\n  var boundary = props.boundary;\n  var flip = props.flip;\n  var mainClass = props.mainClass;\n\n  if (false) {}\n\n  if (false) {}\n\n  var ref = position$$1.split('-');\n  var dir = ref[0];\n  var align = ref[1];\n  trigger(el, BEFORE_POSITION);\n  var classesRx = new RegExp(mainClass + \"-(top|bottom|left|right)(-[a-z]+)?\");\n  el.className = el.className.replace(classesRx, '');\n  css(el, {\n    top: '',\n    left: ''\n  });\n  var axis = getPositionAxis(position$$1);\n  var elAttach = axis === 'x' ? flipPosition(dir) + \" \" + align : align + \" \" + flipPosition(dir);\n  var targetAttach = axis === 'x' ? dir + \" \" + align : align + \" \" + dir;\n  var elOffset = axis === 'x' ? \"\" + (dir === 'left' ? -1 * offset$$1 : offset$$1) : \" \" + (dir === 'top' ? -1 * offset$$1 : offset$$1);\n  var targetOffset = null;\n  var ref$1 = positionAt(el, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary).target;\n  var x = ref$1.x;\n  var y = ref$1.y;\n  dir = axis === 'x' ? x : y;\n  align = axis === 'x' ? y : x;\n  toggleClass(el, mainClass + \"-\" + dir + \"-\" + align, offset$$1 === false);\n  trigger(el, AFTER_POSITION);\n}\n\nfunction getOptions(ctx) {\n  var vnode = ctx.vnode;\n  var ref = ctx.binding;\n  var value = ref.value;\n\n  if (false) {}\n\n  var options = assign({\n    target: null,\n    position: 'top-center',\n    boundary: window,\n    flip: true,\n    offset: false,\n    mainClass: ''\n  }, value);\n  return options;\n}\n\nfunction getContext(el, binding, vnode) {\n  var ctx = {\n    el: el,\n    binding: binding,\n    vnode: vnode\n  };\n  ctx.props = getOptions(ctx);\n\n  if (!ctx.props) {\n    binding.def.unbind(el, binding);\n    return;\n  }\n\n  return ctx;\n}\n\nfunction getPositionAxis(position$$1) {\n  var ref = position$$1.split('-');\n  var dir = ref[0];\n  return dir === 'top' || dir === 'bottom' ? 'y' : 'x';\n}\n\nvar EventsMixin = {\n  methods: {\n    on: function on$1() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      this._vk_events_off.push(on.apply(void 0, args));\n    },\n    off: function off$1() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      off.apply(void 0, args);\n    }\n  },\n  created: function created() {\n    this._vk_events_off = [];\n  },\n  beforeDestroy: function beforeDestroy() {\n    this._vk_events_off.forEach(function (off$$1) {\n      return off$$1();\n    });\n  }\n};\n\nfunction $(selector, context) {\n  return !isString(selector) ? toNode(selector) : isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);\n}\n\nfunction $$(selector, context) {\n  return !isString(selector) ? toNodes(selector) : isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);\n}\n\nfunction isHtml(str) {\n  return str[0] === '<' || str.match(/^\\s*</);\n}\n\nfunction MouseTracker() {}\n\nMouseTracker.prototype = {\n  positions: [],\n  position: null,\n  init: function init() {\n    var this$1 = this;\n    this.positions = [];\n    this.position = null;\n    var ticking = false;\n    this.unbind = on(document, 'mousemove', function (e) {\n      if (ticking) {\n        return;\n      }\n\n      setTimeout(function () {\n        var time = Date.now();\n        var ref = this$1.positions;\n        var length = ref.length;\n\n        if (length && time - this$1.positions[length - 1].time > 100) {\n          this$1.positions.splice(0, length);\n        }\n\n        this$1.positions.push({\n          time: time,\n          x: e.pageX,\n          y: e.pageY\n        });\n\n        if (this$1.positions.length > 5) {\n          this$1.positions.shift();\n        }\n\n        ticking = false;\n      }, 5);\n      ticking = true;\n    });\n  },\n  cancel: function cancel() {\n    if (this.unbind) {\n      this.unbind();\n    }\n  },\n  movesTo: function movesTo(target) {\n    if (this.positions.length < 2) {\n      return false;\n    }\n\n    var p = offset(target);\n    var position$$1 = this.positions[this.positions.length - 1];\n    var ref = this.positions;\n    var prevPos = ref[0];\n\n    if (p.left <= position$$1.x && position$$1.x <= p.right && p.top <= position$$1.y && position$$1.y <= p.bottom) {\n      return false;\n    }\n\n    var points = [[{\n      x: p.left,\n      y: p.top\n    }, {\n      x: p.right,\n      y: p.bottom\n    }], [{\n      x: p.right,\n      y: p.top\n    }, {\n      x: p.left,\n      y: p.bottom\n    }]];\n\n    if (p.right <= position$$1.x) {} else if (p.left >= position$$1.x) {\n      points[0].reverse();\n      points[1].reverse();\n    } else if (p.bottom <= position$$1.y) {\n      points[0].reverse();\n    } else if (p.top >= position$$1.y) {\n      points[1].reverse();\n    }\n\n    return !!points.reduce(function (result, point) {\n      return result + (slope(prevPos, point[0]) < slope(position$$1, point[0]) && slope(prevPos, point[1]) > slope(position$$1, point[1]));\n    }, 0);\n  }\n};\n\nfunction slope(a, b) {\n  return (b.y - a.y) / (b.x - a.x);\n}\n\nvar doc$1 = typeof document !== 'undefined' && document;\nvar win$1 = typeof window !== 'undefined' && window;\nvar nav = typeof navigator !== 'undefined' && navigator;\nvar isRtl = doc$1 && attr(document.documentElement, 'dir') === 'rtl';\nvar hasTouchEvents = win$1 && 'ontouchstart' in window;\nvar hasPointerEvents = win$1 && window.PointerEvent;\nvar hasTouch = hasTouchEvents || win$1 && window.DocumentTouch && doc$1 && document instanceof window.DocumentTouch || nav && navigator.maxTouchPoints;\nvar pointerDown = !hasTouch ? 'mousedown' : \"mousedown \" + (hasTouchEvents ? 'touchstart' : 'pointerdown');\nvar pointerMove = !hasTouch ? 'mousemove' : \"mousemove \" + (hasTouchEvents ? 'touchmove' : 'pointermove');\nvar pointerUp = !hasTouch ? 'mouseup' : \"mouseup \" + (hasTouchEvents ? 'touchend' : 'pointerup');\nvar pointerEnter = hasTouch && hasPointerEvents ? 'pointerenter' : 'mouseenter';\nvar pointerLeave = hasTouch && hasPointerEvents ? 'pointerleave' : 'mouseleave';\nvar props$1 = {\n  target: {},\n  boundary: {},\n  boundaryAlign: {\n    type: Boolean,\n    default: false\n  },\n  flip: {\n    type: [String, Boolean],\n    default: true\n  },\n  position: {\n    type: String,\n    default: \"bottom-\" + (isRtl ? 'right' : 'left'),\n    validator: function (pos) {\n      return /^(top|bottom)-(left|right|center|justify)$/.test(pos) || /^(left|right)-(top|bottom|center|justify)$/.test(pos);\n    }\n  },\n  offset: {\n    type: [Boolean, Number],\n    default: false\n  },\n  animation: {\n    type: String,\n    default: 'fade'\n  },\n  duration: {\n    type: Number,\n    default: 200\n  },\n  mode: {\n    type: String,\n    default: 'click hover'\n  },\n  delayShow: {\n    type: Number,\n    default: 0\n  },\n  delayHide: {\n    type: Number,\n    default: 800\n  },\n  mainClass: {\n    type: String,\n    default: 'uk-drop'\n  }\n};\nvar ElementDrop = {\n  functional: true,\n  props: {\n    show: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var children = ref.children;\n    var data = ref.data;\n    var props = ref.props;\n    var show = props.show;\n    return h('div', mergeData(data, {\n      class: {\n        'uk-open': show\n      },\n      style: {\n        display: show ? 'block' : null\n      }\n    }), children);\n  }\n};\nvar win$2 = typeof window !== 'undefined' && window;\nvar Promise = win$2 && 'Promise' in window ? window.Promise : PromiseFn;\nvar RESOLVED = 0;\nvar REJECTED = 1;\nvar PENDING = 2;\nvar async = win$2 && 'setImmediate' in window ? setImmediate : setTimeout;\n\nfunction PromiseFn(executor) {\n  this.state = PENDING;\n  this.value = undefined;\n  this.deferred = [];\n  var promise = this;\n\n  try {\n    executor(function (x) {\n      promise.resolve(x);\n    }, function (r) {\n      promise.reject(r);\n    });\n  } catch (e) {\n    promise.reject(e);\n  }\n}\n\nPromiseFn.reject = function (r) {\n  return new PromiseFn(function (resolve, reject) {\n    reject(r);\n  });\n};\n\nPromiseFn.resolve = function (x) {\n  return new PromiseFn(function (resolve, reject) {\n    resolve(x);\n  });\n};\n\nPromiseFn.all = function all(iterable) {\n  return new PromiseFn(function (resolve, reject) {\n    var result = [];\n    var count = 0;\n\n    if (iterable.length === 0) {\n      resolve(result);\n    }\n\n    function resolver(i) {\n      return function (x) {\n        result[i] = x;\n        count += 1;\n\n        if (count === iterable.length) {\n          resolve(result);\n        }\n      };\n    }\n\n    for (var i = 0; i < iterable.length; i += 1) {\n      PromiseFn.resolve(iterable[i]).then(resolver(i), reject);\n    }\n  });\n};\n\nPromiseFn.race = function race(iterable) {\n  return new PromiseFn(function (resolve, reject) {\n    for (var i = 0; i < iterable.length; i += 1) {\n      PromiseFn.resolve(iterable[i]).then(resolve, reject);\n    }\n  });\n};\n\nvar p = PromiseFn.prototype;\n\np.resolve = function resolve(x) {\n  var promise = this;\n\n  if (promise.state === PENDING) {\n    if (x === promise) {\n      throw new TypeError('Promise settled with itself.');\n    }\n\n    var called = false;\n\n    try {\n      var then = x && x.then;\n\n      if (x !== null && isObject(x) && isFunction(then)) {\n        then.call(x, function (x) {\n          if (!called) {\n            promise.resolve(x);\n          }\n\n          called = true;\n        }, function (r) {\n          if (!called) {\n            promise.reject(r);\n          }\n\n          called = true;\n        });\n        return;\n      }\n    } catch (e) {\n      if (!called) {\n        promise.reject(e);\n      }\n\n      return;\n    }\n\n    promise.state = RESOLVED;\n    promise.value = x;\n    promise.notify();\n  }\n};\n\np.reject = function reject(reason) {\n  var promise = this;\n\n  if (promise.state === PENDING) {\n    if (reason === promise) {\n      throw new TypeError('Promise settled with itself.');\n    }\n\n    promise.state = REJECTED;\n    promise.value = reason;\n    promise.notify();\n  }\n};\n\np.notify = function notify() {\n  var this$1 = this;\n  async(function () {\n    if (this$1.state !== PENDING) {\n      while (this$1.deferred.length) {\n        var ref = this$1.deferred.shift();\n        var onResolved = ref[0];\n        var onRejected = ref[1];\n        var resolve = ref[2];\n        var reject = ref[3];\n\n        try {\n          if (this$1.state === RESOLVED) {\n            if (isFunction(onResolved)) {\n              resolve(onResolved.call(undefined, this$1.value));\n            } else {\n              resolve(this$1.value);\n            }\n          } else if (this$1.state === REJECTED) {\n            if (isFunction(onRejected)) {\n              resolve(onRejected.call(undefined, this$1.value));\n            } else {\n              reject(this$1.value);\n            }\n          }\n        } catch (e) {\n          reject(e);\n        }\n      }\n    }\n  });\n};\n\np.then = function then(onResolved, onRejected) {\n  var this$1 = this;\n  return new PromiseFn(function (resolve, reject) {\n    this$1.deferred.push([onResolved, onRejected, resolve, reject]);\n    this$1.notify();\n  });\n};\n\np.catch = function (onRejected) {\n  return this.then(undefined, onRejected);\n};\n\nfunction transition(element, props, duration, timing) {\n  if (duration === void 0) duration = 400;\n  if (timing === void 0) timing = 'linear';\n  return Promise.all(toNodes(element).map(function (element) {\n    return new Promise(function (resolve, reject) {\n      for (var name in props) {\n        var value = css(element, name);\n\n        if (value === '') {\n          css(element, name, value);\n        }\n      }\n\n      var timer = setTimeout(function () {\n        return trigger(element, 'transitionend');\n      }, duration);\n      once(element, 'transitionend transitioncanceled', function (ref) {\n        var type = ref.type;\n        clearTimeout(timer);\n        removeClass(element, 'uk-transition');\n        css(element, {\n          'transition-property': '',\n          'transition-duration': '',\n          'transition-timing-function': ''\n        });\n        type === 'transitioncanceled' ? reject() : resolve();\n      }, false, function (ref) {\n        var target = ref.target;\n        return element === target;\n      });\n      addClass(element, 'uk-transition');\n      css(element, assign({\n        'transition-property': Object.keys(props).map(propName).join(','),\n        'transition-duration': duration + \"ms\",\n        'transition-timing-function': timing\n      }, props));\n    });\n  }));\n}\n\nvar Transition = {\n  start: transition,\n  stop: function stop(element) {\n    trigger(element, 'transitionend');\n    return Promise.resolve();\n  },\n  cancel: function cancel(element) {\n    trigger(element, 'transitioncanceled');\n  },\n  inProgress: function inProgress(element) {\n    return hasClass(element, 'uk-transition');\n  }\n};\nvar animationPrefix = 'uk-animation-';\nvar clsCancelAnimation = 'uk-cancel-animation';\n\nfunction animate(element, animation, duration, origin, out) {\n  var arguments$1 = arguments;\n  if (duration === void 0) duration = 200;\n  return Promise.all(toNodes(element).map(function (element) {\n    return new Promise(function (resolve, reject) {\n      if (hasClass(element, clsCancelAnimation)) {\n        requestAnimationFrame(function () {\n          return Promise.resolve().then(function () {\n            return animate.apply(void 0, arguments$1).then(resolve, reject);\n          });\n        });\n        return;\n      }\n\n      var cls = animation + \" \" + animationPrefix + (out ? 'leave' : 'enter');\n\n      if (startsWith(animation, animationPrefix)) {\n        if (origin) {\n          cls += \" uk-transform-origin-\" + origin;\n        }\n\n        if (out) {\n          cls += \" \" + animationPrefix + \"reverse\";\n        }\n      }\n\n      reset();\n      once(element, 'animationend animationcancel', function (ref) {\n        var type = ref.type;\n        var hasReset = false;\n\n        if (type === 'animationcancel') {\n          reject();\n          reset();\n        } else {\n          resolve();\n          Promise.resolve().then(function () {\n            hasReset = true;\n            reset();\n          });\n        }\n\n        requestAnimationFrame(function () {\n          if (!hasReset) {\n            addClass(element, clsCancelAnimation);\n            requestAnimationFrame(function () {\n              return removeClass(element, clsCancelAnimation);\n            });\n          }\n        });\n      }, false, function (ref) {\n        var target = ref.target;\n        return element === target;\n      });\n      css(element, 'animationDuration', duration + \"ms\");\n      addClass(element, cls);\n\n      function reset() {\n        css(element, 'animationDuration', '');\n        removeClasses(element, animationPrefix + \"\\\\S*\");\n      }\n    });\n  }));\n}\n\nvar inProgress = new RegExp(animationPrefix + \"(enter|leave)\");\nvar Animation = {\n  in: function in$1(element, animation, duration, origin) {\n    return animate(element, animation, duration, origin, false);\n  },\n  out: function out(element, animation, duration, origin) {\n    return animate(element, animation, duration, origin, true);\n  },\n  inProgress: function inProgress$1(element) {\n    return inProgress.test(attr(element, 'class'));\n  },\n  cancel: function cancel(element) {\n    trigger(element, 'animationcancel');\n  }\n};\nvar Transition$1 = {\n  name: 'VkTransition',\n  functional: true,\n  props: {\n    name: {\n      type: [String, Array],\n      required: true\n    },\n    duration: {\n      type: Number\n    },\n    mode: {\n      type: String,\n      default: 'out-in'\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var name = props.name;\n    var duration = props.duration;\n    var ref$1 = isString(name) ? [name, name] : name;\n    var animationIn = ref$1[0];\n    var animationOut = ref$1[1];\n    var def = {\n      props: {\n        css: false,\n        mode: props.mode\n      },\n      on: {\n        enter: function enter(el, done) {\n          animationIn ? Animation.in(el, \"uk-animation-\" + animationIn, duration).then(done) : done();\n        },\n        leave: function leave(el, done) {\n          animationOut ? Animation.out(el, \"uk-animation-\" + animationOut, duration).then(done) : done();\n        }\n      }\n    };\n    return h('transition', def, children);\n  }\n};\nvar render = {\n  mounted: function mounted() {\n    this.$refs.target = this.queryElement(this.target) || this.$el.previousElementSibling;\n    this.$refs.boundary = this.queryElement(this.boundary) || window;\n    this.$forceUpdate();\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var obj, obj$1;\n    var ref = this;\n    var position$$1 = ref.position;\n    var ref$1 = this.$refs;\n    var boundary = ref$1.boundary;\n    var target = ref$1.target;\n    var ref$2 = position$$1.split('-');\n    var align = ref$2[1];\n    var ref$3 = this;\n    var boundaryAlign = ref$3.boundaryAlign;\n    var animation = ref$3.animation;\n    var duration = ref$3.duration;\n    var mainClass = ref$3.mainClass;\n    var flip = ref$3.flip;\n    var offset$$1 = ref$3.offset;\n\n    if (!target || !boundary) {\n      return;\n    }\n\n    position$$1 = position$$1.replace('justify', 'center');\n    target = boundaryAlign ? boundary : target;\n    var def = {\n      on: (obj = {}, obj[BEFORE_POSITION] = function (e) {\n        var ref = this$1;\n        var $el = ref.$el;\n        var alignTo = offset(target);\n        var boundaryOffset = offset(boundary);\n        css($el, {\n          width: '',\n          height: ''\n        });\n        removeClass($el, mainClass + \"-stack\");\n\n        if (align === 'justify') {\n          var prop = getAxis(position$$1) === 'y' ? 'width' : 'height';\n          css($el, prop, alignTo[prop]);\n        } else if ($el.offsetWidth > Math.max(boundaryOffset.right - alignTo.left, alignTo.right - boundaryOffset.left)) {\n          addClass($el, mainClass + \"-stack\");\n        }\n      }, obj),\n      props: {\n        show: this.shown\n      },\n      class: [mainClass, (obj$1 = {}, obj$1[mainClass + \"-boundary\"] = this.boundaryAlign, obj$1)],\n      directives: [{\n        name: 'show',\n        value: this.shown\n      }, {\n        name: 'vk-position',\n        value: {\n          flip: flip,\n          offset: offset$$1,\n          target: target,\n          boundary: boundary,\n          position: position$$1,\n          mainClass: mainClass\n        }\n      }]\n    };\n    return h(Transition$1, {\n      props: {\n        name: [animation],\n        duration: duration\n      }\n    }, [h(ElementDrop, def, this.$slots.default)]);\n  }\n};\n\nfunction getAxis(position$$1) {\n  var ref = position$$1.split('-');\n  var dir = ref[0];\n  return dir === 'top' || dir === 'bottom' ? 'y' : 'x';\n}\n\nvar SHOW = 'show';\nvar HIDE = 'hide';\nvar touch = {},\n    clickTimeout,\n    swipeTimeout,\n    tapTimeout,\n    clicked;\n\nfunction swipeDirection(ref) {\n  var x1 = ref.x1;\n  var x2 = ref.x2;\n  var y1 = ref.y1;\n  var y2 = ref.y2;\n  return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? 'Left' : 'Right' : y1 - y2 > 0 ? 'Up' : 'Down';\n}\n\nfunction cancelAll() {\n  clickTimeout && clearTimeout(clickTimeout);\n  swipeTimeout && clearTimeout(swipeTimeout);\n  tapTimeout && clearTimeout(tapTimeout);\n  clickTimeout = swipeTimeout = tapTimeout = null;\n  touch = {};\n}\n\nready(function () {\n  on(document, 'click', function () {\n    return clicked = true;\n  }, true);\n  on(document, pointerDown, function (e) {\n    var target = e.target;\n    var ref = getPos$1(e);\n    var x = ref.x;\n    var y = ref.y;\n    var now = Date.now();\n    var type = getType(e.type);\n\n    if (touch.type && touch.type !== type) {\n      return;\n    }\n\n    touch.el = 'tagName' in target ? target : target.parentNode;\n    clickTimeout && clearTimeout(clickTimeout);\n    touch.x1 = x;\n    touch.y1 = y;\n\n    if (touch.last && now - touch.last <= 250) {\n      touch = {};\n    }\n\n    touch.type = type;\n    touch.last = now;\n    clicked = e.button > 0;\n  });\n  on(document, pointerMove, function (e) {\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    var ref = getPos$1(e);\n    var x = ref.x;\n    var y = ref.y;\n    touch.x2 = x;\n    touch.y2 = y;\n  });\n  on(document, pointerUp, function (ref) {\n    var type = ref.type;\n    var target = ref.target;\n\n    if (touch.type !== getType(type)) {\n      return;\n    }\n\n    if (touch.x2 && Math.abs(touch.x1 - touch.x2) > 30 || touch.y2 && Math.abs(touch.y1 - touch.y2) > 30) {\n      swipeTimeout = setTimeout(function () {\n        if (touch.el) {\n          trigger(touch.el, 'swipe');\n          trigger(touch.el, \"swipe\" + swipeDirection(touch));\n        }\n\n        touch = {};\n      });\n    } else if ('last' in touch) {\n      tapTimeout = setTimeout(function () {\n        return trigger(touch.el, 'tap');\n      });\n\n      if (touch.el && type !== 'mouseup' && within(target, touch.el)) {\n        clickTimeout = setTimeout(function () {\n          clickTimeout = null;\n\n          if (touch.el && !clicked) {\n            trigger(touch.el, 'click');\n          }\n\n          touch = {};\n        }, 350);\n      }\n    } else {\n      touch = {};\n    }\n  });\n  on(document, 'touchcancel', cancelAll);\n  on(window, 'scroll', cancelAll);\n});\nvar touching = false;\n\nif (typeof document !== 'undefined') {\n  on(document, 'touchstart', function () {\n    return touching = true;\n  }, true);\n  on(document, 'click', function () {\n    touching = false;\n  });\n  on(document, 'touchcancel', function () {\n    return touching = false;\n  }, true);\n}\n\nfunction isTouch(e) {\n  return touching || e.pointerType === 'touch';\n}\n\nfunction getPos$1(e) {\n  var touches = e.touches;\n  var changedTouches = e.changedTouches;\n  var ref = touches && touches[0] || changedTouches && changedTouches[0] || e;\n  var x = ref.pageX;\n  var y = ref.pageY;\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction getType(type) {\n  return type.slice(0, 5);\n}\n\nvar active;\n\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\n  on(window, 'resize', function (ref) {\n    var defaultPrevented = ref.defaultPrevented;\n    var justified = active && /justify/.test(active.position);\n\n    if (!defaultPrevented && justified) {\n      active.$forceUpdate();\n    }\n  });\n  on(document.documentElement, 'click', function (ref) {\n    var target = ref.target;\n    var defaultPrevented = ref.defaultPrevented;\n\n    if (defaultPrevented || !active) {\n      return;\n    }\n\n    var clickedInside = function (drop) {\n      return within(target, drop.$el);\n    };\n\n    var clickedTarget = function (drop) {\n      return within(target, drop.$refs.target);\n    };\n\n    while (active && !clickedInside(active) && !clickedTarget(active)) {\n      var parent = findParent(active);\n\n      active._hide();\n\n      active = parent;\n    }\n  });\n}\n\nvar toggle = {\n  data: function () {\n    return {\n      shown: false\n    };\n  },\n  methods: {\n    show: function show() {\n      this.clearTimers();\n      this.showTimer = setTimeout(this._show, this.delayShow);\n    },\n    _show: function _show() {\n      while (active && !this.isChildOf(active) && !this.isParentOf(active)) {\n        var parent = findParent(active);\n\n        active._hide();\n\n        active = parent;\n      }\n\n      this.shown = true;\n      this.tracker.init();\n      active = this;\n      this.$emit(SHOW);\n    },\n    hide: function hide() {\n      var hoverIdle = 200;\n      this.clearTimers();\n      this.isDelaying = this.tracker.movesTo(this.$el);\n\n      if (this.isDelaying) {\n        this.hideTimer = setTimeout(this.hide, hoverIdle);\n      } else {\n        this.hideTimer = setTimeout(this._hide, this.delayHide);\n      }\n    },\n    _hide: function _hide() {\n      this.shown = false;\n      this.tracker.cancel();\n\n      if (active === this) {\n        var parent = findParent(active);\n        active = parent || null;\n      }\n\n      this.$emit(HIDE);\n    },\n    clearTimers: function clearTimers() {\n      clearTimeout(this.showTimer);\n      clearTimeout(this.hideTimer);\n      this.showTimer = null;\n      this.hideTimer = null;\n    },\n    toggle: function toggle() {\n      this.shown ? this._hide() : this.show();\n    }\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n    var ref = this;\n    var on$$1 = ref.on;\n    var show = ref.show;\n    var hide = ref.hide;\n    var toggle = ref.toggle;\n    var mode = ref.mode;\n    var clearTimers = ref.clearTimers;\n    this.$nextTick(function () {\n      if (/click/.test(mode) || hasTouch) {\n        on$$1(this$1.$refs.target, 'click', toggle);\n      }\n\n      if (/hover/.test(mode)) {\n        on$$1(this$1.$refs.target, pointerEnter, function (e) {\n          if (isTouch(e)) {\n            return;\n          }\n\n          e.preventDefault();\n          show();\n        });\n        on$$1(this$1.$refs.target, pointerLeave, function (e) {\n          if (isTouch(e)) {\n            return;\n          }\n\n          e.preventDefault();\n          hide();\n        });\n        on$$1(this$1.$el, pointerLeave, hide);\n        on$$1(this$1.$el, pointerEnter, clearTimers);\n      }\n    });\n  }\n};\nvar Drop = {\n  name: 'VkDrop',\n  mixins: [render, toggle, EventsMixin],\n  directives: {\n    VkRoot: VkRoot,\n    VkPosition: Directive\n  },\n  props: props$1,\n  methods: {\n    isParentOf: function isParentOf(instance) {\n      var parents = findParents(instance);\n      return includes(parents, this);\n    },\n    isChildOf: function isChildOf(instance) {\n      var parents = findParents(this);\n      return includes(parents, instance);\n    },\n    queryElement: function queryElement(el) {\n      return isNode(el) ? el : isString(el) ? get(this.$vnode.context.$refs, el) || $(el, this.$el) : el;\n    }\n  },\n  created: function created() {\n    this.tracker = new MouseTracker();\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this.$el.parentNode) {\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n};\nvar Dropdown = {\n  name: 'VkDropdown',\n  extends: Drop,\n  props: {\n    mainClass: {\n      default: 'uk-dropdown'\n    }\n  }\n};\nvar ElementGrid = {\n  functional: true,\n  props: {\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    divided: {\n      type: Boolean,\n      default: false\n    },\n    matched: {\n      type: Boolean,\n      default: false\n    },\n    gutter: {\n      type: String,\n      validator: function (val) {\n        return !val || /^(small|medium|large|collapse)$/.test(val);\n      }\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var tag = props.tag;\n    var gutter = props.gutter;\n    var divided = props.divided;\n    var matched = props.matched;\n    return h(tag, mergeData(data, {\n      class: ['uk-grid', (obj = {\n        'uk-grid-match': matched,\n        'uk-grid-divider': divided\n      }, obj[\"uk-grid-\" + gutter] = gutter, obj)]\n    }), children);\n  }\n};\nvar NAMESPACE = '__vkMargin';\nvar VkMargin = {\n  bind: function bind$$1(el, binding, vnode) {\n    el[NAMESPACE] = {};\n  },\n  inserted: function inserted(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      return update(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n    el[NAMESPACE].unbind = on(window, 'resize', function () {\n      return update(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      return update(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n  },\n  unbind: function unbind(el) {\n    if (!el[NAMESPACE]) {\n      return;\n    }\n\n    el[NAMESPACE].unbind();\n    delete el[NAMESPACE];\n  }\n};\n\nfunction update(el, ctx) {\n  var opts = getOptions$1(ctx);\n  var items = el.children;\n\n  if (!items.length || !isVisible(el)) {\n    return;\n  }\n\n  var data = getRows(items);\n  data.rows.forEach(function (row, i) {\n    return row.forEach(function (el, j) {\n      toggleClass(el, opts.margin, i !== 0);\n      toggleClass(el, opts.firstColumn, j === 0);\n    });\n  });\n  opts.onUpdate(el, data);\n}\n\nfunction getOptions$1(ctx) {\n  var ref = ctx.binding;\n  var value = ref.value;\n\n  if (false) {}\n\n  var options = assign({\n    onUpdate: noop,\n    margin: 'uk-margin-small-top',\n    firstColumn: 'uk-first-column'\n  }, value);\n  return options;\n}\n\nfunction getRows(items) {\n  var data = {};\n  var rows = [[]];\n  data.stacks = true;\n\n  for (var i = 0; i < items.length; i++) {\n    var el = items[i];\n    var dim = el.getBoundingClientRect();\n\n    if (!dim.height) {\n      continue;\n    }\n\n    for (var j = rows.length - 1; j >= 0; j--) {\n      var row = rows[j];\n\n      if (!row[0]) {\n        row.push(el);\n        break;\n      }\n\n      var leftDim = row[0].getBoundingClientRect();\n\n      if (dim.top >= Math.floor(leftDim.bottom)) {\n        rows.push([el]);\n        break;\n      }\n\n      if (Math.floor(dim.bottom) > leftDim.top) {\n        data.stacks = false;\n\n        if (dim.left < leftDim.left && !isRtl) {\n          row.unshift(el);\n          break;\n        }\n\n        row.push(el);\n        break;\n      }\n\n      if (j === 0) {\n        rows.unshift([el]);\n        break;\n      }\n    }\n  }\n\n  data.rows = rows;\n  return data;\n}\n\nvar Grid = {\n  name: 'VkGrid',\n  directives: {\n    VkMargin: VkMargin\n  },\n  props: assign({}, ElementGrid.props, {\n    margin: {\n      type: String,\n      default: 'uk-grid-margin'\n    },\n    firstColumn: {\n      type: String,\n      default: 'uk-first-column'\n    }\n  }),\n  render: function render(h) {\n    var clsStack = 'uk-grid-stack';\n    var ref = this;\n    var margin = ref.margin;\n    var firstColumn = ref.firstColumn;\n    return h(ElementGrid, {\n      props: this.$props,\n      directives: [{\n        name: 'vk-margin',\n        value: {\n          margin: margin,\n          firstColumn: firstColumn,\n          onUpdate: function (el, ref) {\n            var stacks = ref.stacks;\n            toggleClass(el, clsStack, stacks);\n          }\n        }\n      }]\n    }, this.$slots.default);\n  }\n};\nvar core = {\n  functional: true,\n  props: {\n    icon: {\n      type: String,\n      required: true\n    },\n    ratio: {\n      type: [Number, String],\n      default: 1\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var icon = props.icon;\n    var ratio = props.ratio;\n    var ref$1 = data.attrs || {};\n    var width = ref$1.width;\n    var height = ref$1.height;\n    var viewBox = ref$1.viewBox;\n    var Icon = h(\"vk-icons-\" + icon, {\n      attrs: {\n        width: width,\n        height: height,\n        viewBox: viewBox\n      }\n    });\n\n    if (ratio !== 1) {\n      Icon.data.attrs.width *= ratio;\n      Icon.data.attrs.height *= ratio;\n      Icon.data.attrs.ratio = ratio;\n    }\n\n    return Icon;\n  }\n};\nvar ElementIcon = {\n  functional: true,\n  render: function (h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('span', mergeData(data, {\n      class: 'uk-icon'\n    }), children);\n  }\n};\nvar ElementIconLink = {\n  functional: true,\n  props: {\n    reset: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var reset = props.reset;\n    return h('a', mergeData(data, {\n      class: ['uk-icon', {\n        'uk-icon-link': reset\n      }]\n    }), children);\n  }\n};\nvar ElementIconButton = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('a', mergeData(data, {\n      class: 'uk-icon uk-icon-button'\n    }), children);\n  }\n};\nvar ElementIconImage = {\n  functional: true,\n  props: {\n    src: {\n      type: String,\n      required: true\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var src = props.src;\n    return h('span', mergeData(data, {\n      class: 'uk-icon uk-icon-image',\n      style: {\n        'background-image': \"url(\" + src + \")\"\n      }\n    }));\n  }\n};\nvar icon = {\n  name: 'VkIcon',\n  functional: true,\n  props: core.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h(ElementIcon, data, [h(core, mergeData(data, {\n      props: props\n    }))]);\n  }\n};\nvar iconLink = {\n  name: 'VkIconLink',\n  functional: true,\n  props: assign({}, core.props, ElementIconLink.props),\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var def = mergeData(data, {\n      props: props\n    });\n    return h(ElementIconLink, def, [h(core, def)]);\n  }\n};\nvar iconButton = {\n  name: 'VkIconButton',\n  functional: true,\n  props: core.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h(ElementIconButton, data, [h(core, mergeData(data, {\n      props: props\n    }))]);\n  }\n};\nvar iconImage = {\n  name: 'VkIconImage',\n  functional: true,\n  props: ElementIconImage.props,\n  render: ElementIconImage.render\n};\nvar ElementIconnav = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('ul', mergeData(data, {\n      class: 'uk-iconnav'\n    }), children);\n  }\n};\nvar ElementIconnavVertical = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('ul', mergeData(data, {\n      class: 'uk-iconnav uk-iconnav-vertical'\n    }), children);\n  }\n};\nvar ElementIconnavItem = {\n  functional: true,\n  props: {\n    href: String,\n    target: String,\n    active: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var active = props.active;\n    var href = props.href;\n    var target = props.target;\n    return h('li', mergeData(data, {\n      class: {\n        'uk-active': active\n      }\n    }), [h(ElementIconLink, {\n      attrs: {\n        href: href,\n        target: target\n      }\n    }, children)]);\n  }\n};\nvar iconnav = {\n  name: 'VkIconnav',\n  functional: true,\n  render: ElementIconnav.render\n};\nvar iconnavVertical = {\n  name: 'VkIconnavVertical',\n  functional: true,\n  render: ElementIconnavVertical.render\n};\nvar iconnav_Item = {\n  name: 'VkIconnavItem',\n  functional: true,\n  props: assign({\n    icon: {\n      type: String,\n      required: true\n    }\n  }, ElementIconnavItem.props),\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h(ElementIconnavItem, mergeData(data, {\n      props: props\n    }), [h(\"vk-icons-\" + props.icon)]);\n  }\n};\nvar ElementLabel = {\n  functional: true,\n  props: {\n    type: {\n      type: String,\n      validator: function (val) {\n        return !val || /^(success|warning|danger)$/.test(val);\n      }\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var type = props.type;\n    return h('span', mergeData(data, {\n      class: ['uk-label', (obj = {}, obj[\"uk-label-\" + type] = type, obj)]\n    }), children);\n  }\n};\nvar label = {\n  name: 'VkLabel',\n  functional: true,\n  props: ElementLabel.props,\n  render: ElementLabel.render\n};\nvar SHOWN = 'shown';\nvar HIDDEN = 'hidden';\nvar TOGGLE = 'update:show';\nvar KEYUP = 'keyup';\nvar doc$2 = typeof document !== 'undefined' && document.documentElement;\nvar active$1;\nvar activeModals;\nvar Transition$2 = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    var modal = ref.parent;\n    var def = {\n      props: {\n        css: false,\n        appear: true\n      },\n      on: {\n        beforeEnter: function beforeEnter() {\n          addClass(doc$2, 'uk-modal-page');\n        },\n        enter: function enter(el, done) {\n          var prev = active$1 !== modal && active$1;\n\n          if (prev && !modal.stack) {\n            prev.hide();\n            once(prev.$el, 'transitionend', function () {\n              return doEnter(el, done);\n            }, false, function (e) {\n              return e.target === prev.$el;\n            });\n            return;\n          }\n\n          setTimeout(function () {\n            return doEnter(el, done);\n          }, 0);\n        },\n        afterEnter: function afterEnter(el) {\n          activeModals++;\n          active$1 = modal;\n          active$1.$emit(SHOWN);\n        },\n        beforeLeave: function beforeLeave(el) {\n          removeClass(el, 'uk-open');\n        },\n        leave: function leave(el, done) {\n          once(el, 'transitionend', done, false, function (e) {\n            return e.target === el;\n          });\n        },\n        afterLeave: function afterLeave(el) {\n          activeModals--;\n\n          if (!activeModals) {\n            removeClass(doc$2, 'uk-modal-page');\n          }\n\n          if (active$1 === modal) {\n            active$1 = null;\n          }\n\n          modal.$emit(HIDDEN);\n        }\n      }\n    };\n\n    function doEnter(el, done) {\n      modal.$root.$el.appendChild(el);\n      el.offsetWidth;\n      once(el, 'transitionend', done, false, function (e) {\n        return e.target === el;\n      });\n      addClass(el, 'uk-open');\n    }\n\n    return h('transition', def, children);\n  }\n};\non(doc$2, 'click', function (e) {\n  if (!active$1) {\n    return;\n  }\n\n  var clickedOut = e.target === active$1.$el;\n\n  if (clickedOut && !active$1.stuck) {\n    active$1.$emit(TOGGLE, false);\n  }\n});\non(doc$2, 'keyup', function (e) {\n  active$1 && active$1.$emit(KEYUP, e);\n});\nvar doc$3 = typeof document !== 'undefined' && document.documentElement;\nvar core$1 = {\n  mixins: [EventsMixin],\n  props: {\n    show: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    hide: function hide() {\n      this.$emit(TOGGLE, false);\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this.$el.parentNode) {\n      this.$el.parentNode.removeChild(this.$el);\n    }\n\n    if (!activeModals) {\n      removeClass(doc$3, 'uk-modal-page');\n    }\n  }\n};\nvar VkModalOverflowAuto = {\n  bind: function bind(el, binding) {\n    el.vkModalOverflowAutoOff = on(window, 'resize', function () {\n      return update$1(el, binding);\n    });\n    addClass(el, 'uk-overflow-auto');\n  },\n  inserted: function inserted(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      return update$1(el, binding);\n    });\n  },\n  componentUpdated: function componentUpdated(el, binding) {\n    update$1(el, binding);\n  },\n  unbind: function unbind(el) {\n    el.vkModalOverflowAutoOff();\n  }\n};\n\nfunction update$1(el, binding) {\n  var modal = closest(el, '.uk-modal');\n  var panel = closest(el, '.uk-modal-dialog');\n\n  if (!panel || !modal) {\n    return;\n  }\n\n  var current = css(el, 'maxHeight');\n  css(el, 'maxHeight', 150);\n  css(el, 'maxHeight', Math.max(150, 150 + height(modal) - panel.offsetHeight));\n\n  if (current !== css(el, 'maxHeight')) {\n    update$1(el, binding);\n  }\n}\n\nvar ElementModal = {\n  functional: true,\n  props: {\n    expand: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var children = ref.children;\n    var data = ref.data;\n    var props = ref.props;\n    var expand = props.expand;\n    return h('div', mergeData(data, {\n      class: ['uk-modal', {\n        'uk-modal-container': expand\n      }],\n      style: {\n        display: 'block'\n      }\n    }), children);\n  }\n};\nvar ElementModalFull = {\n  functional: true,\n  render: function render(h, ref) {\n    var children = ref.children;\n    var data = ref.data;\n    var props = ref.props;\n    return h('div', mergeData(data, {\n      class: 'uk-modal uk-modal-full',\n      style: {\n        display: 'block'\n      }\n    }), children);\n  }\n};\nvar IconClose = {\n  functional: true,\n  render: function (h, ctx) {\n    var props = ctx.props;\n    var width = props.width || 14;\n    var height = props.height || 14;\n    var viewBox = props.viewBox || '0 0 14 14';\n    return h('svg', {\n      attrs: {\n        version: '1.1',\n        width: width,\n        height: height,\n        viewBox: viewBox\n      },\n      domProps: {\n        innerHTML: '<path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1 1l12 12M13 1L1 13\"/>'\n      }\n    });\n  }\n};\nvar IconCloseLarge = {\n  functional: true,\n  render: function (h, ctx) {\n    var props = ctx.props;\n    var width = props.width || 20;\n    var height = props.height || 20;\n    var viewBox = props.viewBox || '0 0 20 20';\n    return h('svg', {\n      attrs: {\n        version: '1.1',\n        width: width,\n        height: height,\n        viewBox: viewBox\n      },\n      domProps: {\n        innerHTML: '<path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M1 1l18 18M19 1L1 19\"/>'\n      }\n    });\n  }\n};\nvar ElementModalClose = {\n  functional: true,\n  props: {\n    large: {\n      type: Boolean,\n      default: false\n    },\n    outside: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var data = ref.data;\n    var props = ref.props;\n    var large = props.large;\n    var outside = props.outside;\n    var def = {\n      class: ['uk-close uk-icon', (obj = {\n        'uk-close-large': large\n      }, obj[\"uk-modal-close-outside\"] = outside, obj[\"uk-modal-close-default\"] = !outside, obj)],\n      attrs: {\n        type: 'button'\n      }\n    };\n    return h('button', mergeData(data, def), [h(large ? IconCloseLarge : IconClose)]);\n  }\n};\nvar ElementModalFullClose = {\n  functional: true,\n  props: {\n    large: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var large = props.large;\n    var def = {\n      class: ['uk-close uk-icon uk-modal-close-full', {\n        'uk-close-large': large\n      }],\n      attrs: {\n        type: 'button'\n      }\n    };\n    return h('button', mergeData(data, def), [h(large ? IconCloseLarge : IconClose)]);\n  }\n};\nvar ElementModalTitle = {\n  functional: true,\n  props: {\n    tag: {\n      type: String,\n      default: 'h2'\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var tag = props.tag;\n    return h(tag, mergeData(data, {\n      class: 'uk-modal-title'\n    }), children);\n  }\n};\nvar ElementModalBody = {\n  functional: true,\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-modal-body'\n    }), children);\n  }\n};\nvar ElementModalDialog = {\n  functional: true,\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-modal-dialog'\n    }), children);\n  }\n};\nvar ElementModalFooter = {\n  functional: true,\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-modal-footer'\n    }), children);\n  }\n};\nvar ElementModalHeader = {\n  functional: true,\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-modal-header'\n    }), children);\n  }\n};\nvar modal = {\n  name: 'VkModal',\n  extends: core$1,\n  directives: {\n    VkModalOverflowAuto: VkModalOverflowAuto\n  },\n  props: {\n    stuck: {\n      type: Boolean,\n      default: false\n    },\n    overflowAuto: {\n      type: Boolean,\n      default: false\n    },\n    center: {\n      type: Boolean,\n      default: false\n    },\n    size: {\n      type: String,\n      default: ''\n    },\n    stack: {\n      type: Boolean,\n      default: false\n    }\n  },\n  computed: {\n    widthClasses: function widthClasses() {\n      return this.size ? this.size.split(' ').map(function (size) {\n        return \"uk-width-\" + size;\n      }) : '';\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var def = {\n      class: {\n        'uk-flex uk-flex-top': this.center\n      },\n      style: {\n        display: this.center ? 'flex' : 'block'\n      },\n      props: {\n        expand: this.size === 'container'\n      },\n      directives: [{\n        name: 'show',\n        value: this.show\n      }],\n      on: {}\n    };\n    Object.keys(this.$slots).forEach(function (slot) {\n      return each(this$1.$slots[slot], function (node) {\n        if (node.fnOptions && node.fnOptions.name === 'VkModalClose') {\n          assign(node.data, {\n            on: assign({\n              click: function (e) {\n                return this$1.$emit(TOGGLE, false);\n              }\n            }, node.data.on || {})\n          });\n        }\n      });\n    });\n    var modal = h(ElementModal, def, [h(ElementModalDialog, {\n      class: [this.widthClasses, {\n        'uk-margin-auto-vertical': this.center\n      }]\n    }, [this.$slots.dialog && this.$slots.dialog, this.$slots.header && h(ElementModalHeader, this.$slots.header), this.$slots.default && h(ElementModalBody, {\n      directives: this.overflowAuto ? [{\n        name: 'vk-modal-overflow-auto'\n      }] : []\n    }, this.$slots.default), this.$slots.footer && h(ElementModalFooter, this.$slots.footer)])]);\n    return h(Transition$2, [modal]);\n  }\n};\nvar NAMESPACE$1 = '__vkHeightViewport';\nvar VkHeightViewport = {\n  bind: function bind$$1(el, binding, vnode) {\n    el[NAMESPACE$1] = {};\n  },\n  inserted: function inserted(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      return update$2(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n    el[NAMESPACE$1].unbind = on(window, 'resize', function () {\n      return update$2(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      return update$2(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n  },\n  unbind: function unbind(el) {\n    if (!el[NAMESPACE$1]) {\n      return;\n    }\n\n    el[NAMESPACE$1].unbind();\n    delete el[NAMESPACE$1];\n  }\n};\n\nfunction getOptions$2(ctx) {\n  var ref = ctx.binding;\n  var value = ref.value;\n  var modifiers = ref.modifiers;\n\n  if (false) {}\n\n  var options = assign({\n    minHeight: 0,\n    expand: false,\n    offsetTop: false,\n    offsetBottom: false\n  }, modifiers, value);\n  return options;\n}\n\nfunction update$2(el, ctx) {\n  var opts = getOptions$2(ctx);\n  css(el, 'boxSizing', 'border-box');\n  var viewport = height(window);\n  var minHeight;\n  var offsetTop = 0;\n\n  if (opts.expand) {\n    css(el, {\n      height: '',\n      minHeight: ''\n    });\n    var diff = viewport - offsetHeight(document.documentElement);\n\n    if (diff > 0) {\n      minHeight = offsetHeight(el) + diff;\n    }\n  } else {\n    var ref = offset(el);\n    var top = ref.top;\n\n    if (top < viewport / 2 && opts.offsetTop) {\n      offsetTop += top;\n    }\n\n    if (opts.offsetBottom === true) {\n      offsetTop += offsetHeight(el.nextElementSibling);\n    } else if (isNumeric(opts.offsetBottom)) {\n      offsetTop += viewport / 100 * opts.offsetBottom;\n    } else if (opts.offsetBottom && endsWith(opts.offsetBottom, 'px')) {\n      offsetTop += toFloat(opts.offsetBottom);\n    } else if (isString(opts.offsetBottom)) {\n      offsetTop += offsetHeight(query(opts.offsetBottom, el));\n    }\n\n    minHeight = offsetTop ? \"calc(100vh - \" + offsetTop + \"px)\" : '100vh';\n  }\n\n  if (!minHeight) {\n    return;\n  }\n\n  css(el, {\n    height: '',\n    minHeight: minHeight\n  });\n  var elHeight = el.offsetHeight;\n\n  if (opts.minHeight && opts.minHeight > elHeight) {\n    css(el, 'minHeight', opts.minHeight);\n  }\n\n  if (viewport - offsetTop >= elHeight) {\n    css(el, 'height', minHeight);\n  }\n}\n\nfunction offsetHeight(el) {\n  return el && (el.offsetHeight || 0);\n}\n\nvar modalFull = {\n  name: 'VkModalFull',\n  extends: core$1,\n  directives: {\n    VkHeightViewport: VkHeightViewport\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var def = {\n      props: {\n        expand: 'full'\n      },\n      directives: [{\n        name: 'show',\n        value: this.show\n      }]\n    };\n    Object.keys(this.$slots).forEach(function (slot) {\n      return each(this$1.$slots[slot], function (node) {\n        if (node.fnOptions && node.fnOptions.name === 'VkModalFullClose') {\n          assign(node.data, {\n            on: assign({\n              click: function (e) {\n                return this$1.$emit(TOGGLE, false);\n              }\n            }, node.data.on || {})\n          });\n        }\n      });\n    });\n    var modal = h(ElementModalFull, def, [h(ElementModalDialog, {\n      directives: [{\n        name: 'vk-height-viewport'\n      }]\n    }, this.$slots.default)]);\n    return h(Transition$2, [modal]);\n  }\n};\nvar modal_Close = {\n  name: 'VkModalClose',\n  functional: true,\n  props: ElementModalClose.props,\n  render: ElementModalClose.render\n};\nvar modalFull_Close = {\n  name: 'VkModalFullClose',\n  functional: true,\n  props: ElementModalFullClose.props,\n  render: ElementModalFullClose.render\n};\nvar modal_Title = {\n  name: 'VkModalTitle',\n  functional: true,\n  props: ElementModalTitle.props,\n  render: ElementModalTitle.render\n};\nvar ElementNav = {\n  functional: true,\n  props: {\n    center: {\n      type: Boolean,\n      default: false\n    },\n    type: {\n      type: String,\n      default: 'default',\n      validator: function (val) {\n        return /^(default|primary|blank)$/.test(val);\n      }\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var center = props.center;\n    var type = props.type;\n    return h('ul', mergeData(data, {\n      class: ['uk-nav', (obj = {\n        'uk-nav-center': center\n      }, obj[\"uk-nav-\" + type] = type, obj)]\n    }), children);\n  }\n};\nvar ElementNavDropdown = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('ul', mergeData(data, {\n      class: 'uk-nav uk-dropdown-nav'\n    }), children);\n  }\n};\nvar ElementNavItem = {\n  functional: true,\n  props: {\n    icon: {},\n    href: String,\n    target: String,\n    title: {\n      type: String,\n      required: true\n    },\n    active: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var active = props.active;\n    var icon$$1 = props.icon;\n    var title = props.title;\n    var href = props.href;\n    var target = props.target;\n    var content = title;\n\n    if (icon$$1) {\n      content = [h(ElementIcon, {\n        class: 'uk-margin-small-right'\n      }, [icon$$1]), h('span', {\n        class: 'uk-text-middle'\n      }, title)];\n    }\n\n    return h('li', mergeData(data, {\n      class: {\n        'uk-active': active\n      }\n    }), [h('a', {\n      attrs: {\n        href: href,\n        target: target\n      }\n    }, content)]);\n  }\n};\nvar ElementNavItemDivider = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    return h('li', mergeData(data, {\n      class: 'uk-nav-divider'\n    }));\n  }\n};\nvar ElementNavItemHeader = {\n  functional: true,\n  props: {\n    title: {\n      type: String,\n      required: true\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h('li', mergeData(data, {\n      class: 'uk-nav-header'\n    }), props.title);\n  }\n};\nvar ElementNavItemParent = {\n  functional: true,\n  props: {\n    href: String,\n    target: String,\n    title: {\n      type: String,\n      required: true\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var title = props.title;\n    var href = props.href;\n    var target = props.target;\n    return h('li', mergeData(data, {\n      class: 'uk-parent'\n    }), [h('a', {\n      attrs: {\n        href: href,\n        target: target\n      }\n    }, [title]), h('ul', {\n      class: 'uk-nav-sub'\n    }, children)]);\n  }\n};\nvar nav$1 = {\n  name: 'VkNav',\n  functional: true,\n  props: ElementNav.props,\n  render: ElementNav.render\n};\nvar navDropdown = {\n  name: 'VkNavDropdown',\n  functional: true,\n  render: ElementNavDropdown.render\n};\nvar nav_Item = {\n  name: 'VkNavItem',\n  functional: true,\n  props: assign({}, ElementNavItem.props, {\n    icon: {\n      type: String\n    }\n  }),\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    props.icon = props.icon && h(\"vk-icons-\" + props.icon);\n    return h(ElementNavItem, mergeData(data, {\n      props: props\n    }));\n  }\n};\nvar nav_ItemDivider = {\n  name: 'VkNavItemDivider',\n  functional: true,\n  render: ElementNavItemDivider.render\n};\nvar nav_ItemHeader = {\n  name: 'VkNavItemHeader',\n  functional: true,\n  props: ElementNavItemHeader.props,\n  render: ElementNavItemHeader.render\n};\nvar nav_ItemParent = {\n  name: 'VkNavItemParent',\n  functional: true,\n  props: ElementNavItemParent.props,\n  render: ElementNavItemParent.render\n};\nvar ElementNavbarNavigation = {\n  functional: true,\n  props: {\n    align: {\n      type: String,\n      default: 'left',\n      validator: function (val) {\n        return /^(left|center(-left|-right)?|right)$/.test(val);\n      }\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var align = props.align;\n    var wrapContent = /center-(left|right)/.test(align);\n    return h('div', mergeData(data, {\n      class: \"uk-navbar-\" + align\n    }), [wrapContent ? h('div', children) : children]);\n  }\n};\n\nfunction renderSlots(h, slots) {\n  return [(slots.left || slots.default) && h(ElementNavbarNavigation, [slots.left, slots.default]), (slots.center || slots['center-left'] || slots['center-right']) && h(ElementNavbarNavigation, {\n    props: {\n      align: 'center'\n    }\n  }, [slots['center-left'] && h(ElementNavbarNavigation, {\n    props: {\n      align: 'center-left'\n    }\n  }, slots['center-left']), slots.center && slots.center, slots['center-right'] && h(ElementNavbarNavigation, {\n    props: {\n      align: 'center-right'\n    }\n  }, slots['center-right'])]), slots.right && h(ElementNavbarNavigation, {\n    props: {\n      align: 'right'\n    }\n  }, slots.right)];\n}\n\nvar ElementNavbar = {\n  functional: true,\n  props: {\n    container: {\n      type: Boolean,\n      default: true\n    },\n    transparent: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var slots = ref.slots;\n    var container = props.container;\n    var transparent = props.transparent;\n    return h('nav', mergeData(data, {\n      class: ['uk-navbar', {\n        'uk-navbar-container': container && !transparent,\n        'uk-navbar-transparent': transparent\n      }]\n    }), renderSlots(h, slots()));\n  }\n};\nvar ElementNavbarFull = {\n  functional: true,\n  props: {\n    expanded: {\n      type: Boolean,\n      default: false\n    },\n    transparent: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var slots = ref.slots;\n    var expanded = props.expanded;\n    var transparent = props.transparent;\n    return h('nav', mergeData(data, {\n      class: ['uk-navbar-container', {\n        'uk-navbar-transparent': transparent\n      }]\n    }), [h('div', {\n      class: ['uk-container', {\n        'uk-container-expand': expanded\n      }]\n    }, [h('div', {\n      class: 'uk-navbar'\n    }, renderSlots(h, slots()))])]);\n  }\n};\nvar ElementNavbarDropbar = {\n  functional: true,\n  props: {\n    slide: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var slide = props.slide;\n    return h('div', mergeData(data, {\n      class: ['uk-navbar-dropbar', {\n        'uk-navbar-dropbar-slide': slide\n      }]\n    }));\n  }\n};\nvar ElementNavbarItem = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-navbar-item'\n    }), children);\n  }\n};\nvar ElementNavbarLogo = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('span', mergeData(data, {\n      class: 'uk-navbar-item uk-logo'\n    }), children);\n  }\n};\nvar IconToggle = {\n  functional: true,\n  render: function (h, ctx) {\n    var props = ctx.props;\n    var width = props.width || 20;\n    var height = props.height || 20;\n    var viewBox = props.viewBox || '0 0 20 20';\n    return h('svg', {\n      attrs: {\n        version: '1.1',\n        width: width,\n        height: height,\n        viewBox: viewBox\n      },\n      domProps: {\n        innerHTML: '<path d=\"M0 9h20v2H0zM0 3h20v2H0zM0 15h20v2H0z\"/>'\n      }\n    });\n  }\n};\nvar ElementNavbarToggle = {\n  functional: true,\n  props: {\n    title: {\n      type: String,\n      default: ''\n    },\n    icon: {\n      type: Boolean,\n      default: true\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var icon$$1 = props.icon;\n    var title = props.title;\n    var Icon = icon$$1 && h(ElementIcon, {\n      class: 'uk-navbar-toggle-icon'\n    }, [h(IconToggle)]);\n    return h('a', mergeData(data, {\n      class: 'uk-navbar-toggle'\n    }), [Icon, title && h('span', {\n      class: 'uk-margin-small-left'\n    }, title)]);\n  }\n};\nvar ElementNavbarNav = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('ul', mergeData(data, {\n      class: 'uk-navbar-nav'\n    }), children);\n  }\n};\nvar ElementNavbarNavItem = {\n  functional: true,\n  props: {\n    icon: {},\n    href: String,\n    target: String,\n    title: {\n      type: String\n    },\n    subtitle: {\n      type: String\n    },\n    active: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var active = props.active;\n    var title = props.title;\n    var subtitle = props.subtitle;\n    var icon$$1 = props.icon;\n    var href = props.href;\n    var target = props.target;\n    var Icon = icon$$1 && h(ElementIcon, {\n      class: 'uk-margin-small-right'\n    }, [icon$$1]);\n    var Subtitle = subtitle && h('div', [title, h('div', {\n      class: 'uk-navbar-subtitle'\n    }, subtitle)]);\n    return h('li', mergeData(data, {\n      class: {\n        'uk-active': active\n      }\n    }), [h('a', {\n      attrs: {\n        href: href,\n        target: target\n      }\n    }, [Icon, Subtitle || title]), children]);\n  }\n};\nvar ElementNavbarNavDropdownNav = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('ul', mergeData(data, {\n      class: 'uk-nav uk-navbar-dropdown-nav'\n    }), children);\n  }\n};\nvar navbar = {\n  name: 'VkNavbar',\n  functional: true,\n  props: ElementNavbar.props,\n  render: ElementNavbar.render\n};\nvar navbarFull = {\n  name: 'VkNavbarFull',\n  functional: true,\n  props: ElementNavbarFull.props,\n  render: ElementNavbarFull.render\n};\nvar SHOW$1 = SHOW;\nvar HIDE$1 = HIDE;\nvar navbarDropbar = {\n  name: 'VkNavbarDropbar',\n  props: {\n    mode: {\n      type: String,\n      default: 'slide',\n      validator: function (val) {\n        return /^(slide|push)$/.test(val);\n      }\n    },\n    duration: {\n      type: Number,\n      default: 200\n    }\n  },\n  methods: {\n    transitionDropbar: function transitionDropbar(dropdownEl) {\n      var el = dropdownEl;\n      var marginTop = toFloat(css(el, 'margin-top'));\n      var marginBottom = toFloat(css(el, 'margin-bottom'));\n      var height$$1 = el.offsetHeight + marginTop + marginBottom;\n      this.transitionTo(height$$1, el);\n    },\n    transitionTo: function transitionTo(newHeight, el) {\n      var dropbar = this.$refs.dropbar;\n      var oldHeight = isVisible(dropbar) ? height(dropbar) : 0;\n      el = oldHeight < newHeight && el;\n      css(el, {\n        height: oldHeight,\n        overflow: 'hidden'\n      });\n      height(dropbar, oldHeight);\n      Transition.cancel([el, dropbar]);\n      return Transition.start([el, dropbar], {\n        height: newHeight\n      }, this.duration).catch(noop).finally(function () {\n        return css(el, {\n          height: '',\n          overflow: ''\n        });\n      });\n    }\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n    var dropdowns = get(this, '$children', []).filter(function (child) {\n      return /NavbarNavDropdown/.test(child.$options.name);\n    }).map(function (c) {\n      return c.$children[0];\n    });\n    dropdowns.forEach(function (drop) {\n      drop.$vnode.data.class['uk-navbar-dropdown-dropbar'] = true;\n      drop.$on(SHOW$1, function () {\n        this$1.$nextTick(function () {\n          this$1.transitionDropbar(drop.$el);\n        });\n      });\n      drop.$on(HIDE$1, function () {\n        this$1.$nextTick(function () {\n          var thereAreActiveDrops = active && within(active.$el, this$1.$el);\n\n          if (!thereAreActiveDrops) {\n            this$1.transitionDropbar(drop.$el);\n          }\n        });\n      });\n    });\n  },\n  render: function render(h) {\n    return h('div', {\n      class: 'uk-position-relative'\n    }, [this.$slots.default, h(ElementNavbarDropbar, {\n      ref: 'dropbar',\n      props: {\n        slide: this.mode === 'slide'\n      }\n    })]);\n  }\n};\nvar navbar_Item = {\n  name: 'VkNavbarItem',\n  functional: true,\n  render: ElementNavbarItem.render\n};\nvar navbar_Logo = {\n  name: 'VkNavbarLogo',\n  functional: true,\n  render: ElementNavbarLogo.render\n};\nvar navbar_Toggle = {\n  name: 'VkNavbarToggle',\n  functional: true,\n  props: ElementNavbarToggle.props,\n  render: ElementNavbarToggle.render\n};\nvar navbar_Nav = {\n  name: 'VkNavbarNav',\n  functional: true,\n  render: ElementNavbarNav.render\n};\nvar navbar_Nav_Item = {\n  name: 'VkNavbarNavItem',\n  functional: true,\n  props: assign({}, ElementNavbarNavItem.props, {\n    icon: {\n      type: String\n    }\n  }),\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    props.icon = props.icon && h(\"vk-icons-\" + props.icon);\n    return h(ElementNavbarNavItem, mergeData(data, {\n      props: props\n    }));\n  }\n};\nvar SHOW$2 = SHOW;\nvar navbar_Nav_Dropdown = {\n  name: 'VkNavbarNavDropdown',\n  props: {\n    title: {\n      type: String,\n      required: true\n    },\n    subtitle: {\n      type: String\n    },\n    justified: {\n      type: Boolean,\n      default: false\n    },\n    align: {\n      type: String,\n      default: isRtl ? 'right' : 'left',\n      validator: function (val) {\n        return /^(left|center|right)$/.test(val);\n      }\n    },\n    navbarAligned: {\n      type: Boolean,\n      default: false\n    },\n    mode: Drop.props.mode,\n    offset: Drop.props.offset,\n    animation: Drop.props.animation,\n    duration: Drop.props.duration,\n    delayShow: Drop.props.delayShow,\n    delayHide: Drop.props.delayHide\n  },\n  computed: {\n    navbar: function navbar() {\n      return query('!.uk-navbar', this.$el);\n    },\n    dropbar: function dropbar() {\n      return /NavbarDropbar/.test(get(this, '$parent.$options.name', '')) ? this.$parent : false;\n    }\n  },\n  mounted: function mounted() {\n    var ref = this;\n    var mode = ref.mode;\n    var ref$1 = this.$refs.drop;\n    var on = ref$1.on;\n    var toggle = ref$1.toggle;\n    var show = ref$1.show;\n    var hide = ref$1.hide;\n    var target = this.$refs.drop.$refs.target;\n\n    if (/click/.test(mode) || hasTouch) {\n      on(target, 'click', toggle);\n    }\n\n    if (/hover/.test(mode)) {\n      on(target, pointerEnter, function (e) {\n        if (isTouch(e)) {\n          return;\n        }\n\n        e.preventDefault();\n        show();\n      });\n      on(this.dropbar ? this.dropbar.$el : target, pointerLeave, function (e) {\n        if (isTouch(e)) {\n          return;\n        }\n\n        e.preventDefault();\n        hide();\n      });\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var obj, obj$1, obj$2;\n    var ref = this;\n    var title = ref.title;\n    var justified = ref.justified;\n    var mode = ref.mode;\n    var align = ref.align;\n    var navbarAligned = ref.navbarAligned;\n    var subtitle = ref.subtitle;\n    var defaultSlots = this.$slots.default || [];\n    var childrenNodes = defaultSlots.filter(function (n) {\n      return n.tag;\n    });\n    var colCount = childrenNodes.length;\n    var Subtitle = subtitle && h('div', [title, h('div', {\n      class: 'uk-navbar-subtitle'\n    }, subtitle)]);\n    return h('li', [h('a', [Subtitle || title]), h(Drop, {\n      on: (obj = {}, obj[SHOW$2] = function (e) {\n        this$1.$forceUpdate();\n      }, obj),\n      nativeOn: (obj$1 = {}, obj$1[pointerEnter] = function (e) {\n        this$1.$refs.drop.clearTimers();\n\n        if (/hover/.test(mode)) {\n          this$1.$refs.drop.show();\n        }\n      }, obj$1[pointerLeave] = function (e) {\n        if (!this$1.dropbar && /hover/.test(mode)) {\n          this$1.$refs.drop.hide();\n        }\n      }, obj$1),\n      ref: 'drop',\n      class: (obj$2 = {\n        'uk-navbar-dropdown-dropbar': Boolean(this.dropbar),\n        'uk-navbar-dropdown-boundary': justified || navbarAligned\n      }, obj$2[\"uk-navbar-dropdown-width-\" + colCount] = colCount > 1 && !justified, obj$2),\n      props: assign({}, this.$props, {\n        mode: '',\n        position: justified ? 'bottom-justify' : \"bottom-\" + align,\n        mainClass: 'uk-navbar-dropdown',\n        flip: justified ? 'x' : undefined,\n        boundary: '!nav',\n        boundaryAlign: justified || navbarAligned\n      })\n    }, [colCount >= 2 ? h(Grid, {\n      class: ['uk-navbar-dropdown-grid', \"uk-child-width-1-\" + colCount + (colCount > 2 ? '@m' : '')]\n    }, childrenNodes.map(function (child) {\n      return h('div', [child]);\n    })) : defaultSlots])]);\n  }\n};\nvar navbar_Nav_Dropdown_Nav = {\n  name: 'VkNavbarNavDropdownNav',\n  functional: true,\n  render: ElementNavbarNavDropdownNav.render\n};\nvar NAMESPACE$2 = '__vkNotification';\nvar MessageDirective = {\n  inserted: function inserted(el, binding, vnode) {\n    el[NAMESPACE$2] = {};\n\n    var close = function () {\n      return doClose(el, vnode);\n    };\n\n    var opts = el[NAMESPACE$2].options = binding.value;\n\n    if (opts.timeout) {\n      el[NAMESPACE$2].timer = setTimeout(close, opts.timeout);\n    }\n\n    on(el, 'click', close);\n    on(el, pointerEnter, function () {\n      if (el[NAMESPACE$2].timer) {\n        clearTimeout(el[NAMESPACE$2].timer);\n      }\n    });\n    on(el, pointerLeave, function () {\n      if (opts.timeout) {\n        el[NAMESPACE$2].timer = setTimeout(close, opts.timeout);\n      }\n    });\n  },\n  unbind: function unbind(el) {\n    if (!el[NAMESPACE$2]) {\n      return;\n    }\n\n    clearTimeout(el[NAMESPACE$2].timer);\n    delete el[NAMESPACE$2];\n  }\n};\n\nfunction doClose(el, vnode) {\n  clearTimeout(el[NAMESPACE$2].timer);\n  trigger(el, 'close');\n}\n\nvar MessageTransition = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    var parent = ref.parent;\n    var def = {\n      props: {\n        css: false,\n        appear: true,\n        tag: 'div'\n      },\n      on: {\n        enter: function enter(el, done) {\n          var marginBottom = toFloat(css(el, 'marginBottom'));\n          css(el, {\n            opacity: 0,\n            marginTop: -el.offsetHeight,\n            marginBottom: 0\n          });\n          Transition.start(el, {\n            opacity: 1,\n            marginTop: 0,\n            marginBottom: marginBottom\n          }).then(done);\n        },\n        leave: function leave(el, done) {\n          Transition.start(el, {\n            opacity: 0,\n            marginTop: -el.offsetHeight,\n            marginBottom: 0\n          }).then(done);\n        }\n      }\n    };\n    return h('transition-group', mergeData(data, def), children);\n  }\n};\nvar ElementNotification = {\n  functional: true,\n  props: {\n    position: {\n      type: String,\n      default: 'top-center',\n      validator: function (val) {\n        return /^(top|bottom)-(left|center|right)$/.test(val);\n      }\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var position = props.position;\n    return h('div', mergeData(data, {\n      class: ['uk-notification', \"uk-notification-\" + position]\n    }), children);\n  }\n};\nvar ElementNotificationClose = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    return h(ElementIconLink, mergeData(data, {\n      class: 'uk-notification-close uk-close'\n    }), [h(IconClose)]);\n  }\n};\nvar ElementNotificationMessage = {\n  functional: true,\n  props: {\n    status: {\n      type: String,\n      default: '',\n      validator: function (val) {\n        return !val || /^(primary|success|warning|danger)$/.test(val);\n      }\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var status = props.status;\n    return h('div', mergeData(data, {\n      class: ['uk-notification-message', (obj = {}, obj[\"uk-notification-message-\" + status] = status, obj)]\n    }), children);\n  }\n};\nvar isNotProd = \"production\" !== 'production';\nvar notification = {\n  name: 'VkNotification',\n  directives: {\n    MessageDirective: MessageDirective\n  },\n  props: assign({}, ElementNotification.props, {\n    timeout: {\n      type: Number,\n      default: 5000\n    },\n    messages: {\n      type: Array,\n      default: function () {\n        return [];\n      },\n      validator: function (val) {\n        if (!val.every(function (m) {\n          return isObject(m) || isString(m);\n        })) {\n          isNotProd && warn('vk-notification -> each message is expected as Object or String');\n          return false;\n        }\n\n        return true;\n      }\n    },\n    status: ElementNotificationMessage.props.status\n  }),\n  computed: {\n    $messages: function $messages() {\n      var this$1 = this;\n      var messages = this.messages.map(function (val) {\n        var msg = isString(val) ? {\n          message: val\n        } : val;\n        return assign({\n          status: this$1.status,\n          timeout: this$1.timeout\n        }, msg);\n      });\n      messages = this.removeDuplicates(messages);\n      return messages;\n    }\n  },\n  methods: {\n    triggerRemove: function triggerRemove(msg) {\n      var this$1 = this;\n      this.closeQueue = this.closeQueue || [];\n      this.closeQueue.push(msg);\n      clearTimeout(this.timer);\n      this.timer = setTimeout(function () {\n        var queue = [].concat(this$1.closeQueue);\n        var messages = [].concat(this$1.$messages);\n        this$1.closeQueue = [];\n        queue.forEach(function (msg) {\n          var index = messages.indexOf(messages.filter(function (m) {\n            return m === msg;\n          })[0]);\n          messages.splice(index, 1);\n        });\n        this$1.$emit('update:messages', messages);\n      });\n    },\n    removeDuplicates: function removeDuplicates(values) {\n      var this$1 = this;\n      var messages = [];\n\n      var isDuplicated = function (msg) {\n        return messages.filter(function (m) {\n          return this$1.getMessageId(m) === this$1.getMessageId(msg);\n        }).length;\n      };\n\n      for (var i = 0; i < values.length; i++) {\n        if (isDuplicated(values[i])) {\n          isNotProd && tip('vk-notification -> duplicate messages are filtered out, consider adding a unique `key` to those.');\n          continue;\n        }\n\n        messages.push(values[i]);\n      }\n\n      return messages;\n    },\n    getMessageId: function getMessageId(msg) {\n      var validKeys = ['message', 'status', 'key', 'timeout'];\n      return Object.keys(msg).filter(function (k) {\n        return validKeys.filter(function (k) {\n          return k;\n        })[0];\n      }).map(function (k) {\n        return msg[k];\n      }).join(':');\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var ref = this;\n    var position = ref.position;\n    var MessageSlot = get(this, '$scopedSlots.default', function (msg) {\n      return msg.message;\n    });\n    return h(ElementNotification, {\n      props: {\n        position: position\n      }\n    }, [h(MessageTransition, [this.$messages.map(function (msg, index) {\n      return h(ElementNotificationMessage, {\n        key: this$1.getMessageId(msg),\n        props: msg,\n        directives: [{\n          name: 'message-directive',\n          value: msg\n        }],\n        on: {\n          close: function () {\n            return this$1.triggerRemove(msg);\n          }\n        }\n      }, [MessageSlot(msg), h(ElementNotificationClose)]);\n    })])]);\n  }\n};\nvar SHOWN$1 = 'shown';\nvar HIDDEN$1 = 'hidden';\nvar TOGGLE$1 = 'update:show';\nvar KEYUP$1 = 'keyup';\nvar active$2;\nvar scrollbarWidth;\nvar win$3 = typeof window !== 'undefined' && window;\nvar body = typeof document !== 'undefined' && document.body;\nvar doc$4 = typeof document !== 'undefined' && document.documentElement;\nvar scroll;\n\nvar getScrollbarWidth = function () {\n  return width(win$3) - doc$4.offsetWidth;\n};\n\nvar events = {\n  beforeEnter: function (el) {\n    var ref = el.__vkOffcanvas;\n    var $refs = ref.$refs;\n    var $props = ref.$props;\n    scrollbarWidth = getScrollbarWidth();\n    scroll = scroll || {\n      x: win$3.pageXOffset,\n      y: win$3.pageYOffset\n    };\n    addClass(doc$4, 'uk-offcanvas-page');\n    addClass(body, 'uk-offcanvas-container');\n\n    if ($props.flipped) {\n      addClass($refs.bar, 'uk-offcanvas-bar-flip');\n      addClass($refs.content.parentNode, 'uk-offcanvas-flip');\n    }\n\n    if ($props.overlay) {\n      addClass(body, 'uk-offcanvas-overlay');\n    }\n\n    height(el);\n  },\n  afterEnter: function afterEnter(el) {\n    var ref = el.__vkOffcanvas;\n    var $refs = ref.$refs;\n    var $props = ref.$props;\n\n    if ($props.overlay) {\n      width($refs.content, width(win$3) - scrollbarWidth);\n      height($refs.content, height(win$3));\n\n      if (scroll) {\n        $refs.content.scrollTop = scroll.y;\n      }\n    }\n\n    active$2 = el.__vkOffcanvas;\n    active$2.$emit(SHOWN$1);\n  },\n  afterLeave: function afterLeave(el) {\n    var ref = el.__vkOffcanvas;\n    var $refs = ref.$refs;\n    var $props = ref.$props;\n\n    if (!$props.overlay) {\n      scroll = {\n        x: win$3.pageXOffset,\n        y: win$3.pageYOffset\n      };\n    } else if (!scroll) {\n      var ref$1 = $refs.content;\n      var x = ref$1.scrollLeft;\n      var y = ref$1.scrollTop;\n      scroll = {\n        x: x,\n        y: y\n      };\n    }\n\n    removeClass($refs.bar, 'uk-offcanvas-bar-flip');\n    removeClass($refs.content.parentNode, 'uk-offcanvas-flip');\n    removeClass(doc$4, 'uk-offcanvas-page');\n    removeClass(body, 'uk-offcanvas-container');\n    removeClass(body, 'uk-offcanvas-overlay');\n    body.scrollTop = scroll.y;\n    css(body, 'overflowY', '');\n    css(doc$4, 'overflowY', '');\n    width($refs.content, '');\n    height($refs.content, '');\n    win$3.scrollTo(scroll.x, scroll.y);\n    scroll = null;\n\n    if (active$2 === el.__vkOffcanvas) {\n      active$2 = null;\n    }\n\n    el.__vkOffcanvas.$emit(HIDDEN$1);\n  }\n};\non(doc$4, 'click', function (e) {\n  if (!active$2) {\n    return;\n  }\n\n  var $refs = active$2.$refs;\n  var $props = active$2.$props;\n  var clickedOut = !$refs.bar.contains(e.target);\n\n  if (clickedOut && !$props.stuck) {\n    active$2.$emit(TOGGLE$1, false);\n  }\n});\non(doc$4, 'keyup', function (e) {\n  active$2 && active$2.$emit(KEYUP$1, e);\n});\nvar ElementOffcanvas = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-offcanvas',\n      style: {\n        display: 'block'\n      }\n    }), children);\n  }\n};\nvar ElementOffcanvasContent = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-offcanvas-content'\n    }), children);\n  }\n};\nvar ElementOffcanvasBar = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    return h('div', mergeData(data, {\n      class: 'uk-offcanvas-bar'\n    }), children);\n  }\n};\nvar ElementOffcanvasClose = {\n  functional: true,\n  props: {\n    large: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var large = props.large;\n    var def = {\n      class: ['uk-offcanvas-close uk-close uk-icon', {\n        'uk-close-large': large\n      }],\n      attrs: {\n        type: 'button'\n      }\n    };\n    return h('button', mergeData(data, def), [h(large ? IconCloseLarge : IconClose)]);\n  }\n};\nvar TransitionNone = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    var def = {\n      props: {\n        css: false\n      },\n      on: {\n        enter: function (el, done) {\n          return done();\n        },\n        leave: function (el, done) {\n          return done();\n        },\n        beforeEnter: function beforeEnter(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          var $props = ref.$props;\n          events.beforeEnter(el);\n          css(doc$4, 'overflowY', scrollbarWidth && $props.overlay ? 'scroll' : '');\n          addClass(el, 'uk-open');\n          addClass($refs.bar, 'uk-offcanvas-none');\n        },\n        afterEnter: function afterEnter(el) {\n          events.afterEnter(el);\n        },\n        afterLeave: function afterLeave(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          removeClass(el, 'uk-open');\n          removeClass($refs.bar, 'uk-offcanvas-none');\n          events.afterLeave(el);\n        }\n      }\n    };\n    return h('transition', mergeData(def, data), children);\n  }\n};\nvar TransitionPush = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    var def = {\n      props: {\n        css: false\n      },\n      on: {\n        beforeEnter: function beforeEnter(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          var $props = ref.$props;\n          events.beforeEnter(el);\n          css(doc$4, 'overflowY', $props.flipped && scrollbarWidth && $props.overlay ? 'scroll' : '');\n          addClass($refs.bar, 'uk-offcanvas-bar-animation uk-offcanvas-push');\n        },\n        enter: function enter(el, done) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          height(el);\n          addClass(el, 'uk-open');\n          addClass($refs.content, 'uk-offcanvas-content-animation');\n          once(el, 'transitionend', done, false, function (e) {\n            return e.target === $refs.bar;\n          });\n        },\n        afterEnter: function afterEnter(el) {\n          events.afterEnter(el);\n        },\n        beforeLeave: function beforeLeave(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          removeClass(el, 'uk-open');\n          removeClass($refs.content, 'uk-offcanvas-content-animation');\n        },\n        leave: function leave(el, done) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          var bar = $refs.bar;\n          once(el, 'transitionend', done, false, function (e) {\n            return e.target === bar;\n          });\n        },\n        afterLeave: function afterLeave(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          removeClass($refs.bar, 'uk-offcanvas-bar-animation uk-offcanvas-push');\n          events.afterLeave(el);\n        }\n      }\n    };\n    return h('transition', mergeData(def, data), children);\n  }\n};\nvar TransitionSlide = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    var def = {\n      props: {\n        css: false\n      },\n      on: {\n        beforeEnter: function beforeEnter(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          var $props = ref.$props;\n          events.beforeEnter(el);\n          css(doc$4, 'overflowY', scrollbarWidth && $props.overlay ? 'scroll' : '');\n          addClass($refs.bar, 'uk-offcanvas-bar-animation uk-offcanvas-slide');\n        },\n        enter: function enter(el, done) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          height(el);\n          addClass(el, 'uk-open');\n          once(el, 'transitionend', done, false, function (e) {\n            return e.target === $refs.bar;\n          });\n        },\n        afterEnter: function afterEnter(el) {\n          events.afterEnter(el);\n        },\n        beforeLeave: function beforeLeave(el) {\n          removeClass(el, 'uk-open');\n        },\n        leave: function leave(el, done) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          once(el, 'transitionend', done, false, function (e) {\n            return e.target === $refs.bar;\n          });\n        },\n        afterLeave: function afterLeave(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          removeClass($refs.bar, 'uk-offcanvas-bar-animation uk-offcanvas-slide');\n          events.afterLeave(el);\n        }\n      }\n    };\n    return h('transition', mergeData(def, data), children);\n  }\n};\nvar TransitionReveal = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    var def = {\n      props: {\n        css: false\n      },\n      on: {\n        beforeEnter: function beforeEnter(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          var $props = ref.$props;\n          events.beforeEnter(el);\n          width($refs.content, width(win$3) - scrollbarWidth);\n          css(doc$4, 'overflowY', $props.flipped && scrollbarWidth && $props.overlay ? 'scroll' : '');\n        },\n        enter: function enter(el, done) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          height(el);\n          addClass(el, 'uk-open');\n          addClass($refs.content, 'uk-offcanvas-content-animation');\n          once(el, 'transitionend', done, false, function (e) {\n            return e.target === $refs.reveal;\n          });\n        },\n        afterEnter: function afterEnter(el) {\n          events.afterEnter(el);\n        },\n        beforeLeave: function beforeLeave(el) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          removeClass(el, 'uk-open');\n          removeClass($refs.content, 'uk-offcanvas-content-animation');\n        },\n        leave: function leave(el, done) {\n          var ref = el.__vkOffcanvas;\n          var $refs = ref.$refs;\n          once(el, 'transitionend', done, false, function (e) {\n            return e.target === $refs.reveal;\n          });\n        },\n        afterLeave: function afterLeave(el) {\n          events.afterLeave(el);\n        }\n      }\n    };\n    return h('transition', mergeData(def, data), children);\n  }\n};\nvar Transitions = {\n  none: TransitionNone,\n  push: TransitionPush,\n  slide: TransitionSlide,\n  reveal: TransitionReveal\n};\nvar offcanvas = {\n  props: {\n    show: {\n      type: Boolean,\n      default: false\n    },\n    flipped: {\n      type: Boolean,\n      default: false\n    },\n    stuck: {\n      type: Boolean,\n      default: false\n    },\n    overlay: {\n      type: Boolean,\n      default: false\n    },\n    mode: {\n      type: String,\n      default: 'slide',\n      validator: function (val) {\n        return /^(none|slide|push|reveal)$/.test(val);\n      }\n    }\n  },\n  mounted: function mounted() {\n    this.$refs.content = query('.uk-offcanvas-content');\n    this.$refs.bar = this.$el.querySelector('.uk-offcanvas-bar');\n\n    if (false) {}\n\n    this.$el.__vkOffcanvas = this;\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this.show) {\n      events.afterLeave(this.$el);\n    }\n  },\n  render: function render(h) {\n    var nodes = this.$slots.default || [];\n    var customBar = findBar(nodes);\n    var bar = customBar || h(ElementOffcanvasBar, nodes);\n    var content = h(ElementOffcanvas, {\n      key: this.mode,\n      class: {\n        'uk-offcanvas-overlay': this.overlay\n      },\n      directives: [{\n        name: 'show',\n        value: this.show\n      }]\n    }, [this.mode === 'reveal' ? h('div', {\n      class: 'uk-offcanvas-reveal',\n      ref: 'reveal'\n    }, [bar]) : bar]);\n    return h(Transitions[this.mode], [content]);\n  }\n};\n\nfunction findBar(nodes) {\n  return nodes.filter(function (n) {\n    return n.tag && n.data && /offcanvas-bar/.test(getNodeClass(n));\n  })[0];\n}\n\nfunction getNodeClass(node) {\n  return (node.data.class || []).concat([node.data.staticClass]).join(' ');\n}\n\nvar offcanvasContent = {\n  name: 'VkOffcanvasContent',\n  functional: true,\n  render: ElementOffcanvasContent.render\n};\nvar offcanvas_Bar = {\n  name: 'VkOffcanvasBar',\n  functional: true,\n  render: ElementOffcanvasBar.render\n};\nvar offcanvas_Close = {\n  name: 'VkOffcanvasClose',\n  functional: true,\n  props: ElementOffcanvasClose.props,\n  render: ElementOffcanvasClose.render\n};\nvar ElementPagination = {\n  functional: true,\n  props: {\n    align: {\n      type: String,\n      default: 'left',\n      validator: function (val) {\n        return /^(left|center|right)$/.test(val);\n      }\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var align = props.align;\n    return h('ul', mergeData(data, {\n      class: ['uk-pagination', (obj = {}, obj[\"uk-flex-\" + align] = align !== 'left', obj)]\n    }), children);\n  }\n};\nvar ElementPaginationPage = {\n  functional: true,\n  props: {\n    active: {\n      type: Boolean,\n      default: false\n    },\n    title: {\n      type: [String, Number],\n      default: ''\n    }\n  },\n  render: function (h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var active = props.active;\n    var title = props.title;\n    return h('li', {\n      class: {\n        'uk-active': active\n      }\n    }, [active ? h('span', title) : h('a', {\n      on: data.on\n    }, title)]);\n  }\n};\nvar Icon = {\n  functional: true,\n  render: function (h, ctx) {\n    var props = ctx.props;\n    var ratio = props.ratio || 1;\n    var width = props.width || 7;\n    var height = props.height || 12;\n    var viewBox = props.viewBox || '0 0 7 12';\n\n    if (ratio !== 1) {\n      width = width * ratio;\n      height = height * ratio;\n    }\n\n    return h('svg', {\n      attrs: {\n        version: '1.1',\n        meta: 'icon-pagination-next ratio-' + ratio,\n        width: width,\n        height: height,\n        viewBox: viewBox\n      },\n      domProps: {\n        innerHTML: '<path fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" d=\"M1 1l5 5-5 5\"/>'\n      }\n    });\n  }\n};\nvar ElementPaginationPageNext = {\n  functional: true,\n  props: {\n    title: {\n      type: String,\n      default: ''\n    },\n    expanded: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var listeners = ref.listeners;\n    var title = props.title;\n    var expanded = props.expanded;\n    var disabled = props.disabled;\n    delete data.on;\n    return h('li', mergeData(data, {\n      class: {\n        'uk-disabled': disabled,\n        'uk-margin-auto-left': expanded\n      }\n    }), [h('a', {\n      on: listeners\n    }, [title, h(ElementIcon, {\n      class: ['uk-pagination-prev', {\n        'uk-margin-small-left': title\n      }]\n    }, [h(Icon)])])]);\n  }\n};\nvar Icon$1 = {\n  functional: true,\n  render: function (h, ctx) {\n    var props = ctx.props;\n    var ratio = props.ratio || 1;\n    var width = props.width || 7;\n    var height = props.height || 12;\n    var viewBox = props.viewBox || '0 0 7 12';\n\n    if (ratio !== 1) {\n      width = width * ratio;\n      height = height * ratio;\n    }\n\n    return h('svg', {\n      attrs: {\n        version: '1.1',\n        meta: 'icon-pagination-prev ratio-' + ratio,\n        width: width,\n        height: height,\n        viewBox: viewBox\n      },\n      domProps: {\n        innerHTML: '<path fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" d=\"M6 1L1 6l5 5\"/>'\n      }\n    });\n  }\n};\nvar ElementPaginationPagePrev = {\n  functional: true,\n  props: {\n    title: {\n      type: String,\n      default: ''\n    },\n    expanded: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var listeners = ref.listeners;\n    var title = props.title;\n    var expanded = props.expanded;\n    var disabled = props.disabled;\n    delete data.on;\n    return h('li', mergeData(data, {\n      class: {\n        'uk-disabled': disabled,\n        'uk-margin-auto-right': expanded\n      }\n    }), [h('a', {\n      on: listeners\n    }, [h(ElementIcon, {\n      class: ['uk-pagination-prev', {\n        'uk-margin-small-right': title\n      }]\n    }, [h(Icon$1)]), title])]);\n  }\n};\n\nfunction Matrix(ref) {\n  if (ref === void 0) ref = {};\n  var total = ref.total;\n  if (total === void 0) total = 200;\n  var page = ref.page;\n  if (page === void 0) page = 1;\n  var perPage = ref.perPage;\n  if (perPage === void 0) perPage = 10;\n  var range$$1 = ref.range;\n  if (range$$1 === void 0) range$$1 = 3;\n  var matrix = [];\n  var totalPages = Math.ceil(total / perPage);\n\n  if (totalPages < 2) {\n    return [1];\n  }\n\n  var mainPages = getMainPages({\n    page: page,\n    range: range$$1,\n    totalPages: totalPages\n  });\n  var first = mainPages[0];\n  var last = mainPages[mainPages.length - 1];\n  var prePages = range(1, first <= 3 ? first : 2);\n  var postPages = range(last >= totalPages - 2 ? last + 1 : totalPages, totalPages + 1);\n  var nextPage = 1;\n  [].concat(prePages, mainPages, postPages).forEach(function (p) {\n    if (p === nextPage) {\n      matrix.push(p);\n      nextPage++;\n    } else {\n      matrix.push('...');\n      matrix.push(p);\n      nextPage = p + 1;\n    }\n  });\n  return matrix;\n}\n\nvar getMainPages = function (ref) {\n  var page = ref.page;\n  var range$$1 = ref.range;\n  var totalPages = ref.totalPages;\n  var start = page - range$$1;\n  var end = page + range$$1;\n\n  if (end > totalPages) {\n    end = totalPages;\n    start = totalPages - range$$1 * 2;\n    start = start < 1 ? 1 : start;\n  }\n\n  if (start <= 1) {\n    start = 1;\n    end = Math.min(range$$1 * 2 + 1, totalPages);\n  }\n\n  return range(start, end + 1);\n};\n\nvar pagination = {\n  name: 'Pagination',\n  directives: {\n    VkMargin: VkMargin\n  },\n  props: assign({}, ElementPagination.props, {\n    page: {\n      type: Number,\n      default: 1\n    },\n    perPage: {\n      type: Number,\n      required: true\n    },\n    total: {\n      type: Number,\n      required: true\n    },\n    range: {\n      type: Number,\n      default: 3\n    }\n  }),\n  computed: {\n    prevPage: function prevPage() {\n      return this.page - 1;\n    },\n    nextPage: function nextPage() {\n      return this.page + 1;\n    },\n    pages: function pages() {\n      return Matrix({\n        total: this.total,\n        page: this.page,\n        perPage: this.perPage\n      });\n    },\n    lastPage: function lastPage() {\n      return this.pages[this.pages.length - 1];\n    }\n  },\n  methods: {\n    update: function update(page) {\n      this.$emit('update:page', page);\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var nodes = (this.$slots.default || []).filter(function (node) {\n      return node.tag;\n    });\n    return h(ElementPagination, {\n      props: this.$props,\n      directives: [{\n        name: 'vk-margin'\n      }]\n    }, nodes.map(function (node) {\n      if (!node.fnOptions) {\n         false && false;\n        return;\n      }\n\n      return node.data.rerender ? h(node.fnOptions, mergeData(node.data, {\n        rerendering: true\n      })) : node;\n    }));\n  }\n};\nvar pagination_Pages = {\n  functional: true,\n  render: function (h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var parent = ref.parent;\n\n    if (!data.rerendering) {\n      return h('li', {\n        rerender: true\n      });\n    }\n\n    var currentPage = parent.page;\n    return parent.pages.map(function (page) {\n      var isPage = isNumber(page);\n      return isPage ? h(ElementPaginationPage, {\n        props: {\n          title: page,\n          active: currentPage === page\n        },\n        on: {\n          click: function (e) {\n            return parent.$emit('update:page', page);\n          }\n        }\n      }) : h('li', [h('span', '...')]);\n    });\n  }\n};\nvar pagination_PageFirst = {\n  functional: true,\n  props: ElementPaginationPagePrev.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var parent = ref.parent;\n    var title = props.title;\n    var expanded = props.expanded;\n\n    if (!data.rerendering) {\n      return h('li', mergeData(data, {\n        rerender: true,\n        props: props\n      }));\n    }\n\n    return h(ElementPaginationPagePrev, {\n      props: {\n        title: title,\n        expanded: expanded,\n        disabled: parent.prevPage < 1\n      },\n      on: {\n        click: function (e) {\n          return parent.update(1);\n        }\n      }\n    });\n  }\n};\nvar pagination_PagePrev = {\n  functional: true,\n  props: ElementPaginationPagePrev.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var parent = ref.parent;\n    var title = props.title;\n    var expanded = props.expanded;\n\n    if (!data.rerendering) {\n      return h('li', mergeData(data, {\n        rerender: true,\n        props: props\n      }));\n    }\n\n    return h(ElementPaginationPagePrev, {\n      props: {\n        title: title,\n        expanded: expanded,\n        disabled: parent.prevPage < 1\n      },\n      on: {\n        click: function (e) {\n          return parent.update(parent.prevPage);\n        }\n      }\n    });\n  }\n};\nvar pagination_PageNext = {\n  functional: true,\n  props: ElementPaginationPageNext.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var parent = ref.parent;\n    var title = props.title;\n    var expanded = props.expanded;\n\n    if (!data.rerendering) {\n      return h('li', mergeData(data, {\n        rerender: true,\n        props: props\n      }));\n    }\n\n    return h(ElementPaginationPageNext, {\n      props: {\n        title: title,\n        expanded: expanded,\n        disabled: parent.nextPage > parent.lastPage\n      },\n      on: {\n        click: function (e) {\n          return parent.update(parent.nextPage);\n        }\n      }\n    });\n  }\n};\nvar pagination_PageLast = {\n  functional: true,\n  props: ElementPaginationPageNext.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var parent = ref.parent;\n    var title = props.title;\n    var expanded = props.expanded;\n\n    if (!data.rerendering) {\n      return h('li', mergeData(data, {\n        rerender: true,\n        props: props\n      }));\n    }\n\n    return h(ElementPaginationPageNext, {\n      props: {\n        title: title,\n        expanded: expanded,\n        disabled: parent.nextPage > parent.lastPage\n      },\n      on: {\n        click: function (e) {\n          return parent.update(parent.lastPage);\n        }\n      }\n    });\n  }\n};\nvar fastdom = {\n  reads: [],\n  writes: [],\n  read: function read(task) {\n    this.reads.push(task);\n    scheduleFlush();\n    return task;\n  },\n  write: function write(task) {\n    this.writes.push(task);\n    scheduleFlush();\n    return task;\n  },\n  clear: function clear(task) {\n    return remove$1(this.reads, task) || remove$1(this.writes, task);\n  },\n  flush: function flush() {\n    runTasks(this.reads);\n    runTasks(this.writes.splice(0, this.writes.length));\n    this.scheduled = false;\n\n    if (this.reads.length || this.writes.length) {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction scheduleFlush() {\n  if (!fastdom.scheduled) {\n    fastdom.scheduled = true;\n    requestAnimationFrame(fastdom.flush.bind(fastdom));\n  }\n}\n\nfunction runTasks(tasks) {\n  var task;\n\n  while (task = tasks.shift()) {\n    task();\n  }\n}\n\nfunction remove$1(array, item) {\n  var index = array.indexOf(item);\n  return !!~index && !!array.splice(index, 1);\n}\n\nvar DATA = '_vk_fastdom_data';\nvar FRAMES = '_vk_fastdom_frames';\nvar scroll$1 = 0;\nvar instances = [];\n\nif (typeof window !== 'undefined') {\n  on(window, 'load resize', function () {\n    return instances.forEach(function (i) {\n      return i.fastdomUpdate();\n    });\n  });\n  on(window, 'scroll', function (e) {\n    e.dir = scroll$1 <= window.pageYOffset ? 'down' : 'up';\n    e.scrollY = scroll$1 = window.pageYOffset;\n    instances.forEach(function (inst) {\n      return inst.fastdomUpdate(e);\n    });\n  });\n}\n\nvar MixinFastdom = {\n  methods: {\n    fastdomUpdate: function fastdomUpdate(e, parents) {\n      if (parents === void 0) parents = false;\n      e = createEvent(e || 'update');\n      var instance = this;\n\n      if (parents) {\n        do {\n          if (instance._fastdom_ready) {\n            instance._fastdomUpdate(e);\n          }\n\n          instance = instance.$parent();\n        } while (instance);\n      } else {\n        apply$2(instance, function (instance) {\n          if (instance._fastdom_ready) {\n            instance._fastdomUpdate(e);\n          }\n        });\n      }\n    },\n    _fastdomUpdate: function _fastdomUpdate(e) {\n      var this$1 = this;\n      e = createEvent(e || 'update');\n      var type = e.type;\n      var updates = this.$options.fastdom;\n      var ref = this[FRAMES];\n      var reads = ref.reads;\n      var writes = ref.writes;\n\n      if (!updates) {\n        return;\n      }\n\n      updates.forEach(function (ref, i) {\n        var read = ref.read;\n        var write = ref.write;\n        var events = ref.events;\n\n        if (type !== 'update' && !includes(events, type)) {\n          return;\n        }\n\n        if (read && !includes(fastdom.reads, reads[i])) {\n          reads[i] = fastdom.read(function () {\n            var result = read.call(this$1, this$1[DATA], e);\n\n            if (result === false && write) {\n              fastdom.clear(writes[i]);\n              delete writes[i];\n            } else if (isPlainObject(result)) {\n              assign(this$1[DATA], result);\n            }\n\n            delete reads[i];\n          });\n        }\n\n        if (write && !includes(fastdom.writes, writes[i])) {\n          writes[i] = fastdom.write(function () {\n            write.call(this$1, this$1[DATA], e);\n            delete writes[i];\n          });\n        }\n      });\n    }\n  },\n  created: function created() {\n    this[DATA] = {};\n    this[FRAMES] = {\n      reads: {},\n      writes: {}\n    };\n    instances.push(this);\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n    this._fastdom_ready || ready(function () {\n      var hook = this$1.$options.domReady;\n      hook && hook.call(this$1);\n      this$1._fastdom_ready = true;\n\n      this$1._fastdomUpdate();\n    });\n\n    this._fastdomUpdate();\n  },\n  beforeDestroy: function beforeDestroy() {\n    var this$1 = this;\n    var index$$1 = instances.indexOf(instances.filter(function (inst) {\n      return inst === this$1;\n    })[0]);\n    instances.splice(index$$1, 1);\n  }\n};\nvar scrollspy = {\n  name: 'VkScrollspy',\n  abstract: true,\n  mixins: [EventsMixin, MixinFastdom],\n  props: {\n    cls: {\n      type: Array,\n      default: function () {\n        return [];\n      }\n    },\n    target: {\n      default: false\n    },\n    hidden: {\n      type: Boolean,\n      default: true\n    },\n    offsetTop: {\n      type: Number,\n      default: 0\n    },\n    offsetLeft: {\n      type: Number,\n      default: 0\n    },\n    repeat: {\n      type: Boolean,\n      default: false\n    },\n    delay: {\n      type: Number,\n      default: 0\n    }\n  },\n  classMapping: {\n    inViewClass: 'uk-scrollspy-inview'\n  },\n  computed: {\n    elements: function elements() {\n      return this.target ? $$(this.target, this.$el) : [this.$el];\n    }\n  },\n  fastdom: [{\n    write: function write() {\n      var ref = this.$options.classMapping;\n      var inViewClass = ref.inViewClass;\n\n      if (this.hidden) {\n        css(filter(this.elements, \":not(.\" + inViewClass + \")\"), 'visibility', 'hidden');\n      }\n    }\n  }, {\n    read: function read(els) {\n      var this$1 = this;\n      this.elements.forEach(function (el, i) {\n        var elData = els[i];\n\n        if (!elData || elData.el !== el) {\n          var cls = data(el, 'vk-scrollspy-class');\n          elData = {\n            el: el,\n            toggles: cls && cls.split(',') || this$1.cls\n          };\n        }\n\n        elData.show = isInView(el, this$1.offsetTop, this$1.offsetLeft);\n        els[i] = elData;\n      });\n    },\n    write: function write(els) {\n      var this$1 = this;\n      var ref = this.$options.classMapping;\n      var inViewClass = ref.inViewClass;\n      var index = this.elements.length === 1 ? 1 : 0;\n      this.elements.forEach(function (el, i) {\n        var elData = els[i];\n        var cls = elData.toggles[i] || elData.toggles[0];\n\n        if (elData.show && !elData.inview && !elData.timer) {\n          var show = function () {\n            css(el, 'visibility', '');\n            addClass(el, inViewClass);\n            toggleClass(el, cls);\n            trigger(el, 'inview');\n            this$1.fastdomUpdate();\n            elData.inview = true;\n            delete elData.timer;\n          };\n\n          if (this$1.delay && index) {\n            elData.timer = setTimeout(show, this$1.delay * index);\n          } else {\n            show();\n          }\n\n          index++;\n        } else if (!elData.show && elData.inview && this$1.repeat) {\n          if (elData.timer) {\n            clearTimeout(elData.timer);\n            delete elData.timer;\n          }\n\n          css(el, 'visibility', this$1.hidden ? 'hidden' : '');\n          removeClass(el, inViewClass);\n          toggleClass(el, cls);\n          trigger(el, 'outview');\n          this$1.fastdomUpdate();\n          elData.inview = false;\n        }\n      });\n    },\n    events: ['scroll', 'load', 'resize']\n  }],\n  render: function render(h) {\n    var children = this.$slots.default;\n\n    if (!children) {\n      return;\n    }\n\n    children = filterOutTextNodes(children);\n\n    if (!children.length) {\n      return;\n    }\n\n    if (false) {}\n\n    return children[0];\n  }\n};\nvar scrollspyNav = {\n  name: 'VkScrollspyNav',\n  abstract: true,\n  mixins: [EventsMixin, MixinFastdom],\n  props: {\n    cls: {\n      type: String,\n      default: 'uk-active'\n    },\n    closest: {\n      type: String,\n      default: ''\n    },\n    overflow: {\n      type: Boolean,\n      default: true\n    },\n    offset: {\n      type: Number,\n      default: 0\n    }\n  },\n  methods: {\n    setComputed: function setComputed() {\n      this.links = $$('a[href^=\"#\"]', this.$el).filter(function (el) {\n        return el.hash;\n      });\n      this.elements = this.closest ? closest(this.links, this.closest) : this.links;\n      this.targets = $$(this.links.map(function (el) {\n        return el.hash;\n      }).join(','));\n    }\n  },\n  fastdom: [{\n    read: function read(data) {\n      var this$1 = this;\n      var scroll = window.pageYOffset + this.offset + 1;\n      var max = height(document) - height(window) + this.offset;\n      data.active = false;\n      this.targets.every(function (el, i) {\n        var ref = offset(el);\n        var top = ref.top;\n        var last = i + 1 === this$1.targets.length;\n\n        if (!this$1.overflow && (i === 0 && top > scroll || last && top + el.offsetTop < scroll)) {\n          return false;\n        }\n\n        if (!last && offset(this$1.targets[i + 1]).top <= scroll) {\n          return true;\n        }\n\n        if (scroll >= max) {\n          for (var j = this$1.targets.length - 1; j > i; j--) {\n            if (isInView(this$1.targets[j])) {\n              el = this$1.targets[j];\n              break;\n            }\n          }\n        }\n\n        return !(data.active = $(filter(this$1.links, \"[href=\\\"#\" + el.id + \"\\\"]\")));\n      });\n    },\n    write: function write(ref) {\n      var active = ref.active;\n      this.links.forEach(function (el) {\n        return el.blur();\n      });\n      removeClass(this.elements, this.cls);\n\n      if (active) {\n        trigger(this.$el, 'active', [active, addClass(this.closest ? closest(active, this.closest) : active, this.cls)]);\n      }\n    },\n    events: ['scroll', 'load', 'resize']\n  }],\n  mounted: function mounted() {\n    this.setComputed();\n  },\n  updated: function updated() {\n    var this$1 = this;\n    this.$nextTick(function () {\n      this$1.setComputed();\n      this$1.fastdomUpdate();\n    });\n  },\n  render: function render(h) {\n    var children = this.$slots.default;\n\n    if (!children) {\n      return;\n    }\n\n    children = filterOutTextNodes(children);\n\n    if (!children.length) {\n      return;\n    }\n\n    if (false) {}\n\n    return children[0];\n  }\n};\nvar ElementSkeleton = {\n  functional: true,\n  props: {\n    animated: {\n      type: Boolean,\n      default: false\n    },\n    width: {\n      type: [Boolean, Number],\n      default: false\n    },\n    height: {\n      type: [Boolean, Number],\n      default: false\n    }\n  },\n  render: function (h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var animated = props.animated;\n    var width = props.width;\n    var height = props.height;\n    return h('div', mergeData({\n      class: {\n        'vk-skeleton--animated': animated\n      },\n      style: {\n        width: width + \"px\",\n        height: height + \"px\"\n      }\n    }, data), [h('div', {\n      class: 'vk-skeleton-content'\n    })]);\n  }\n};\nvar ElementSkeletonImage = {\n  functional: true,\n  props: assign({}, ElementSkeleton.props, {\n    width: {\n      type: Number,\n      default: 150\n    },\n    height: {\n      type: Number,\n      default: 120\n    }\n  }),\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h(ElementSkeleton, mergeData(data, {\n      class: 'vk-skeleton-image',\n      props: props\n    }));\n  }\n};\nvar ElementSkeletonText = {\n  functional: true,\n  props: ElementSkeleton.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h(ElementSkeleton, mergeData(data, {\n      class: 'vk-skeleton-text',\n      props: props\n    }));\n  }\n};\nvar ElementSkeletonTitle = {\n  functional: true,\n  props: ElementSkeleton.props,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h(ElementSkeleton, mergeData(data, {\n      class: 'vk-skeleton-title',\n      props: props\n    }));\n  }\n};\nvar skeletonImage = {\n  name: 'VkSkeletonImage',\n  functional: true,\n  props: ElementSkeletonImage.props,\n  render: ElementSkeletonImage.render\n};\nvar skeletonText = {\n  name: 'VkSkeletonText',\n  functional: true,\n  props: ElementSkeletonText.props,\n  render: ElementSkeletonText.render\n};\nvar skeletonTitle = {\n  name: 'VkSkeletonTitle',\n  functional: true,\n  props: ElementSkeletonTitle.props,\n  render: ElementSkeletonTitle.render\n};\nvar Icon$2 = {\n  functional: true,\n  render: function (h, ctx) {\n    var props = ctx.props;\n    var ratio = props.ratio || 1;\n    var width = props.width || 30;\n    var height = props.height || 30;\n    var viewBox = props.viewBox || '0 0 30 30';\n\n    if (ratio !== 1) {\n      width = width * ratio;\n      height = height * ratio;\n    }\n\n    return h('svg', {\n      attrs: {\n        version: '1.1',\n        width: width,\n        height: height,\n        viewBox: viewBox\n      },\n      domProps: {\n        innerHTML: '<circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/>'\n      }\n    });\n  }\n};\nvar ElementSpinner = {\n  functional: true,\n  props: {\n    ratio: {\n      type: [String, Number]\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    return h('div', mergeData(data, {\n      class: ['uk-icon', 'uk-spinner']\n    }), [h(Icon$2, {\n      props: props\n    })]);\n  }\n};\nvar spinner = {\n  name: 'VkSpinner',\n  functional: true,\n  props: ElementSpinner.props,\n  render: ElementSpinner.render\n};\nvar ACTIVE = 'active';\nvar INACTIVE = 'inactive';\nvar sticky = {\n  name: 'VkSticky',\n  abstract: true,\n  mixins: [EventsMixin, MixinFastdom],\n  props: {\n    top: {\n      type: [Number, String],\n      default: 0\n    },\n    bottom: {\n      type: [Boolean, String],\n      default: false\n    },\n    offset: {\n      type: Number,\n      default: 0\n    },\n    widthElement: {\n      default: false\n    },\n    animation: {\n      type: String,\n      default: ''\n    },\n    showOnUp: {\n      type: Boolean,\n      default: false\n    },\n    media: {\n      type: [Number, String]\n    },\n    selTarget: {\n      type: String\n    },\n    target: {\n      type: [Number, Boolean],\n      default: false\n    }\n  },\n  classMapping: {\n    clsFixed: 'uk-sticky-fixed',\n    clsBelow: 'uk-sticky-below',\n    clsActive: 'uk-active',\n    clsInactive: ''\n  },\n  data: function () {\n    return {\n      isActive: false\n    };\n  },\n  computed: {\n    outerHeight: function outerHeight() {\n      return (this.isActive ? this.$refs.placeholder : this.$el).offsetHeight;\n    },\n    $selTarget: function $selTarget() {\n      return this.selTarget ? $(this.selTarget, this.$el) : this.$el;\n    }\n  },\n  fastdom: [{\n    write: function write() {\n      var ref = this.$refs;\n      var placeholder = ref.placeholder;\n      var widthElement = ref.widthElement;\n      var outerHeight = (this.isActive ? placeholder : this.$el).offsetHeight;\n      css(placeholder, assign({\n        height: css(this.$el, 'position') !== 'absolute' ? outerHeight : ''\n      }, css(this.$el, ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'])));\n\n      if (!within(placeholder, document)) {\n        after(this.$el, placeholder);\n        attr(placeholder, 'hidden', '');\n      }\n\n      attr(widthElement, 'hidden', null);\n      this.width = widthElement.offsetWidth;\n      attr(widthElement, 'hidden', this.isActive ? null : '');\n      this.topOffset = offset(this.isActive ? placeholder : this.$el).top;\n      this.bottomOffset = this.topOffset + outerHeight;\n      var bottom = parseProp('bottom', this);\n      this.stickAt = Math.max(toFloat(parseProp('top', this)), this.topOffset) - this.offset;\n      this.stickUntil = bottom && bottom - outerHeight;\n      this.inactive = this.media && !window.matchMedia(toMedia(this.media)).matches;\n\n      if (this.isActive) {\n        this.update();\n      }\n    },\n    events: ['load', 'resize']\n  }, {\n    read: function read(_, ref) {\n      var scrollY = ref.scrollY;\n      if (scrollY === void 0) scrollY = window.pageYOffset;\n      this.scroll = scrollY;\n      return {\n        scroll: scrollY,\n        visible: isVisible(this.$el)\n      };\n    },\n    write: function write(ref, ref$1) {\n      var this$1 = this;\n      var visible = ref.visible;\n      var scroll = ref.scroll;\n      if (ref$1 === void 0) ref$1 = {};\n      var dir = ref$1.dir;\n\n      if (scroll < 0 || !visible || this.disabled || this.showOnUp && !dir) {\n        return;\n      }\n\n      if (this.inactive || scroll < this.stickAt || this.showOnUp && (scroll <= this.stickAt || dir === 'down' || dir === 'up' && !this.isActive && scroll <= this.bottomOffset)) {\n        if (!this.isActive) {\n          return;\n        }\n\n        this.isActive = false;\n\n        if (this.animation && scroll > this.topOffset) {\n          Animation.cancel(this.$el);\n          Animation.out(this.$el, \"uk-animation-\" + this.animation).then(function () {\n            return this$1.hide();\n          }, noop);\n        } else {\n          this.hide();\n        }\n      } else if (this.isActive) {\n        this.update();\n      } else if (this.animation) {\n        Animation.cancel(this.$el);\n        this.show();\n        Animation.in(this.$el, \"uk-animation-\" + this.animation).catch(noop);\n      } else {\n        this.show();\n      }\n    },\n    events: ['scroll']\n  }],\n  methods: {\n    show: function show() {\n      this.isActive = true;\n      this.update();\n      attr(this.$refs.placeholder, 'hidden', null);\n    },\n    hide: function hide() {\n      var ref = this.$options.classMapping;\n      var clsFixed = ref.clsFixed;\n      var clsBelow = ref.clsBelow;\n      var clsActive = ref.clsActive;\n\n      if (!this.isActive || hasClass(this.$selTarget, clsActive)) {\n        this.$emit(INACTIVE);\n      }\n\n      removeClass(this.$el, clsFixed, clsBelow);\n      css(this.$el, {\n        position: '',\n        top: '',\n        width: ''\n      });\n      attr(this.$refs.placeholder, 'hidden', '');\n    },\n    update: function update() {\n      var ref = this.$options.classMapping;\n      var clsFixed = ref.clsFixed;\n      var clsBelow = ref.clsBelow;\n      var clsActive = ref.clsActive;\n      var active = this.stickAt !== 0 || this.scroll > this.stickAt;\n      var top = Math.max(0, this.offset);\n\n      if (this.stickUntil && this.scroll > this.stickUntil - this.offset) {\n        top = this.stickUntil - this.scroll;\n      }\n\n      css(this.$el, {\n        position: 'fixed',\n        top: top + \"px\",\n        width: this.width\n      });\n\n      if (hasClass(this.$selTarget, clsActive)) {\n        if (!active) {\n          this.$emit(INACTIVE);\n        }\n      } else if (active) {\n        this.$emit(ACTIVE);\n      }\n\n      toggleClass(this.$el, clsBelow, this.scroll > this.bottomOffset);\n      addClass(this.$el, clsFixed);\n    }\n  },\n  created: function created() {\n    var this$1 = this;\n    var ref = this.$options.classMapping;\n    var clsActive = ref.clsActive;\n    var clsInactive = ref.clsInactive;\n    this.$on(ACTIVE, function () {\n      return replaceClass(this$1.$selTarget, clsInactive, clsActive);\n    });\n    this.$on(INACTIVE, function () {\n      return replaceClass(this$1.$selTarget, clsActive, clsInactive);\n    });\n  },\n  mounted: function mounted() {\n    addClass(this.$el, 'uk-sticky');\n    this.$refs.placeholder = $('<div class=\"uk-sticky-placeholder\"></div>');\n    this.$refs.widthElement = this.widthElement && query(this.widthElement) || this.$refs.placeholder;\n\n    if (!this.isActive) {\n      this.hide();\n    }\n  },\n  domReady: function domReady() {\n    var this$1 = this;\n\n    if (!(this.target && location.hash && window.pageYOffset > 0)) {\n      return;\n    }\n\n    var target = $(location.hash);\n\n    if (target) {\n      fastdom.read(function () {\n        var ref = offset(target);\n        var top = ref.top;\n        var elTop = offset(this$1.$el).top;\n        var elHeight = this$1.$el.offsetHeight;\n\n        if (elTop + elHeight >= top && elTop <= top + target.offsetHeight) {\n          window.scrollTo(0, top - elHeight - this$1.target - this$1.offset);\n        }\n      });\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    var ref = this.$options.classMapping;\n    var clsInactive = ref.clsInactive;\n\n    if (this.isActive) {\n      this.isActive = false;\n      this.hide();\n      removeClass(this.$selTarget, clsInactive);\n    }\n\n    remove(this.$refs.placeholder);\n    this.$refs.placeholder = null;\n    this.$refs.widthElement = null;\n  },\n  render: function render(h) {\n    var children = this.$slots.default;\n\n    if (!children) {\n      return;\n    }\n\n    children = filterOutTextNodes(children);\n\n    if (!children.length) {\n      return;\n    }\n\n    if (false) {}\n\n    return children[0];\n  }\n};\n\nfunction parseProp(prop, ref) {\n  var $props = ref.$props;\n  var $el = ref.$el;\n  var propOffset = ref[prop + \"Offset\"];\n  var value = $props[prop];\n  value = isString(value) && value === '' ? true : value;\n\n  if (!value) {\n    return;\n  }\n\n  if (isNumeric(value)) {\n    return propOffset + toFloat(value);\n  } else if (isString(value) && /^-?\\d+vh$/.test(value)) {\n    return height(window) * toFloat(value) / 100;\n  } else {\n    var el = value === true ? $el.parentNode : query(value, $el);\n\n    if (el) {\n      return offset(el).top + el.offsetHeight;\n    }\n  }\n}\n\nvar ElementSubnav = {\n  functional: true,\n  props: {\n    divided: {\n      type: Boolean,\n      default: false\n    },\n    pill: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var divided = props.divided;\n    var pill = props.pill;\n    return h('ul', mergeData(data, {\n      class: ['uk-subnav', {\n        'uk-subnav-divider': divided,\n        'uk-subnav-pill': pill\n      }]\n    }), children);\n  }\n};\nvar ElementSubnavItem = {\n  functional: true,\n  props: {\n    title: {\n      type: String,\n      required: true\n    },\n    active: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function (h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var listeners = ref.listeners;\n    var title = props.title;\n    var active = props.active;\n    var disabled = props.disabled;\n    delete data.on;\n    return h('li', mergeData(data, {\n      class: {\n        'uk-active': active && !disabled,\n        'uk-disabled': disabled\n      }\n    }), [disabled ? h('span', title) : h('a', {\n      on: listeners\n    }, title)]);\n  }\n};\nvar ElementSubnavItemDropdown = {\n  functional: true,\n  props: {\n    title: {\n      type: String,\n      required: true\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var disabled = props.disabled;\n    var title = props.title;\n    return h('li', mergeData(data, {\n      class: {\n        'uk-disabled': disabled\n      }\n    }), [disabled ? h('span', title) : children]);\n  }\n};\nvar subnav = {\n  name: 'VkSubnav',\n  props: assign({}, ElementSubnav.props, {\n    activeItem: {}\n  }),\n  data: function (vm) {\n    return {\n      state: {\n        activeItem: vm.activeItem || filterItems(vm).shift().data.key || 0\n      }\n    };\n  },\n  computed: {\n    items: function items() {\n      return (this.$slots.default || []).filter(function (n) {\n        return n.tag;\n      });\n    }\n  },\n  watch: {\n    activeItem: function activeItem(val) {\n      this.state.activeItem = val;\n    }\n  },\n  methods: {\n    triggerUpdate: function triggerUpdate(val) {\n      this.state.activeItem = val;\n      this.$emit('update:activeItem', val);\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n    return h(ElementSubnav, {\n      props: this.$props\n    }, filterItems(this).map(function (node, index) {\n      if (false) {}\n\n      var key = get(node, 'data.key', index);\n      return node.data.rerender ? h(node.fnOptions, mergeData({}, node.data, {\n        key: key,\n        rerendering: true,\n        props: {\n          active: JSON.stringify(key) === JSON.stringify(this$1.state.activeItem)\n        }\n      }), node.children) : node;\n    }));\n  }\n};\n\nfunction filterItems(vm) {\n  return vm.$slots.default.filter(function (n) {\n    return n.tag;\n  });\n}\n\nvar subnav_Item = {\n  name: 'VkSubnavItem',\n  functional: true,\n  props: ElementSubnavItem.props,\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var parent = ref.parent;\n\n    if (data.rerendering) {\n      delete data.class;\n    }\n\n    return h(ElementSubnavItem, mergeData(data, {\n      props: props\n    }, {\n      rerender: true,\n      on: {\n        click: function (e) {\n          e.preventDefault();\n          parent.triggerUpdate(data.key);\n        }\n      }\n    }));\n  }\n};\nvar IconTriangeDown = {\n  functional: true,\n  render: function (h, ref) {\n    var props = ref.props;\n    var width = props.width || 20;\n    var height = props.height || 20;\n    var viewBox = props.viewBox || '0 0 20 20';\n    return h('svg', {\n      attrs: {\n        version: '1.1',\n        width: width,\n        height: height,\n        viewBox: viewBox\n      },\n      domProps: {\n        innerHTML: '<polygon points=\"5 7 15 7 10 12\" />'\n      }\n    });\n  }\n};\nvar subnav_ItemDropdown = {\n  name: 'VkSubnavItemDropdown',\n  functional: true,\n  props: assign({}, ElementSubnavItemDropdown.props, Dropdown.props, {\n    mode: {\n      type: String,\n      default: 'click'\n    }\n  }),\n  render: function render(h, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var title = props.title;\n    return h(ElementSubnavItemDropdown, {\n      props: props\n    }, [h('a', {\n      class: ['uk-icon']\n    }, [title + ' ', h(IconTriangeDown)]), h(Dropdown, {\n      props: props\n    }, [children])]);\n  }\n};\nvar MixinSort = {\n  props: {\n    sortedBy: {\n      type: Object\n    }\n  }\n};\nvar ROW_ID = '__vkTable_rowId';\nvar ROW_LEVEL = '__vkTable_rowLevel';\nvar ROW_CHILDREN_COUNT = '__vkTable_rowChildrenCount';\nvar ROW_CLICK_PREVENTED = '__vkTable_rowClickPrevented';\nvar ON_CLICK_ROW = 'click-row';\nvar UPDATE_SORTEDBY = 'update:sortedBy';\nvar UPDATE_EXPANDEDROWS = 'update:expandedRows';\nvar UPDATE_SELECTEDROWS = 'update:selectedRows';\nvar MixinSelect = {\n  props: {\n    selectedRows: {\n      type: Array,\n      default: function () {\n        return [];\n      }\n    },\n    rowSelectable: {\n      type: Boolean,\n      default: false\n    },\n    rowsSelectable: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    selectRow: function selectRow(row) {\n      var id = row[ROW_ID];\n\n      if (this.rowSelectable) {\n        this.updateRowSelection([id]);\n        return;\n      }\n\n      var selectedRows = [].concat(this.selectedRows);\n      selectedRows.push(id);\n      this.updateRowSelection(selectedRows);\n    },\n    unselectRow: function unselectRow(row) {\n      var id = row[ROW_ID];\n      var index = this.selectedRows.indexOf(id);\n      var selectedRows = [].concat(this.selectedRows);\n      selectedRows.splice(index, 1);\n      this.updateRowSelection(selectedRows);\n    },\n    toggleRowSelection: function toggleRowSelection(row) {\n      this.isRowSelected(row) ? this.unselectRow(row) : this.selectRow(row);\n    },\n    toggleRowsSelection: function toggleRowsSelection() {\n      var selectedRows = [];\n\n      if (!this.allRowsSelected) {\n        selectedRows = this.rows.map(function (row) {\n          return row[ROW_ID];\n        });\n      }\n\n      this.updateRowSelection(selectedRows);\n    },\n    isRowSelected: function isRowSelected(row) {\n      return Boolean(this.selectedRows.filter(function (id) {\n        return JSON.stringify(id) === JSON.stringify(row[ROW_ID]);\n      }).length);\n    },\n    updateRowSelection: function updateRowSelection(selectedRows) {\n      this.$emit(UPDATE_SELECTEDROWS, selectedRows);\n    }\n  },\n  computed: {\n    allRowsSelected: function allRowsSelected() {\n      if (this.selectedRows && this.selectedRows.length < this.rows.length) {\n        return false;\n      }\n\n      var selected = this.rows.filter(this.isRowSelected);\n      return selected.length === this.rows.length;\n    }\n  },\n  created: function created() {\n    if (this.rowsSelectable || this.rowSelectable) {\n      this.$on(ON_CLICK_ROW, this.toggleRowSelection);\n    }\n  }\n};\nvar ElementTable = {\n  functional: true,\n  props: {\n    divided: {\n      type: Boolean,\n      default: true\n    },\n    narrowed: {\n      type: Boolean,\n      default: false\n    },\n    cellMiddle: {\n      type: Boolean,\n      default: false\n    },\n    striped: {\n      type: Boolean,\n      default: false\n    },\n    hoverable: {\n      type: Boolean,\n      default: false\n    },\n    justified: {\n      type: Boolean,\n      default: false\n    },\n    responsive: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    return h('table', mergeData(data, {\n      class: ['uk-table', {\n        'uk-table-small': props.narrowed,\n        'uk-table-hover': props.hoverable,\n        'uk-table-middle': props.cellMiddle,\n        'uk-table-divider': props.divided,\n        'uk-table-striped': props.striped,\n        'uk-table-justify': props.justified,\n        'uk-table-responsive': props.responsive\n      }]\n    }), children);\n  }\n};\nvar ElementTableTd = {\n  functional: true,\n  props: {\n    cellMiddle: {\n      type: Boolean,\n      default: false\n    },\n    shrinked: {\n      type: Boolean,\n      default: false\n    },\n    expanded: {\n      type: Boolean,\n      default: false\n    },\n    width: {\n      type: String,\n      default: ''\n    },\n    linked: {\n      type: Boolean,\n      default: false\n    },\n    truncated: {\n      type: Boolean,\n      default: false\n    },\n    unwrapped: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var obj;\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var cellMiddle = props.cellMiddle;\n    var shrinked = props.shrinked;\n    var expanded = props.expanded;\n    var width = props.width;\n    var linked = props.linked;\n    var truncated = props.truncated;\n    var unwrapped = props.unwrapped;\n    return h('td', mergeData(data, {\n      class: (obj = {\n        'uk-table-link': linked,\n        'uk-table-middle': cellMiddle,\n        'uk-table-shrink': shrinked,\n        'uk-table-expand': expanded,\n        'uk-text-nowrap': unwrapped,\n        'uk-text-truncate': truncated\n      }, obj[\"uk-width-\" + width] = width, obj)\n    }), children);\n  }\n};\nvar ElementTableTr = {\n  functional: true,\n  props: {\n    active: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var active = props.active;\n    return h('tr', mergeData(data, {\n      class: {\n        'uk-active': active\n      }\n    }), children);\n  }\n};\nvar ElementTableTh = {\n  functional: true,\n  props: {\n    shrinked: {\n      type: Boolean,\n      default: false\n    },\n    expanded: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var shrinked = props.shrinked;\n    var expanded = props.expanded;\n    return h('th', mergeData(data, {\n      class: {\n        'uk-table-shrink': shrinked,\n        'uk-table-expand': expanded\n      }\n    }), children);\n  }\n};\nvar ElementTableThSort = {\n  functional: true,\n  props: assign({}, ElementTableTh.props, {\n    order: {\n      type: String\n    }\n  }),\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var order = props.order;\n    return h(ElementTableTh, mergeData(data, {\n      class: 'vk-table-column-sort uk-visible-hover-inline'\n    }), [h('div', {\n      class: 'uk-text-nowrap uk-position-relative'\n    }, [children, h('span', mergeData(data, {\n      class: ['vk-table-column-sort__arrow uk-position-absolute', {\n        'uk-invisible': !order,\n        'vk-table-column-sort__arrow--rotated': !order || order === 'asc'\n      }]\n    }))])]);\n  }\n};\nvar Row = {\n  functional: true,\n  render: function render(h, ref) {\n    var data = ref.data;\n    var children = ref.children;\n    var parent = ref.parent;\n    var $row = data.$row;\n    return h(ElementTableTr, {\n      props: {\n        active: parent.isRowSelected($row)\n      },\n      class: resolveClass(parent.rowClass, $row),\n      on: {\n        click: function (e) {\n          var isPrevented = e[ROW_CLICK_PREVENTED];\n          var isIgnoredTag = /^(A|BUTTON)$/.test(e.target.tagName);\n\n          if (isPrevented || isIgnoredTag) {\n            return;\n          }\n\n          parent.$emit(ON_CLICK_ROW, $row);\n        }\n      }\n    }, children);\n  }\n};\n\nfunction Render(h, ref) {\n  var rows = ref.rows;\n  var props = ref.props;\n  var columns = ref.columns;\n  var table = ref.table;\n  columns = columns.filter(function (node) {\n    var isValid = node.fnOptions && node.fnOptions.headRender && node.fnOptions.cellRender;\n\n    if (false) {}\n\n    return isValid;\n  });\n  var isHeadless = !columns.some(function (node) {\n    return node.children || get(node, 'data.props.title') || get(node, 'data.props.head');\n  });\n  return h(ElementTable, {\n    props: props\n  }, [isHeadless || h('thead', [h(ElementTableTr, columns.map(function (node) {\n    var fnOptions = node.fnOptions;\n    delete node.data.class;\n    return h({\n      functional: true,\n      render: fnOptions.headRender\n    }, node.data);\n  }))]), h('tbody', rows.map(function ($row, index) {\n    return h(Row, {\n      $row: $row\n    }, columns.map(function (node) {\n      var ref = node.data;\n      var props = ref.props;\n      var slots = ref.slots;\n      var scopedSlots = ref.scopedSlots;\n      var fnOptions = node.fnOptions;\n\n      if (false) {}\n\n      if (false) {}\n\n      return h({\n        functional: true,\n        render: fnOptions.cellRender\n      }, {\n        $row: $row,\n        props: props,\n        slots: slots,\n        scopedSlots: scopedSlots\n      });\n    }));\n  }))]);\n}\n\nfunction resolveClass(rowClass, row) {\n  return isFunction(rowClass) ? rowClass(row) : rowClass;\n}\n\nvar Table = {\n  name: 'VkTable',\n  mixins: [MixinSelect, MixinSort],\n  inheritAttrs: false,\n  props: assign({}, ElementTable.props, {\n    data: {\n      type: Array,\n      required: true\n    },\n    rowKey: {\n      type: String,\n      default: 'id'\n    },\n    rowClass: {\n      type: Function\n    }\n  }),\n  computed: {\n    rows: function rows() {\n      var this$1 = this;\n      return this.data.map(function (_row, index) {\n        var row = assign({}, _row);\n        row[ROW_ID] = row[this$1.rowKey] || index;\n        return row;\n      });\n    }\n  },\n  render: function render(h) {\n    var columns = get(this, '$slots.default', []).filter(function (n) {\n      return n.tag;\n    });\n    return Render(h, {\n      columns: columns,\n      table: this,\n      rows: this.rows,\n      props: this.$props\n    });\n  }\n};\nvar tableTree = {\n  name: 'VkTableTree',\n  extends: Table,\n  props: {\n    expandedRows: {\n      type: Array,\n      default: function () {\n        return [];\n      }\n    },\n    childrenKey: {\n      type: String,\n      default: 'children'\n    }\n  },\n  computed: {\n    rows: function rows() {\n      var this$1 = this;\n      var rows = [];\n\n      var flatten = function (data, parent) {\n        if (parent === void 0) parent = {};\n        var idCount = 0;\n        data.forEach(function (_row) {\n          var row = assign({}, _row);\n          var children = row[this$1.childrenKey];\n          var hasChildren = children && children.length;\n          row[ROW_LEVEL] = parent[ROW_LEVEL] !== undefined ? parent[ROW_LEVEL] + 1 : 0;\n          row[ROW_ID] = row[this$1.rowKey] ? row[this$1.rowKey] : row[ROW_LEVEL] === 0 ? \"\" + idCount++ : parent[ROW_ID] + \"_\" + idCount++;\n          rows.push(row);\n\n          if (hasChildren && this$1.isExpanded(row)) {\n            flatten(children, row);\n          }\n\n          if (hasChildren) {\n            row[ROW_CHILDREN_COUNT] = children.length;\n            delete row[this$1.childrenKey];\n          }\n        });\n      };\n\n      flatten(this.data);\n      return rows;\n    },\n    thereAreSubLevels: function thereAreSubLevels() {\n      return this.rows.some(function (row) {\n        return row[ROW_CHILDREN_COUNT];\n      });\n    }\n  },\n  methods: {\n    isExpanded: function isExpanded(row) {\n      return Boolean(this.expandedRows.filter(function (id) {\n        return JSON.stringify(id) === JSON.stringify(row[ROW_ID]);\n      }).length);\n    },\n    toggleExpand: function toggleExpand(row) {\n      var id = row[ROW_ID];\n      var expandedRows = [].concat(this.expandedRows);\n      var index = expandedRows.indexOf(id);\n      var isExpanded = index !== -1;\n      isExpanded ? expandedRows.splice(index, 1) : expandedRows.push(id);\n      this.$emit(UPDATE_EXPANDEDROWS, expandedRows);\n    }\n  },\n  render: function render(h) {\n    var columns = (this.$slots.default || []).filter(function (n) {\n      return n.tag;\n    });\n    return Render(h, {\n      columns: columns,\n      table: this,\n      rows: this.rows,\n      props: this.$props\n    });\n  }\n};\n\nfunction RenderCell(h, ctx, defaultContent) {\n  var props = ctx.props;\n  var data = ctx.data;\n  var $row = data.$row;\n  var cell = props.cell;\n  var cellClass = props.cellClass;\n  var cellValue = get($row, cell);\n  var isEmpty = !isUndefined(cell) && isUndefined(cellValue);\n  var scope = getCellScope(ctx);\n  var slots = getCellSlots(ctx);\n  var slot = isEmpty && slots.empty ? slots.empty : slots.default || defaultContent;\n  return h(ElementTableTd, {\n    props: props,\n    class: cellClass\n  }, [slot(scope)]);\n}\n\nfunction getCellScope(ref) {\n  var data = ref.data;\n  var props = ref.props;\n  var parent = ref.parent;\n  var $row = data.$row;\n  var cell = props.cell;\n  var cellValue = get($row, cell);\n  var selected = parent.isRowSelected($row);\n  var allSelected = parent.allRowsSelected;\n  return {\n    cell: cellValue,\n    row: $row,\n    selected: selected,\n    allSelected: allSelected\n  };\n}\n\nfunction getCellSlots(ref) {\n  var data = ref.data;\n  var defaultSlot = get(data, 'slots.default') ? function () {\n    return get(data, 'slots.default');\n  } : get(data, 'scopedSlots.default');\n  var emptySlot = get(data, 'slots.empty') ? function () {\n    return get(data, 'slots.empty');\n  } : get(data, 'scopedSlots.empty');\n  return {\n    default: defaultSlot,\n    empty: emptySlot\n  };\n}\n\nvar Column = {\n  name: 'VkTableColumn',\n  functional: true,\n  props: assign({}, ElementTableTh.props, ElementTableTd.props, {\n    cell: String,\n    title: String,\n    cellClass: String\n  }),\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var slots = ref.slots;\n    data.slots = slots();\n    return h('div', mergeData({}, data, {\n      props: props\n    }));\n  },\n  headRender: function headRender(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    return h(ElementTableTh, mergeData({}, data, {\n      props: props,\n      class: 'vk-table-column'\n    }), props.title);\n  },\n  cellRender: function cellRender(h, ctx) {\n    return RenderCell(h, ctx, function (ref) {\n      var cell = ref.cell;\n      return cell;\n    });\n  }\n};\nvar table_ColumnSort = {\n  name: 'VkTableColumnSort',\n  functional: true,\n  props: assign({}, Column.props, ElementTableThSort, {\n    cell: {\n      type: String,\n      required: true\n    }\n  }),\n  render: Column.render,\n  cellRender: Column.cellRender,\n  headRender: function headRender(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var title = props.title;\n\n    if (false) {}\n\n    return h(ElementTableThSort, mergeData(data, {\n      props: assign({\n        order: get(parent, \"sortedBy.\" + props.cell)\n      }, props),\n      on: {\n        click: function (e) {\n          var sortedBy = getNewSortOrder(parent.sortedBy, props.cell, e.shiftKey);\n          parent.$emit(UPDATE_SORTEDBY, sortedBy);\n        }\n      }\n    }), title || children);\n  }\n};\n\nfunction getNewSortOrder(currentSort, by, multi) {\n  var sort = {};\n  var order = currentSort[by] === 'asc' ? 'desc' : 'asc';\n  sort[by] = order;\n  return multi ? assign({}, currentSort, sort) : sort;\n}\n\nvar ElementCheckbox = {\n  functional: true,\n  props: ['checked'],\n  render: function render(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var listeners = ref.listeners;\n    var def = {\n      staticClass: 'uk-checkbox',\n      attrs: {\n        type: 'checkbox'\n      },\n      domProps: {\n        checked: props.checked\n      },\n      on: {\n        change: function (e) {\n          e.target.checked = props.checked;\n        }\n      }\n    };\n    return h('input', mergeData(data, def));\n  }\n};\nvar table_ColumnSelect = {\n  name: 'VkTableColumnSelect',\n  functional: true,\n  props: assign({}, ElementTableTh.props, {\n    cellClass: {\n      type: String\n    },\n    headless: {\n      type: Boolean,\n      default: false\n    },\n    shrinked: {\n      type: Boolean,\n      default: true\n    }\n  }),\n  render: Column.render,\n  headRender: function headRender(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var parent = ref.parent;\n    var content = props.headless || h('span', {\n      class: 'uk-form uk-text-center'\n    }, [h(ElementCheckbox, {\n      props: {\n        checked: parent.allRowsSelected\n      },\n      on: {\n        click: function (e) {\n          return parent.toggleRowsSelection();\n        }\n      }\n    })]);\n    return h(ElementTableTh, mergeData(data, {\n      props: {\n        shrinked: true\n      },\n      class: 'vk-table-column-select'\n    }), [content]);\n  },\n  cellRender: function cellRender(h, ctx) {\n    var parent = ctx.parent;\n    return RenderCell(h, ctx, function (ref) {\n      var row = ref.row;\n      var selected = ref.selected;\n      return h('span', {\n        class: 'uk-form uk-text-center'\n      }, [h(ElementCheckbox, {\n        props: {\n          checked: selected\n        },\n        on: {\n          click: function (e) {\n            return parent.toggleRowSelection(row);\n          }\n        }\n      })]);\n    });\n  }\n};\nvar TreeArrow = {\n  functional: true,\n  props: ['rotated'],\n  render: function (h, ref) {\n    var listeners = ref.listeners;\n    var props = ref.props;\n    return h('span', {\n      on: listeners,\n      class: ['vk-table-column-tree__arrow', {\n        'vk-table-column-tree__arrow--rotated': props.rotated\n      }]\n    });\n  }\n};\nvar TreeIndent = {\n  functional: true,\n  render: function (h, ref) {\n    var children = ref.children;\n    return h('span', {\n      class: 'vk-table-column-tree__indent'\n    }, children);\n  }\n};\nvar table_ColumnTree = {\n  name: 'VkTableTreeColumn',\n  functional: true,\n  props: assign({}, Column.props),\n  render: Column.render,\n  headRender: Column.headRender,\n  cellRender: function cellRender(h, ctx) {\n    var parent = ctx.parent;\n    return RenderCell(h, ctx, function (ref) {\n      var row = ref.row;\n      var cell = ref.cell;\n      return [Array(row[ROW_LEVEL]).fill(h(TreeIndent)), parent.thereAreSubLevels && h(TreeIndent, [row[ROW_CHILDREN_COUNT] && h(TreeArrow, {\n        props: {\n          rotated: parent.isExpanded(row)\n        },\n        on: {\n          click: function (e) {\n            e[ROW_CLICK_PREVENTED] = true;\n            parent.toggleExpand(row);\n          }\n        }\n      })]), h('span', cell)];\n    });\n  }\n};\nvar TAB_ID = '__vkTabs_id';\nvar isNotProd$1 = \"production\" !== 'production';\nvar core$2 = {\n  props: {\n    activeTab: {},\n    animation: {\n      type: String,\n      default: ''\n    },\n    keepAlive: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function (vm) {\n    return {\n      state: {\n        activeTab: vm.activeTab || filterTabs(vm).shift().data.key || 0\n      }\n    };\n  },\n  watch: {\n    activeTab: function activeTab(val) {\n      this.state.activeTab = val;\n    }\n  },\n  computed: {\n    activeTabContent: {\n      get: function get$$1() {\n        var this$1 = this;\n        return filterTabs(this).filter(function (node) {\n          return this$1.isActive(node.data[TAB_ID]);\n        })[0];\n      },\n      cache: false\n    }\n  },\n  methods: {\n    getTabs: function getTabs() {\n      var this$1 = this;\n      return filterTabs(this).filter(function (node, index) {\n        if (!node.componentOptions) {\n          isNotProd$1 && warn(\"vk-tabs -> failed to process '\" + node.tag + \"', seems is not a stateful component\", this$1);\n          return false;\n        }\n\n        node.key = get(node, 'data.key', index);\n        node.data[TAB_ID] = node.key;\n        return true;\n      });\n    },\n    setActiveTab: function setActiveTab(id) {\n      this.state.activeTab = id;\n      this.$emit('update:activeTab', id);\n    },\n    isActive: function isActive(id) {\n      return JSON.stringify(this.state.activeTab) === JSON.stringify(id);\n    }\n  }\n};\n\nfunction filterTabs(vm) {\n  return vm.$slots.default.filter(function (n) {\n    return n.tag;\n  });\n}\n\nvar ElementTabs = {\n  functional: true,\n  props: {\n    align: {\n      type: String,\n      default: 'left',\n      validator: function (val) {\n        return !val || /^(left|right|center|justify)$/.test(val);\n      }\n    },\n    flipped: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function (h, ref) {\n    var obj;\n    var children = ref.children;\n    var props = ref.props;\n    var data = ref.data;\n    var align = props.align;\n    var flipped = props.flipped;\n    return h('ul', mergeData(data, {\n      class: ['uk-tab', (obj = {\n        'uk-tab-bottom': flipped,\n        'uk-child-width-expand': align === 'justify'\n      }, obj[\"uk-flex-\" + align] = /^(right|center)$/.test(align), obj)]\n    }), children);\n  }\n};\nvar ElementTabsVertical = {\n  functional: true,\n  props: {\n    align: {\n      type: String,\n      default: 'left',\n      validator: function (val) {\n        return !val || /^(left|right)$/.test(val);\n      }\n    }\n  },\n  render: function (h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var children = ref.children;\n    var align = props.align;\n    return h('ul', mergeData(data, {\n      class: ['uk-tab', \"uk-tab-\" + align]\n    }), children);\n  }\n};\nvar ElementTabsItem = {\n  functional: true,\n  props: {\n    icon: {},\n    title: {\n      type: String,\n      required: true\n    },\n    active: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  render: function render(h, ref) {\n    var props = ref.props;\n    var data = ref.data;\n    var listeners = ref.listeners;\n    var children = ref.children;\n    var active = props.active;\n    var disabled = props.disabled;\n    var title = props.title;\n    var icon$$1 = props.icon;\n    delete data.on;\n    return h('li', mergeData(data, {\n      class: {\n        'uk-active': active && !disabled,\n        'uk-disabled': disabled\n      }\n    }), [h('a', {\n      on: listeners\n    }, [title, icon$$1 && h(ElementIcon, {\n      class: 'uk-margin-small-left'\n    }, [icon$$1])]), children]);\n  }\n};\nvar tabs = {\n  name: 'VkTabs',\n  extends: core$2,\n  mixins: [EventsMixin],\n  props: ElementTabs.props,\n  render: function render(h) {\n    var this$1 = this;\n    var ref = this;\n    var flipped = ref.flipped;\n    var animation = ref.animation;\n    var keepAlive = ref.keepAlive;\n    var $props = ref.$props;\n    var Tabs = this.getTabs();\n    Tabs = Tabs.map(function (node, index) {\n      var obj;\n      var Tab = {\n        functional: true,\n        render: node.componentOptions.Ctor.options.tabRender\n      };\n      return h(Tab, (obj = {}, obj[TAB_ID] = node.data[TAB_ID], obj.props = assign({}, node.componentOptions.propsData, {\n        active: this$1.isActive(node.data[TAB_ID])\n      }), obj));\n    });\n    return h('div', {\n      class: {\n        'uk-flex uk-flex-column-reverse': flipped\n      }\n    }, [h(ElementTabs, {\n      props: $props\n    }, Tabs), h('div', {\n      class: {\n        'uk-margin': flipped\n      }\n    }, [h(Transition$1, {\n      props: {\n        name: animation\n      }\n    }, [keepAlive ? h('keep-alive', [this.activeTabContent]) : this.activeTabContent])])]);\n  }\n};\nvar tabsVertical = {\n  name: 'VkTabsVertical',\n  extends: core$2,\n  props: ElementTabsVertical.props,\n  render: function render(h) {\n    var this$1 = this;\n    var ref = this;\n    var align = ref.align;\n    var animation = ref.animation;\n    var keepAlive = ref.keepAlive;\n    var $props = ref.$props;\n    var Tabs = this.getTabs().map(function (node, index) {\n      var obj;\n      var Tab = {\n        functional: true,\n        render: node.componentOptions.Ctor.options.tabRender\n      };\n      return h(Tab, (obj = {}, obj[TAB_ID] = node.data[TAB_ID], obj.props = assign({}, node.componentOptions.propsData, {\n        active: this$1.isActive(node.data[TAB_ID])\n      }), obj));\n    });\n    return h('div', {\n      class: ['uk-grid', {\n        'uk-flex uk-flex-row-reverse': align === 'right'\n      }]\n    }, [h('div', {\n      class: 'uk-width-auto'\n    }, [h(ElementTabsVertical, {\n      props: $props\n    }, Tabs)]), h('div', {\n      class: 'uk-width-expand'\n    }, [h(Transition$1, {\n      props: {\n        name: animation\n      }\n    }, [keepAlive ? h('keep-alive', [this.activeTabContent]) : this.activeTabContent])])]);\n  }\n};\nvar tabs_Item = {\n  name: 'VkTabsItem',\n  props: assign({}, ElementTabsItem.props, {\n    icon: {\n      type: String\n    }\n  }),\n  render: function render(h) {\n    return h('div', this.$slots.default);\n  },\n  tabRender: function tabRender(h, ref) {\n    var data = ref.data;\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    props.icon = props.icon && h(\"vk-icons-\" + props.icon);\n    return h(ElementTabsItem, mergeData(data, {\n      props: props,\n      on: {\n        click: function (e) {\n          e.preventDefault();\n          parent.setActiveTab(data[TAB_ID]);\n        }\n      }\n    }), children);\n  }\n};\nvar components =\n/*#__PURE__*/\nObject.freeze({\n  Breadcrumb: breadcrumb,\n  BreadcrumbItem: breadcrumb_Item,\n  Button: button,\n  ButtonLink: buttonLink,\n  ButtonGroup: buttonGroup,\n  Card: card,\n  CardTitle: card_Title,\n  Drop: Drop,\n  Dropdown: Dropdown,\n  Grid: Grid,\n  Icon: icon,\n  IconLink: iconLink,\n  IconButton: iconButton,\n  IconImage: iconImage,\n  Iconnav: iconnav,\n  IconnavVertical: iconnavVertical,\n  IconnavItem: iconnav_Item,\n  Label: label,\n  Modal: modal,\n  ModalFull: modalFull,\n  ModalClose: modal_Close,\n  ModalFullClose: modalFull_Close,\n  ModalTitle: modal_Title,\n  Nav: nav$1,\n  NavDropdown: navDropdown,\n  NavItem: nav_Item,\n  NavItemDivider: nav_ItemDivider,\n  NavItemHeader: nav_ItemHeader,\n  NavItemParent: nav_ItemParent,\n  Navbar: navbar,\n  NavbarFull: navbarFull,\n  NavbarDropbar: navbarDropbar,\n  NavbarItem: navbar_Item,\n  NavbarLogo: navbar_Logo,\n  NavbarToggle: navbar_Toggle,\n  NavbarNav: navbar_Nav,\n  NavbarNavItem: navbar_Nav_Item,\n  NavbarNavDropdown: navbar_Nav_Dropdown,\n  NavbarNavDropdownNav: navbar_Nav_Dropdown_Nav,\n  Notification: notification,\n  Offcanvas: offcanvas,\n  OffcanvasContent: offcanvasContent,\n  OffcanvasBar: offcanvas_Bar,\n  OffcanvasClose: offcanvas_Close,\n  Pagination: pagination,\n  PaginationPages: pagination_Pages,\n  PaginationPageFirst: pagination_PageFirst,\n  PaginationPagePrev: pagination_PagePrev,\n  PaginationPageNext: pagination_PageNext,\n  PaginationPageLast: pagination_PageLast,\n  Scrollspy: scrollspy,\n  ScrollspyNav: scrollspyNav,\n  SkeletonImage: skeletonImage,\n  SkeletonText: skeletonText,\n  SkeletonTitle: skeletonTitle,\n  Spinner: spinner,\n  Sticky: sticky,\n  Subnav: subnav,\n  SubnavItem: subnav_Item,\n  SubnavItemDropdown: subnav_ItemDropdown,\n  Table: Table,\n  TableTree: tableTree,\n  TableColumn: Column,\n  TableColumnSort: table_ColumnSort,\n  TableColumnSelect: table_ColumnSelect,\n  TableColumnTree: table_ColumnTree,\n  Tabs: tabs,\n  TabsVertical: tabsVertical,\n  TabsItem: tabs_Item\n});\nvar NAMESPACE$3 = '__vkScroll';\nvar index$1 = {\n  bind: function bind$$1(el, binding, vnode) {\n    el[NAMESPACE$3] = {};\n  },\n  inserted: function inserted(el, binding, vnode) {\n    el[NAMESPACE$3].options = getOptions$3({\n      binding: binding,\n      vnode: vnode\n    });\n    el[NAMESPACE$3].unbind = on(el, 'click', function (e) {\n      var opts = el[NAMESPACE$3].options;\n      var isAnchor = e.target.nodeName === 'A';\n\n      if (!isAnchor || e.defaultPrevented && !opts.force) {\n        return;\n      }\n\n      if (e.target === el || matches$1(el, e.target, opts.target)) {\n        e.preventDefault();\n        scrollTo(el, e.target, escape(e.target.hash).substr(1), opts);\n      }\n    });\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    el[NAMESPACE$3].options = getOptions$3({\n      binding: binding,\n      vnode: vnode\n    });\n  },\n  unbind: function unbind(el) {\n    if (!el[NAMESPACE$3]) {\n      return;\n    }\n\n    el[NAMESPACE$3].unbind();\n    delete el[NAMESPACE$3];\n  }\n};\n\nfunction scrollTo(el, fromEl, toEl, options) {\n  toEl = toEl && $(toEl) || document.body;\n  var docHeight = height(document);\n  var winHeight = height(window);\n  var target = offset(toEl).top - options.offset;\n\n  if (target + winHeight > docHeight) {\n    target = docHeight - winHeight;\n  }\n\n  if (!trigger(el, 'beforeScroll', {\n    from: fromEl,\n    to: toEl\n  })) {\n    return;\n  }\n\n  var start = Date.now();\n  var startY = window.pageYOffset;\n\n  var step = function () {\n    var currentY = startY + (target - startY) * ease(clamp((Date.now() - start) / options.duration));\n    window.scrollTo(window.pageXOffset, currentY);\n\n    if (currentY !== target) {\n      requestAnimationFrame(step);\n    } else {\n      trigger(el, 'afterScroll', {\n        from: fromEl,\n        to: toEl\n      });\n    }\n  };\n\n  step();\n}\n\nfunction ease(k) {\n  return 0.5 * (1 - Math.cos(Math.PI * k));\n}\n\nfunction getOptions$3(ctx) {\n  var ref = ctx.binding;\n  var value = ref.value;\n  var modifiers = ref.modifiers;\n\n  if (isString(value)) {\n    value = {\n      target: value\n    };\n  }\n\n  return assign({\n    offset: 0,\n    target: 'a',\n    force: false,\n    duration: 1000\n  }, modifiers, value);\n}\n\nfunction matches$1(el, target, selector) {\n  var matches$$1 = $$(\"\" + selector, el);\n  var i = matches$$1.length;\n\n  while (--i >= 0 && matches$$1[i] !== target) {}\n\n  return i > -1;\n}\n\nvar NAMESPACE$4 = '__vkTooltip';\nvar index$2 = {\n  bind: function bind$$1(el, binding, vnode) {\n    el[NAMESPACE$4] = {\n      vnode: vnode,\n      state: null,\n      options: getOptions$4({\n        binding: binding\n      })\n    };\n\n    if (hasAttr(el, 'title')) {\n      el[NAMESPACE$4].attrTitle = attr(el, 'title');\n      attr(el, {\n        title: ''\n      });\n    }\n\n    el[NAMESPACE$4].title = el[NAMESPACE$4].options.title || el[NAMESPACE$4].attrTitle;\n  },\n  inserted: function inserted(el, binding, vnode) {\n    bindEvents(el);\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    el[NAMESPACE$4].options = getOptions$4({\n      binding: binding\n    });\n    el[NAMESPACE$4].title = el[NAMESPACE$4].options.title || el[NAMESPACE$4].attrTitle;\n  },\n  unbind: function unbind(el, binding, vnode) {\n    if (!el[NAMESPACE$4]) {\n      return;\n    }\n\n    _hide(el);\n\n    attr(el, {\n      title: el[NAMESPACE$4].attrTitle || null\n    });\n    el[NAMESPACE$4].unbindEvents();\n    delete el[NAMESPACE$4];\n  }\n};\n\nfunction bindEvents(el) {\n  var events = [on(el, \"focus \" + pointerEnter + \" \" + pointerDown, function (e) {\n    if (e.type !== pointerDown || !isTouch(e)) {\n      show(el);\n    }\n  }), on(el, 'blur', function (e) {\n    return hide(el);\n  }), on(el, pointerLeave, function (e) {\n    if (!isTouch(e)) {\n      hide(el);\n    }\n  })];\n\n  el[NAMESPACE$4].unbindEvents = function () {\n    return events.forEach(function (unbind) {\n      return unbind();\n    });\n  };\n}\n\nfunction toggleIn(el) {\n  var ref = el[NAMESPACE$4].options;\n  var cls = ref.cls;\n  var position$$1 = ref.position;\n  var animation = ref.animation;\n  var duration = ref.duration;\n\n  if (!trigger(el, 'beforeShow')) {\n    return Promise.reject();\n  }\n\n  var origin = el[NAMESPACE$4].origin = getOrigin(position$$1);\n  var tooltip = el[NAMESPACE$4].tooltip = createTooltip(el);\n  positionTooltip(el);\n  addClass(tooltip, cls);\n  el[NAMESPACE$4].hideTimer = setInterval(function () {\n    if (!isVisible(el)) {\n      hide(el);\n    }\n  }, 150);\n  el[NAMESPACE$4].state = 'in';\n  trigger(el, 'show');\n  return Animation.in(tooltip, \"uk-animation-\" + animation[0], duration, origin).then(function () {\n    el[NAMESPACE$4].state = 'active';\n    trigger(el, 'shown');\n  }).catch(function () {});\n}\n\nfunction toggleOut(el) {\n  var ref = el[NAMESPACE$4];\n  var tooltip = ref.tooltip;\n  var ref$1 = el[NAMESPACE$4].options;\n  var animation = ref$1.animation;\n  var duration = ref$1.duration;\n\n  if (!trigger(el, 'beforeHide')) {\n    return Promise.reject();\n  }\n\n  Animation.cancel(tooltip);\n  el[NAMESPACE$4].state = 'out';\n  trigger(el, 'hide');\n\n  if (!animation[1]) {\n    return Promise.resolve().then(function () {\n      return _hide(el);\n    });\n  }\n\n  return Animation.out(tooltip, \"uk-animation-\" + animation[1], duration, origin).then(function () {\n    return _hide(el);\n  }).catch(function () {});\n}\n\nfunction show(el) {\n  var ref = el[NAMESPACE$4].options;\n  var delay = ref.delay;\n  var ref$1 = el[NAMESPACE$4];\n  var state = ref$1.state;\n  var title = ref$1.title;\n\n  if (!title || state === 'active' || el[NAMESPACE$4].showTimer) {\n    return;\n  }\n\n  if (state === 'out') {\n    Animation.cancel(el);\n\n    _hide(el);\n  }\n\n  el[NAMESPACE$4].showTimer = setTimeout(function () {\n    return toggleIn(el);\n  }, delay);\n}\n\nfunction hide(el) {\n  if (!el[NAMESPACE$4]) {\n    return;\n  }\n\n  var ref = el[NAMESPACE$4];\n  var state = ref.state;\n  clearAllTimers(el);\n\n  if (state === 'out' || matches(el, 'input') && isFocused(el)) {\n    return;\n  }\n\n  toggleOut(el);\n}\n\nfunction _hide(el) {\n  if (!el[NAMESPACE$4]) {\n    return;\n  }\n\n  var ref = el[NAMESPACE$4];\n  var tooltip = ref.tooltip;\n  var ref$1 = el[NAMESPACE$4].options;\n  var cls = ref$1.cls;\n  attr(el, 'aria-expanded', false);\n  removeClass(tooltip, cls);\n  tooltip && remove(tooltip);\n  el[NAMESPACE$4].state = null;\n  el[NAMESPACE$4].tooltip = null;\n  trigger(el, 'hidden');\n}\n\nfunction clearAllTimers(el) {\n  clearTimeout(el[NAMESPACE$4].showTimer);\n  clearTimeout(el[NAMESPACE$4].hideTimer);\n  el[NAMESPACE$4].showTimer = null;\n  el[NAMESPACE$4].hideTimer = null;\n}\n\nfunction positionTooltip(el) {\n  var target = el;\n  var ref = el[NAMESPACE$4];\n  var tooltip = ref.tooltip;\n  var ref$1 = el[NAMESPACE$4].options;\n  var clsPos = ref$1.clsPos;\n  var position$$1 = ref$1.position;\n  var ref$2 = el[NAMESPACE$4].options;\n  var offset$$1 = ref$2.offset;\n  var node;\n  var ref$3 = position$$1.split('-');\n  var dir = ref$3[0];\n  var align = ref$3[1];\n  if (align === void 0) align = 'center';\n  removeClasses(tooltip, clsPos + \"-(top|bottom|left|right)(-[a-z]+)?\");\n  css(tooltip, {\n    top: '',\n    left: ''\n  });\n  var axis = getAxis$1(position$$1);\n  offset$$1 = isNumeric(offset$$1) ? offset$$1 : (node = $(offset$$1)) ? offset(node)[axis === 'x' ? 'left' : 'top'] - offset(target)[axis === 'x' ? 'right' : 'bottom'] : 0;\n  var elAttach = axis === 'x' ? flipPosition(dir) + \" \" + align : align + \" \" + flipPosition(dir);\n  var targetAttach = axis === 'x' ? dir + \" \" + align : align + \" \" + dir;\n  var elOffset = axis === 'x' ? \"\" + (dir === 'left' ? -1 * offset$$1 : offset$$1) : \"\" + (dir === 'top' ? -1 * offset$$1 : offset$$1);\n  var targetOffset = null;\n  var ref$4 = positionAt(tooltip, target, elAttach, targetAttach, elOffset, targetOffset, true).target;\n  var x = ref$4.x;\n  var y = ref$4.y;\n  dir = axis === 'x' ? x : y;\n  align = axis === 'x' ? y : x;\n  toggleClass(tooltip, clsPos + \"-\" + dir + \"-\" + align, el[NAMESPACE$4].options.offset === false);\n  return {\n    dir: dir,\n    align: align\n  };\n}\n\nfunction getOptions$4(ctx) {\n  var ref = ctx.binding;\n  var value = ref.value;\n  var modifiers = ref.modifiers;\n\n  if (isString(value)) {\n    value = {\n      title: value\n    };\n  }\n\n  if (Object.keys(modifiers).length) {\n    var firstKey = Object.keys(modifiers)[0];\n    modifiers = {\n      position: firstKey\n    };\n  }\n\n  var options = assign({\n    delay: 0,\n    title: '',\n    offset: false,\n    duration: 100,\n    position: 'top',\n    container: true,\n    cls: 'uk-active',\n    clsPos: 'uk-tooltip',\n    animation: 'scale-up'\n  }, modifiers, value);\n  options.position = hyphenate(options.position);\n  options.animation = options.animation.split(' ');\n\n  if (false) { var pos; }\n\n  return options;\n}\n\nfunction getAxis$1(position$$1) {\n  var ref = position$$1.split('-');\n  var dir = ref[0];\n  return dir === 'top' || dir === 'bottom' ? 'y' : 'x';\n}\n\nfunction getContainer(el) {\n  var ref = el[NAMESPACE$4];\n  var vnode = ref.vnode;\n  var ref$1 = el[NAMESPACE$4].options;\n  var container = ref$1.container;\n  return container === true && vnode.context.$root.$el || container && $(container);\n}\n\nfunction createTooltip(el) {\n  var ref = el[NAMESPACE$4];\n  var title = ref.title;\n  var ref$1 = el[NAMESPACE$4].options;\n  var clsPos = ref$1.clsPos;\n  return append(getContainer(el), \"<div class=\\\"\" + clsPos + \"\\\" aria-hidden>\\n    <div class=\\\"\" + clsPos + \"-inner\\\">\" + title + \"</div>\\n  </div>\");\n}\n\nfunction getOrigin(position$$1) {\n  var dir = position$$1[0];\n  var align = position$$1[1];\n  return getAxis$1(position$$1) === 'y' ? flipPosition(dir) + \"-\" + align : align + \"-\" + flipPosition(dir);\n}\n\nfunction isFocused(el) {\n  return el === document.activeElement;\n}\n\nvar NAMESPACE$5 = '__vkHeightMatch';\nvar index$3 = {\n  bind: function bind$$1(el, binding, vnode) {\n    el[NAMESPACE$5] = {};\n  },\n  inserted: function inserted(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      return update$3(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n    el[NAMESPACE$5].unbind = on(window, 'resize', function () {\n      return update$3(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    vnode.context.$nextTick(function () {\n      return update$3(el, {\n        binding: binding,\n        vnode: vnode\n      });\n    });\n  },\n  unbind: function unbind(el) {\n    if (!el[NAMESPACE$5]) {\n      return;\n    }\n\n    el[NAMESPACE$5].unbind();\n    delete el[NAMESPACE$5];\n  }\n};\n\nfunction update$3(el, ctx) {\n  var opts = getOptions$5(ctx);\n  var elements = $$(opts.target, el);\n  css(elements, 'minHeight', '');\n  var rows = getRows$1(elements, opts.row);\n  rows.forEach(function (els) {\n    var ref = match(els);\n    var height = ref.height;\n    var elements = ref.elements;\n    css(elements, 'minHeight', height);\n  });\n}\n\nfunction getOptions$5(ctx) {\n  var ref = ctx.binding;\n  var value = ref.value;\n\n  if (isString(value)) {\n    value = {\n      target: value\n    };\n  }\n\n  return assign({\n    target: '> *',\n    row: true\n  }, value);\n}\n\nfunction getRows$1(elements, row) {\n  if (!row) {\n    return [elements];\n  }\n\n  var lastOffset = false;\n  return elements.reduce(function (rows, el) {\n    if (lastOffset !== el.offsetTop) {\n      rows.push([el]);\n    } else {\n      rows[rows.length - 1].push(el);\n    }\n\n    lastOffset = el.offsetTop;\n    return rows;\n  }, []);\n}\n\nfunction match(elements) {\n  if (elements.length < 2) {\n    return {};\n  }\n\n  var max = 0;\n  var heights = [];\n  elements.forEach(function (el) {\n    var style;\n    var hidden;\n\n    if (!isVisible(el)) {\n      style = attr(el, 'style');\n      hidden = attr(el, 'hidden');\n      attr(el, {\n        style: (style || '') + \";display:block !important;\",\n        hidden: null\n      });\n    }\n\n    max = Math.max(max, el.offsetHeight);\n    heights.push(el.offsetHeight);\n\n    if (!isUndefined(style)) {\n      attr(el, {\n        style: style,\n        hidden: hidden\n      });\n    }\n  });\n  elements = elements.filter(function (el, i) {\n    return heights[i] < max;\n  });\n  return {\n    height: max,\n    elements: elements\n  };\n}\n\nvar directives =\n/*#__PURE__*/\nObject.freeze({\n  Margin: VkMargin,\n  Scroll: index$1,\n  Tooltip: index$2,\n  HeightMatch: index$3,\n  HeightViewport: VkHeightViewport\n});\nvar Vuikit = {\n  components: components,\n  directives: directives,\n  install: function install(Vue) {\n    each(components, function (def, name) {\n      Vue.component(\"Vk\" + name, def);\n    });\n    each(directives, function (def, name) {\n      Vue.directive(\"Vk\" + name, def);\n    });\n  }\n};\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vuikit);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVpa2l0L2Rpc3QvdnVpa2l0LmVzbS5qcz82ZDY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVnVpa2l0IDAuOC4xMFxuICogKGMpIDIwMTggTWlsamFuIEFsZWtzaWNcbiAqIEBsaWNlbnNlIE1JVFxuKiovXG5cbi8qIFN1YnN0YW50aWFsIHBhcnQgb2YgdGhlIGNvZGUgaXMgYWRhcHRlZCBmcm9tIFVJa2l0LFxuICBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxOCBZT090aGVtZSBHbWJILCBnZXR1aWtpdC5jb20gKi9cblxudmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxudmFyIGh5cGhlbmF0ZVJlID0gLyhbYS16XFxkXSkoW0EtWl0pL2c7XG5mdW5jdGlvbiBoeXBoZW5hdGUgKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUmUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn1cbmZ1bmN0aW9uIHRvVXBwZXIgKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJ1xufVxuZnVuY3Rpb24gdWNmaXJzdCAoc3RyKSB7XG4gIHJldHVybiBzdHIubGVuZ3RoID8gdG9VcHBlcihudWxsLCBzdHIuY2hhckF0KDApKSArIHN0ci5zbGljZSgxKSA6ICcnXG59XG52YXIgc3RyUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBzdGFydHNXaXRoRm4gPSBzdHJQcm90b3R5cGUuc3RhcnRzV2l0aCB8fCBmdW5jdGlvbiAoc2VhcmNoKSB7IHJldHVybiB0aGlzLmxhc3RJbmRleE9mKHNlYXJjaCwgMCkgPT09IDAgfTtcbmZ1bmN0aW9uIHN0YXJ0c1dpdGggKHN0ciwgc2VhcmNoKSB7XG4gIHJldHVybiBzdGFydHNXaXRoRm4uY2FsbChzdHIsIHNlYXJjaClcbn1cbnZhciBlbmRzV2l0aEZuID0gc3RyUHJvdG90eXBlLmVuZHNXaXRoIHx8IGZ1bmN0aW9uIChzZWFyY2gpIHsgcmV0dXJuIHRoaXMuc3Vic3RyKC1zZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoIH07XG5mdW5jdGlvbiBlbmRzV2l0aCAoc3RyLCBzZWFyY2gpIHtcbiAgcmV0dXJuIGVuZHNXaXRoRm4uY2FsbChzdHIsIHNlYXJjaClcbn1cbnZhciBpbmNsdWRlc0ZuID0gZnVuY3Rpb24gKHNlYXJjaCkgeyByZXR1cm4gfnRoaXMuaW5kZXhPZihzZWFyY2gpIH07XG52YXIgaW5jbHVkZXNTdHIgPSBzdHJQcm90b3R5cGUuaW5jbHVkZXMgfHwgaW5jbHVkZXNGbjtcbnZhciBpbmNsdWRlc0FycmF5ID0gQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzIHx8IGluY2x1ZGVzRm47XG5mdW5jdGlvbiBpbmNsdWRlcyAob2JqLCBzZWFyY2gpIHtcbiAgcmV0dXJuIG9iaiAmJiAoaXNTdHJpbmcob2JqKSA/IGluY2x1ZGVzU3RyIDogaW5jbHVkZXNBcnJheSkuY2FsbChvYmosIHNlYXJjaClcbn1cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJ1xufVxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGVcbn1cbmZ1bmN0aW9uIGlzV2luZG93IChvYmopIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgb2JqID09PSBvYmoud2luZG93XG59XG5mdW5jdGlvbiBpc0RvY3VtZW50IChvYmopIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgb2JqLm5vZGVUeXBlID09PSA5XG59XG5mdW5jdGlvbiBpc0pRdWVyeSAob2JqKSB7XG4gIHJldHVybiBpc09iamVjdChvYmopICYmICEhb2JqLmpxdWVyeVxufVxuZnVuY3Rpb24gaXNOb2RlIChlbGVtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgTm9kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUgfHwgaXNPYmplY3QoZWxlbWVudCkgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMVxufVxuZnVuY3Rpb24gaXNOb2RlQ29sbGVjdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gdHlwZW9mIE5vZGVMaXN0ICE9PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50IGluc3RhbmNlb2YgTm9kZUxpc3QgfHxcbiAgICB0eXBlb2YgSFRNTENvbGxlY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvblxufVxuZnVuY3Rpb24gaXNTdHJpbmcgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG5mdW5jdGlvbiBpc051bWJlciAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYyAodmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSB8fCBpc1N0cmluZyh2YWx1ZSkgJiYgIWlzTmFOKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkpXG59XG5mdW5jdGlvbiBpc1VuZGVmaW5lZCAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDBcbn1cbmZ1bmN0aW9uIHRvRmxvYXQgKHZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwXG59XG5mdW5jdGlvbiB0b05vZGUgKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzTm9kZShlbGVtZW50KSB8fCBpc1dpbmRvdyhlbGVtZW50KSB8fCBpc0RvY3VtZW50KGVsZW1lbnQpXG4gICAgPyBlbGVtZW50XG4gICAgOiBpc05vZGVDb2xsZWN0aW9uKGVsZW1lbnQpIHx8IGlzSlF1ZXJ5KGVsZW1lbnQpXG4gICAgICA/IGVsZW1lbnRbMF1cbiAgICAgIDogaXNBcnJheShlbGVtZW50KVxuICAgICAgICA/IHRvTm9kZShlbGVtZW50WzBdKVxuICAgICAgICA6IG51bGxcbn1cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuZnVuY3Rpb24gdG9Ob2RlcyAoZWxlbWVudCkge1xuICByZXR1cm4gaXNOb2RlKGVsZW1lbnQpXG4gICAgPyBbZWxlbWVudF1cbiAgICA6IGlzTm9kZUNvbGxlY3Rpb24oZWxlbWVudClcbiAgICAgID8gYXJyYXlQcm90by5zbGljZS5jYWxsKGVsZW1lbnQpXG4gICAgICA6IGlzQXJyYXkoZWxlbWVudClcbiAgICAgICAgPyBlbGVtZW50Lm1hcCh0b05vZGUpLmZpbHRlcihCb29sZWFuKVxuICAgICAgICA6IGlzSlF1ZXJ5KGVsZW1lbnQpXG4gICAgICAgICAgPyBlbGVtZW50LnRvQXJyYXkoKVxuICAgICAgICAgIDogW11cbn1cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcbiAgdGFyZ2V0ID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmdzW2ldO1xuICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093bihzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRcbn07XG5mdW5jdGlvbiBlYWNoIChvYmosIGNiKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoY2IuY2FsbChvYmpba2V5XSwgb2JqW2tleV0sIGtleSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xhbXAgKG51bWJlciwgbWluLCBtYXgpIHtcbiAgaWYgKCBtaW4gPT09IHZvaWQgMCApIG1pbiA9IDA7XG4gIGlmICggbWF4ID09PSB2b2lkIDAgKSBtYXggPSAxO1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtYmVyLCBtaW4pLCBtYXgpXG59XG5mdW5jdGlvbiBub29wICgpIHt9XG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0IChyMSwgcjIpIHtcbiAgcmV0dXJuIHIxLmxlZnQgPD0gcjIucmlnaHQgJiZcbiAgICAgICAgcjIubGVmdCA8PSByMS5yaWdodCAmJlxuICAgICAgICByMS50b3AgPD0gcjIuYm90dG9tICYmXG4gICAgICAgIHIyLnRvcCA8PSByMS5ib3R0b21cbn1cblxuZnVuY3Rpb24gYXR0ciAoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgIGF0dHIoZWxlbWVudCwga2V5LCBuYW1lW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKVxuICB9IGVsc2Uge1xuICAgIHRvTm9kZXMoZWxlbWVudCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChlbGVtZW50LCBhdHRyKGVsZW1lbnQsIG5hbWUpKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVBdHRyKGVsZW1lbnQsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBoYXNBdHRyIChlbGVtZW50LCBuYW1lKSB7XG4gIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKG5hbWUpOyB9KVxufVxuZnVuY3Rpb24gcmVtb3ZlQXR0ciAoZWxlbWVudCwgbmFtZSkge1xuICBlbGVtZW50ID0gdG9Ob2RlcyhlbGVtZW50KTtcbiAgbmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7IH1cbiAgICApOyB9XG4gICk7XG59XG5mdW5jdGlvbiBmaWx0ZXJBdHRyIChlbGVtZW50LCBhdHRyaWJ1dGUsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG4gIGF0dHIoZWxlbWVudCwgYXR0cmlidXRlLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID8gdmFsdWUucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCkgOiB2YWx1ZTsgfSk7XG59XG5mdW5jdGlvbiBkYXRhIChlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGF0dHJzID0gW2F0dHJpYnV0ZSwgKFwiZGF0YS1cIiArIGF0dHJpYnV0ZSldOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQXR0cihlbGVtZW50LCBhdHRyc1tpXSkpIHtcbiAgICAgIHJldHVybiBhdHRyKGVsZW1lbnQsIGF0dHJzW2ldKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBxdWVyeSAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRvTm9kZShzZWxlY3RvcikgfHwgZmluZChzZWxlY3RvciwgaXNDb250ZXh0U2VsZWN0b3Ioc2VsZWN0b3IpID8gY29udGV4dCA6IGRvY3VtZW50KVxufVxuZnVuY3Rpb24gZmluZCAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRvTm9kZShfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsICdxdWVyeVNlbGVjdG9yJykpXG59XG5mdW5jdGlvbiBmaW5kQWxsIChzZWxlY3RvciwgY29udGV4dCkge1xuICByZXR1cm4gdG9Ob2RlcyhfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsICdxdWVyeVNlbGVjdG9yQWxsJykpXG59XG5mdW5jdGlvbiBfcXVlcnkgKHNlbGVjdG9yLCBjb250ZXh0LCBxdWVyeUZuKSB7XG4gIGlmICggY29udGV4dCA9PT0gdm9pZCAwICkgY29udGV4dCA9IGRvY3VtZW50O1xuICBpZiAoIXNlbGVjdG9yIHx8ICFpc1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShjb250ZXh0U2FuaXRpemVSZSwgJyQxIConKTtcbiAgdmFyIHJlbW92ZXM7XG4gIGlmIChpc0NvbnRleHRTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICByZW1vdmVzID0gW107XG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IsIGkpIHtcbiAgICAgIHZhciBjdHggPSBjb250ZXh0O1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKCk7XG4gICAgICBpZiAoc2VsZWN0b3JbMF0gPT09ICchJykge1xuICAgICAgICB2YXIgc2VsZWN0b3JzID0gc2VsZWN0b3Iuc3Vic3RyKDEpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICBjdHggPSBjbG9zZXN0KGNvbnRleHQucGFyZW50Tm9kZSwgc2VsZWN0b3JzWzBdKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnMuc2xpY2UoMSkuam9pbignICcpO1xuICAgICAgfVxuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGlmICghY3R4LmlkKSB7XG4gICAgICAgIGN0eC5pZCA9IFwidWstXCIgKyAoRGF0ZS5ub3coKSkgKyBpO1xuICAgICAgICByZW1vdmVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlQXR0cihjdHgsICdpZCcpOyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCIjXCIgKyAoZXNjYXBlKGN0eC5pZCkpICsgXCIgXCIgKyBzZWxlY3RvcilcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbignLCcpO1xuICAgIGNvbnRleHQgPSBkb2N1bWVudDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBjb250ZXh0W3F1ZXJ5Rm5dKHNlbGVjdG9yKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBmaW5hbGx5IHtcbiAgICByZW1vdmVzICYmIHJlbW92ZXMuZm9yRWFjaChmdW5jdGlvbiAocmVtb3ZlKSB7IHJldHVybiByZW1vdmUoKTsgfSk7XG4gIH1cbn1cbnZhciBjb250ZXh0U2VsZWN0b3JSZSA9IC8oXnwsKVxccypbIT4rfl0vO1xudmFyIGNvbnRleHRTYW5pdGl6ZVJlID0gLyhbIT4rfl0pKD89XFxzK1shPit+XXxcXHMqJCkvZztcbmZ1bmN0aW9uIGlzQ29udGV4dFNlbGVjdG9yIChzZWxlY3Rvcikge1xuICByZXR1cm4gaXNTdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKGNvbnRleHRTZWxlY3RvclJlKVxufVxuZnVuY3Rpb24gbWF0Y2hlcyAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgdmFyIGVsUHJvdG8gPSB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGU7XG4gIHZhciBtYXRjaGVzRm4gPSBlbFByb3RvLm1hdGNoZXMgfHwgZWxQcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWxQcm90by5tc01hdGNoZXNTZWxlY3RvcjtcbiAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZShmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gbWF0Y2hlc0ZuLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpOyB9KVxufVxuZnVuY3Rpb24gY2xvc2VzdCAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgdmFyIGVsUHJvdG8gPSB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGU7XG4gIHZhciBjbG9zZXN0Rm4gPSBlbFByb3RvLmNsb3Nlc3QgfHwgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGFuY2VzdG9yID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAobWF0Y2hlcyhhbmNlc3Rvciwgc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvclxuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGFuY2VzdG9yICYmIGFuY2VzdG9yLm5vZGVUeXBlID09PSAxKVxuICB9O1xuICBpZiAoc3RhcnRzV2l0aChzZWxlY3RvciwgJz4nKSkge1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZShlbGVtZW50KVxuICAgID8gZWxlbWVudC5wYXJlbnROb2RlICYmIGNsb3Nlc3RGbi5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKVxuICAgIDogdG9Ob2RlcyhlbGVtZW50KS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBjbG9zZXN0Rm4uY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7IH0pLmZpbHRlcihCb29sZWFuKVxufVxuZnVuY3Rpb24gZXNjYXBlIChjc3MpIHtcbiAgdmFyIGVzY2FwZUZuID0gd2luZG93LkNTUyAmJiBDU1MuZXNjYXBlIHx8IGZ1bmN0aW9uIChjc3MpIHsgcmV0dXJuIGNzcy5yZXBsYWNlKC8oW15cXHg3Zi1cXHVGRkZGXFx3LV0pL2csIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gKFwiXFxcXFwiICsgbWF0Y2gpOyB9KSB9O1xuICByZXR1cm4gaXNTdHJpbmcoY3NzKSA/IGVzY2FwZUZuLmNhbGwobnVsbCwgY3NzKSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVmlzaWJsZSAoZWxlbWVudCkge1xuICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDsgfSlcbn1cbmZ1bmN0aW9uIGZpbHRlciAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKTsgfSlcbn1cbmZ1bmN0aW9uIHdpdGhpbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuICFpc1N0cmluZyhzZWxlY3RvcilcbiAgICA/IGVsZW1lbnQgPT09IHNlbGVjdG9yIHx8IChpc0RvY3VtZW50KHNlbGVjdG9yKVxuICAgICAgPyBzZWxlY3Rvci5kb2N1bWVudEVsZW1lbnRcbiAgICAgIDogdG9Ob2RlKHNlbGVjdG9yKSkuY29udGFpbnModG9Ob2RlKGVsZW1lbnQpKVxuICAgIDogbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikgfHwgY2xvc2VzdChlbGVtZW50LCBzZWxlY3Rvcilcbn1cblxuZnVuY3Rpb24gb24gKCkge1xuICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuICB2YXIgcmVmID0gZ2V0QXJncyhhcmdzKTtcbiAgdmFyIHRhcmdldCA9IHJlZlswXTtcbiAgdmFyIHR5cGUgPSByZWZbMV07XG4gIHZhciBzZWxlY3RvciA9IHJlZlsyXTtcbiAgdmFyIGxpc3RlbmVyID0gcmVmWzNdO1xuICB2YXIgdXNlQ2FwdHVyZSA9IHJlZls0XTtcbiAgdGFyZ2V0ID0gdG9FdmVudFRhcmdldCh0YXJnZXQpO1xuICBpZiAoc2VsZWN0b3IpIHtcbiAgICBsaXN0ZW5lciA9IGRlbGVnYXRlKHRhcmdldCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgfVxuICBpZiAobGlzdGVuZXIubGVuZ3RoID4gMSkge1xuICAgIGxpc3RlbmVyID0gZGV0YWlsKGxpc3RlbmVyKTtcbiAgfVxuICB0eXBlLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTsgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBvZmYodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cbn1cbmZ1bmN0aW9uIG9mZiAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoIHVzZUNhcHR1cmUgPT09IHZvaWQgMCApIHVzZUNhcHR1cmUgPSBmYWxzZTtcbiAgdGFyZ2V0ID0gdG9FdmVudFRhcmdldCh0YXJnZXQpO1xuICB0YXJnZXQgJiYgdHlwZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTsgfSk7XG59XG5mdW5jdGlvbiBvbmNlICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgdmFyIHJlZiA9IGdldEFyZ3MoYXJncyk7XG4gIHZhciBlbGVtZW50ID0gcmVmWzBdO1xuICB2YXIgdHlwZSA9IHJlZlsxXTtcbiAgdmFyIHNlbGVjdG9yID0gcmVmWzJdO1xuICB2YXIgbGlzdGVuZXIgPSByZWZbM107XG4gIHZhciB1c2VDYXB0dXJlID0gcmVmWzRdO1xuICB2YXIgY29uZGl0aW9uID0gcmVmWzVdO1xuICB2YXIgb2ZmID0gb24oZWxlbWVudCwgdHlwZSwgc2VsZWN0b3IsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICFjb25kaXRpb24gfHwgY29uZGl0aW9uKGUpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIG9mZigpO1xuICAgICAgbGlzdGVuZXIoZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0sIHVzZUNhcHR1cmUpO1xuICByZXR1cm4gb2ZmXG59XG5mdW5jdGlvbiB0cmlnZ2VyICh0YXJnZXQsIGV2ZW50LCBkZXRhaWwpIHtcbiAgcmV0dXJuIHRvRXZlbnRUYXJnZXRzKHRhcmdldCkucmVkdWNlKGZ1bmN0aW9uIChub3RDYW5jZWxlZCwgdGFyZ2V0KSB7IHJldHVybiBub3RDYW5jZWxlZCAmJiB0YXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSwgZGV0YWlsKSk7IH1cbiAgICAsIHRydWUpXG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudCAoZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKSB7XG4gIGlmICggYnViYmxlcyA9PT0gdm9pZCAwICkgYnViYmxlcyA9IHRydWU7XG4gIGlmICggY2FuY2VsYWJsZSA9PT0gdm9pZCAwICkgY2FuY2VsYWJsZSA9IGZhbHNlO1xuICBpZiAoaXNTdHJpbmcoZSkpIHtcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKTtcbiAgICBlID0gZXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGVcbn1cbmZ1bmN0aW9uIGdldEFyZ3MgKGFyZ3MpIHtcbiAgaWYgKGlzU3RyaW5nKGFyZ3NbMF0pKSB7XG4gICAgYXJnc1swXSA9IGZpbmQoYXJnc1swXSk7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24oYXJnc1syXSkpIHtcbiAgICBhcmdzLnNwbGljZSgyLCAwLCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIGFyZ3Ncbn1cbmZ1bmN0aW9uIGRlbGVnYXRlIChlbGVtZW50LCBzZWxlY3RvciwgbGlzdGVuZXIpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICB2YXIgY3VycmVudCA9IHNlbGVjdG9yWzBdID09PSAnPidcbiAgICAgID8gZmluZEFsbChzZWxlY3RvciwgZWxlbWVudCkucmV2ZXJzZSgpLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gd2l0aGluKHRhcmdldCwgZWxlbWVudCk7IH0pWzBdXG4gICAgICA6IGNsb3Nlc3QodGFyZ2V0LCBzZWxlY3Rvcik7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGUuZGVsZWdhdGUgPSBlbGVtZW50O1xuICAgICAgZS5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcyQxLCBlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGFpbCAobGlzdGVuZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7IHJldHVybiBpc0FycmF5KGUuZGV0YWlsKSA/IGxpc3RlbmVyLmFwcGx5KGxpc3RlbmVyLCBbZV0uY29uY2F0KGUuZGV0YWlsKSkgOiBsaXN0ZW5lcihlKTsgfVxufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldCAodGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnRXZlbnRUYXJnZXQnIGluIHdpbmRvd1xuICAgID8gdGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50VGFyZ2V0XG4gICAgOiB0YXJnZXQgJiYgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRhcmdldFxufVxuZnVuY3Rpb24gdG9FdmVudFRhcmdldCAodGFyZ2V0KSB7XG4gIHJldHVybiBpc0V2ZW50VGFyZ2V0KHRhcmdldCkgPyB0YXJnZXQgOiB0b05vZGUodGFyZ2V0KVxufVxuZnVuY3Rpb24gdG9FdmVudFRhcmdldHMgKHRhcmdldCkge1xuICByZXR1cm4gaXNFdmVudFRhcmdldCh0YXJnZXQpXG4gICAgPyBbdGFyZ2V0XVxuICAgIDogaXNBcnJheSh0YXJnZXQpXG4gICAgICA/IHRhcmdldC5tYXAodG9FdmVudFRhcmdldCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgICA6IHRvTm9kZXModGFyZ2V0KVxufVxuXG52YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbmZ1bmN0aW9uIGlzUmVhZHkgKCkge1xuICByZXR1cm4gZG9jICYmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJyAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKVxufVxuZnVuY3Rpb24gcmVhZHkgKGZuKSB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzUmVhZHkoKSkge1xuICAgIGZuKCk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGhhbmRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB1bmJpbmQxKCk7XG4gICAgdW5iaW5kMigpO1xuICAgIGZuKCk7XG4gIH07XG4gIHZhciB1bmJpbmQxID0gb24oZG9jdW1lbnQsICdET01Db250ZW50TG9hZGVkJywgaGFuZGxlKTtcbiAgdmFyIHVuYmluZDIgPSBvbih3aW5kb3csICdsb2FkJywgaGFuZGxlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZCAocGFyZW50LCBlbGVtZW50KSB7XG4gIHBhcmVudCA9IHRvTm9kZShwYXJlbnQpO1xuICByZXR1cm4gaW5zZXJ0Tm9kZXMoZWxlbWVudCwgZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTsgfSlcbn1cbmZ1bmN0aW9uIGJlZm9yZSAocmVmLCBlbGVtZW50KSB7XG4gIHJlZiA9IHRvTm9kZShyZWYpO1xuICByZXR1cm4gaW5zZXJ0Tm9kZXMoZWxlbWVudCwgZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIHJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCByZWYpOyB9KVxufVxuZnVuY3Rpb24gYWZ0ZXIgKHJlZiwgZWxlbWVudCkge1xuICByZWYgPSB0b05vZGUocmVmKTtcbiAgcmV0dXJuIGluc2VydE5vZGVzKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiByZWYubmV4dFNpYmxpbmdcbiAgICA/IGJlZm9yZShyZWYubmV4dFNpYmxpbmcsIGVsZW1lbnQpXG4gICAgOiBhcHBlbmQocmVmLnBhcmVudE5vZGUsIGVsZW1lbnQpOyB9XG4gIClcbn1cbmZ1bmN0aW9uIGluc2VydE5vZGVzIChlbGVtZW50LCBmbikge1xuICBlbGVtZW50ID0gaXNTdHJpbmcoZWxlbWVudCkgPyBmcmFnbWVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG4gIHJldHVybiBlbGVtZW50XG4gICAgPyAnbGVuZ3RoJyBpbiBlbGVtZW50XG4gICAgICA/IHRvTm9kZXMoZWxlbWVudCkubWFwKGZuKVxuICAgICAgOiBmbihlbGVtZW50KVxuICAgIDogbnVsbFxufVxuZnVuY3Rpb24gcmVtb3ZlIChlbGVtZW50KSB7XG4gIHRvTm9kZXMoZWxlbWVudCkubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpOyB9KTtcbn1cbnZhciBmcmFnbWVudFJFID0gL15cXHMqPChcXHcrfCEpW14+XSo+LztcbnZhciBzaW5nbGVUYWdSRSA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+KT8kLztcbmZ1bmN0aW9uIGZyYWdtZW50IChodG1sKSB7XG4gIHZhciBtYXRjaGVzID0gc2luZ2xlVGFnUkUuZXhlYyhodG1sKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChtYXRjaGVzWzFdKVxuICB9XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaWYgKGZyYWdtZW50UkUudGVzdChodG1sKSkge1xuICAgIGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGh0bWwudHJpbSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSBodG1sO1xuICB9XG4gIHJldHVybiBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggPiAxID8gdG9Ob2Rlcyhjb250YWluZXIuY2hpbGROb2RlcykgOiBjb250YWluZXIuZmlyc3RDaGlsZFxufVxuXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWxlbWVudCkge1xuICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuICBhcHBseSQxKGVsZW1lbnQsIGFyZ3MsICdhZGQnKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbGVtZW50KSB7XG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG4gIGFwcGx5JDEoZWxlbWVudCwgYXJncywgJ3JlbW92ZScpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyAoZWxlbWVudCwgY2xzKSB7XG4gIGZpbHRlckF0dHIoZWxlbWVudCwgJ2NsYXNzJywgbmV3IFJlZ0V4cCgoXCIoXnxcXFxccylcIiArIGNscyArIFwiKD8hXFxcXFMpXCIpLCAnZycpLCAnJyk7XG59XG5mdW5jdGlvbiByZXBsYWNlQ2xhc3MgKGVsZW1lbnQpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcbiAgYXJnc1swXSAmJiByZW1vdmVDbGFzcyhlbGVtZW50LCBhcmdzWzBdKTtcbiAgYXJnc1sxXSAmJiBhZGRDbGFzcyhlbGVtZW50LCBhcmdzWzFdKTtcbn1cbmZ1bmN0aW9uIGhhc0NsYXNzIChlbGVtZW50LCBjbHMpIHtcbiAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZShmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xzKTsgfSlcbn1cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzIChlbGVtZW50KSB7XG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG4gIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuICBhcmdzID0gZ2V0QXJncyQxKGFyZ3MpO1xuICB2YXIgZm9yY2UgPSAhaXNTdHJpbmcoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA/IGFyZ3MucG9wKCkgOiBbXTtcbiAgYXJncyA9IGFyZ3MuZmlsdGVyKEJvb2xlYW4pO1xuICB0b05vZGVzKGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBjbGFzc0xpc3QgPSByZWYuY2xhc3NMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgc3VwcG9ydHMuRm9yY2VcbiAgICAgICAgPyBjbGFzc0xpc3QudG9nZ2xlLmFwcGx5KGNsYXNzTGlzdCwgW2FyZ3NbaV1dLmNvbmNhdChmb3JjZSkpXG4gICAgICAgIDogKGNsYXNzTGlzdFsoIWlzVW5kZWZpbmVkKGZvcmNlKSA/IGZvcmNlIDogIWNsYXNzTGlzdC5jb250YWlucyhhcmdzW2ldKSkgPyAnYWRkJyA6ICdyZW1vdmUnXShhcmdzW2ldKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5JDEgKGVsZW1lbnQsIGFyZ3MsIGZuKSB7XG4gIGFyZ3MgPSBnZXRBcmdzJDEoYXJncykuZmlsdGVyKEJvb2xlYW4pO1xuICBhcmdzLmxlbmd0aCAmJiB0b05vZGVzKGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBjbGFzc0xpc3QgPSByZWYuY2xhc3NMaXN0O1xuICAgIHN1cHBvcnRzLk11bHRpcGxlXG4gICAgICA/IGNsYXNzTGlzdFtmbl0uYXBwbHkoY2xhc3NMaXN0LCBhcmdzKVxuICAgICAgOiBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZXR1cm4gY2xhc3NMaXN0W2ZuXShjbHMpOyB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBcmdzJDEgKGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChhcmdzLCBhcmcpIHsgcmV0dXJuIGFyZ3MuY29uY2F0LmNhbGwoYXJncywgaXNTdHJpbmcoYXJnKSAmJiBpbmNsdWRlcyhhcmcsICcgJykgPyBhcmcudHJpbSgpLnNwbGl0KCcgJykgOiBhcmcpOyB9XG4gICAgLCBbXSlcbn1cbnZhciBzdXBwb3J0cyA9IHt9O1xuKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnXycpLmNsYXNzTGlzdCkge1xuICAgIHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnXycpLmNsYXNzTGlzdDtcbiAgICBsaXN0LmFkZCgnYScsICdiJyk7XG4gICAgbGlzdC50b2dnbGUoJ2MnLCBmYWxzZSk7XG4gICAgc3VwcG9ydHMuTXVsdGlwbGUgPSBsaXN0LmNvbnRhaW5zKCdiJyk7XG4gICAgc3VwcG9ydHMuRm9yY2UgPSAhbGlzdC5jb250YWlucygnYycpO1xuICAgIGxpc3QgPSBudWxsO1xuICB9XG59KSgpO1xuXG52YXIgY3NzTnVtYmVyID0ge1xuICAnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCc6IHRydWUsXG4gICdjb2x1bW4tY291bnQnOiB0cnVlLFxuICAnZmlsbC1vcGFjaXR5JzogdHJ1ZSxcbiAgJ2ZsZXgtZ3Jvdyc6IHRydWUsXG4gICdmbGV4LXNocmluayc6IHRydWUsXG4gICdmb250LXdlaWdodCc6IHRydWUsXG4gICdsaW5lLWhlaWdodCc6IHRydWUsXG4gICdvcGFjaXR5JzogdHJ1ZSxcbiAgJ29yZGVyJzogdHJ1ZSxcbiAgJ29ycGhhbnMnOiB0cnVlLFxuICAnd2lkb3dzJzogdHJ1ZSxcbiAgJ3otaW5kZXgnOiB0cnVlLFxuICAnem9vbSc6IHRydWVcbn07XG5mdW5jdGlvbiBjc3MgKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoaXNTdHJpbmcocHJvcGVydHkpKSB7XG4gICAgICBwcm9wZXJ0eSA9IHByb3BOYW1lKHByb3BlcnR5KTtcbiAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KVxuICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGlzTnVtZXJpYyh2YWx1ZSkgJiYgIWNzc051bWJlcltwcm9wZXJ0eV0gPyAodmFsdWUgKyBcInB4XCIpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtZW50KTtcbiAgICAgIHJldHVybiBwcm9wZXJ0eS5yZWR1Y2UoZnVuY3Rpb24gKHByb3BzLCBwcm9wZXJ0eSkge1xuICAgICAgICBwcm9wc1twcm9wZXJ0eV0gPSBzdHlsZXNbcHJvcE5hbWUocHJvcGVydHkpXTtcbiAgICAgICAgcmV0dXJuIHByb3BzXG4gICAgICB9LCB7fSlcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHByb3BlcnR5KSkge1xuICAgICAgZWFjaChwcm9wZXJ0eSwgZnVuY3Rpb24gKHZhbHVlLCBwcm9wZXJ0eSkgeyByZXR1cm4gY3NzKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudFxuICB9KVswXVxufVxuZnVuY3Rpb24gZ2V0U3R5bGVzIChlbGVtZW50LCBwc2V1ZG9FbHQpIHtcbiAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHBzZXVkb0VsdClcbn1cbmZ1bmN0aW9uIGdldFN0eWxlIChlbGVtZW50LCBwcm9wZXJ0eSwgcHNldWRvRWx0KSB7XG4gIHJldHVybiBnZXRTdHlsZXMoZWxlbWVudCwgcHNldWRvRWx0KVtwcm9wZXJ0eV1cbn1cbnZhciB2YXJzID0ge307XG5mdW5jdGlvbiBnZXRDc3NWYXIgKG5hbWUpIHtcbiAgaWYgKCEobmFtZSBpbiB2YXJzKSkge1xuICAgIHZhciBlbGVtZW50ID0gYXBwZW5kKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgIGFkZENsYXNzKGVsZW1lbnQsIChcInZhci1cIiArIG5hbWUpKTtcbiAgICB0cnkge1xuICAgICAgdmFyc1tuYW1lXSA9IGdldFN0eWxlKGVsZW1lbnQsICdjb250ZW50JywgJzpiZWZvcmUnKS5yZXBsYWNlKC9eW1wiJ10oLiopW1wiJ10kLywgJyQxJyk7XG4gICAgICB2YXJzW25hbWVdID0gSlNPTi5wYXJzZSh2YXJzW25hbWVdKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gdmFyc1tuYW1lXVxufVxudmFyIGNzc1Byb3BzID0ge307XG5mdW5jdGlvbiBwcm9wTmFtZSAobmFtZSkge1xuICB2YXIgcmV0ID0gY3NzUHJvcHNbbmFtZV07XG4gIGlmICghcmV0KSB7XG4gICAgcmV0ID0gY3NzUHJvcHNbbmFtZV0gPSB2ZW5kb3JQcm9wTmFtZShuYW1lKSB8fCBuYW1lO1xuICB9XG4gIHJldHVybiByZXRcbn1cbnZhciBjc3NQcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veicsICdtcyddO1xuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUgKG5hbWUpIHtcbiAgdmFyIHJlZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcbiAgdmFyIHN0eWxlID0gcmVmLnN0eWxlO1xuICBuYW1lID0gaHlwaGVuYXRlKG5hbWUpO1xuICBpZiAobmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBuYW1lXG4gIH1cbiAgdmFyIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGgsIHByZWZpeGVkTmFtZTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkTmFtZSA9IFwiLVwiICsgKGNzc1ByZWZpeGVzW2ldKSArIFwiLVwiICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWROYW1lIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWROYW1lXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvTWVkaWEgKHZhbHVlKSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWVbMF0gPT09ICdAJykge1xuICAgICAgdmFyIG5hbWUgPSBcIm1lZGlhLVwiICsgKHZhbHVlLnN1YnN0cigxKSk7XG4gICAgICB2YWx1ZSA9IHRvRmxvYXQoZ2V0Q3NzVmFyKG5hbWUpKTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAmJiAhaXNOYU4odmFsdWUpID8gKFwiKG1pbi13aWR0aDogXCIgKyB2YWx1ZSArIFwicHgpXCIpIDogZmFsc2Vcbn1cbmZ1bmN0aW9uIGdldCAob2JqLCBwYXRoLCBkZWZWYWwpIHtcbiAgdmFyIHJlc3VsdCA9IGlzT2JqZWN0KG9iaikgJiYgaXNTdHJpbmcocGF0aClcbiAgICA/IF9nZXQob2JqLCBwYXRoKVxuICAgIDogdW5kZWZpbmVkO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICA/IGRlZlZhbFxuICAgIDogcmVzdWx0XG59XG5mdW5jdGlvbiBfZ2V0IChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdmFsKSB7IHJldHVybiBhY2MgJiYgYWNjW3ZhbF07IH0sIG9iailcbn1cbmZ1bmN0aW9uIHJhbmdlIChzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoIHN0ZXAgPT09IHZvaWQgMCApIHN0ZXAgPSAxO1xuICBpZiAodHlwZW9mIHN0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RvcCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgQXJyYXkoTWF0aC5mbG9vcigoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKSwgZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuIHN0YXJ0ICsgKGkgKiBzdGVwKTsgfSlcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudCAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGZpbmRQYXJlbnRzKGluc3RhbmNlKS5wb3AoKVxufVxuZnVuY3Rpb24gZmluZFBhcmVudHMgKGluc3RhbmNlKSB7XG4gIHZhciBwYXJlbnRzID0gW107XG4gIHZhciBuYW1lID0gaW5zdGFuY2UuJG9wdGlvbnMubmFtZTtcbiAgdmFyIHBhcmVudCA9IGluc3RhbmNlLiRwYXJlbnQ7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LiRvcHRpb25zLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHBhcmVudHMudW5zaGlmdChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgfVxuICByZXR1cm4gcGFyZW50c1xufVxuZnVuY3Rpb24gYXBwbHkkMiAoaW5zdGFuY2UsIGZuKSB7XG4gIGlmICghaW5zdGFuY2UgfHwgIWluc3RhbmNlLl9pc1Z1ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGZuKGluc3RhbmNlKTtcbiAgaW5zdGFuY2UuJGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBhcHBseSQyKGNoaWxkLCBmbik7IH0pO1xufVxuZnVuY3Rpb24gZmlsdGVyT3V0VGV4dE5vZGVzIChub2Rlcykge1xuICByZXR1cm4gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIobik7IH0pXG59XG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5mdW5jdGlvbiBtZXJnZURhdGEgKCkge1xuICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG4gIGZvcih2YXIgZSxhLHM9e30sdD1hcmd1bWVudHMubGVuZ3RoO3QtLTspeyBmb3IodmFyIHI9MCxjPU9iamVjdC5rZXlzKGFyZ3VtZW50c1t0XSk7cjxjLmxlbmd0aDtyKyspeyBzd2l0Y2goZT1jW3JdKXtjYXNlXCJjbGFzc1wiOmNhc2VcInN0eWxlXCI6Y2FzZVwiZGlyZWN0aXZlc1wiOkFycmF5LmlzQXJyYXkoc1tlXSl8fChzW2VdPVtdKSwgc1tlXT1zW2VdLmNvbmNhdChhcmd1bWVudHMkMVt0XVtlXSk7YnJlYWs7Y2FzZVwic3RhdGljQ2xhc3NcIjppZighYXJndW1lbnRzJDFbdF1bZV0peyBicmVhazsgfXZvaWQgMD09PXNbZV0mJihzW2VdPVwiXCIpLCBzW2VdJiYoc1tlXSs9XCIgXCIpLCBzW2VdKz1hcmd1bWVudHMkMVt0XVtlXS50cmltKCk7YnJlYWs7Y2FzZVwib25cIjpjYXNlXCJuYXRpdmVPblwiOnNbZV18fChzW2VdPXt9KTtmb3IodmFyIG89MCxuPU9iamVjdC5rZXlzKGFyZ3VtZW50c1t0XVtlXSk7bzxuLmxlbmd0aDtvKyspeyBhPW5bb10sIHNbZV1bYV0/c1tlXVthXT1bXS5jb25jYXQoc1tlXVthXSxhcmd1bWVudHMkMVt0XVtlXVthXSk6c1tlXVthXT1hcmd1bWVudHMkMVt0XVtlXVthXTsgfWJyZWFrO2Nhc2VcImF0dHJzXCI6Y2FzZVwicHJvcHNcIjpjYXNlXCJkb21Qcm9wc1wiOmNhc2VcInNjb3BlZFNsb3RzXCI6Y2FzZVwic3RhdGljU3R5bGVcIjpjYXNlXCJob29rXCI6Y2FzZVwidHJhbnNpdGlvblwiOnNbZV18fChzW2VdPXt9KSwgc1tlXT1fX2Fzc2lnbih7fSxhcmd1bWVudHMkMVt0XVtlXSxzW2VdKTticmVhaztjYXNlXCJzbG90XCI6Y2FzZVwia2V5XCI6Y2FzZVwicmVmXCI6Y2FzZVwidGFnXCI6Y2FzZVwic2hvd1wiOmNhc2VcImtlZXBBbGl2ZVwiOmRlZmF1bHQ6c1tlXXx8KHNbZV09YXJndW1lbnRzJDFbdF1bZV0pO30gfSB9cmV0dXJuIHN9dmFyIF9fYXNzaWduPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe1xuICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5mb3IodmFyIGEscz0xLHQ9YXJndW1lbnRzLmxlbmd0aDtzPHQ7cysrKXthPWFyZ3VtZW50cyQxW3NdO2Zvcih2YXIgciBpbiBhKXsgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEscikmJihlW3JdPWFbcl0pOyB9fXJldHVybiBlXG59O1xuXG52YXIgRWxlbWVudEJyZWFkY3J1bWIgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICByZXR1cm4gaCgndWwnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6ICd1ay1icmVhZGNydW1iJ1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudEJyZWFkY3J1bWJJdGVtID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGhyZWY6IFN0cmluZyxcbiAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgdmFyIGhyZWYgPSBwcm9wcy5ocmVmO1xuICAgIHZhciB0YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gICAgcmV0dXJuIGgoJ2xpJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgICd1ay1kaXNhYmxlZCc6IGRpc2FibGVkXG4gICAgICB9XG4gICAgfSksIFtcbiAgICAgIChpc1VuZGVmaW5lZChocmVmKSB8fCBkaXNhYmxlZClcbiAgICAgICAgPyBoKCdzcGFuJywgY2hpbGRyZW4pXG4gICAgICAgIDogaCgnYScsIHsgYXR0cnM6IHsgaHJlZjogaHJlZiwgdGFyZ2V0OiB0YXJnZXQgfSB9LCBjaGlsZHJlbilcbiAgICBdKVxuICB9XG59XG5cbnZhciBicmVhZGNydW1iID0ge1xuICBuYW1lOiAnVmtCcmVhZGNydW1iJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnRCcmVhZGNydW1iLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnRCcmVhZGNydW1iLnJlbmRlclxufVxuXG52YXIgYnJlYWRjcnVtYl9JdGVtID0ge1xuICBuYW1lOiAnVmtCcmVhZGNydW1iSXRlbScsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50QnJlYWRjcnVtYkl0ZW0ucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudEJyZWFkY3J1bWJJdGVtLnJlbmRlclxufVxuXG52YXIgcHJvcHMgPSB7XG4gIGFjdGl2ZToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgc2l6ZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICF2YWwgfHwgL14oc21hbGx8bGFyZ2UpJC8udGVzdCh2YWwpOyB9XG4gIH0sXG4gIHR5cGU6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAhdmFsIHx8IC9eKHByaW1hcnl8c2Vjb25kYXJ5fGRhbmdlcnx0ZXh0fGxpbmspJC8udGVzdCh2YWwpOyB9XG4gIH1cbn07XG52YXIgZGVmID0gZnVuY3Rpb24gKHJlZikge1xuICB2YXIgb2JqO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgYWN0aXZlID0gcmVmLmFjdGl2ZTtcbiAgdmFyIHNpemUgPSByZWYuc2l6ZTtcbiAgcmV0dXJuICh7XG4gIGNsYXNzOiBbJ3VrLWJ1dHRvbicsIChcInVrLWJ1dHRvbi1cIiArICh0eXBlIHx8ICdkZWZhdWx0JykpLCAoIG9iaiA9IHtcbiAgICAndWstYWN0aXZlJzogYWN0aXZlXG4gIH0sIG9ialsoXCJ1ay1idXR0b24tXCIgKyBzaXplKV0gPSBzaXplLCBvYmopXVxufSk7XG59O1xuXG52YXIgRWxlbWVudEJ1dHRvbiA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBodG1sVHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICB9XG4gIH0pLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzJCQxID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBodG1sVHlwZSA9IHByb3BzJCQxLmh0bWxUeXBlO1xuICAgIHJldHVybiBoKCdidXR0b24nLCBtZXJnZURhdGEoZGF0YSwgZGVmKHByb3BzJCQxKSwge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdHlwZTogaHRtbFR5cGVcbiAgICAgIH1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRCdXR0b25MaW5rID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogcHJvcHMsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMkJDEgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgoJ2EnLCBtZXJnZURhdGEoZGF0YSwgZGVmKHByb3BzJCQxKSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50QnV0dG9uR3JvdXAgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICByZXR1cm4gaCgnZGl2JywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndWstYnV0dG9uLWdyb3VwJ1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgYnV0dG9uID0ge1xuICBuYW1lOiAnVmtCdXR0b24nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogRWxlbWVudEJ1dHRvbi5wcm9wcyxcbiAgcmVuZGVyOiBFbGVtZW50QnV0dG9uLnJlbmRlclxufVxuXG52YXIgYnV0dG9uTGluayA9IHtcbiAgbmFtZTogJ1ZrQnV0dG9uTGluaycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50QnV0dG9uTGluay5wcm9wcyxcbiAgcmVuZGVyOiBFbGVtZW50QnV0dG9uTGluay5yZW5kZXJcbn1cblxudmFyIGJ1dHRvbkdyb3VwID0ge1xuICBuYW1lOiAnVmtCdXR0b25Hcm91cCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50QnV0dG9uR3JvdXAucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudEJ1dHRvbkdyb3VwLnJlbmRlclxufVxuXG52YXIgRWxlbWVudENhcmQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAvXihkZWZhdWx0fHByaW1hcnl8c2Vjb25kYXJ5fGJsYW5rKSQvLnRlc3QodmFsKTsgfVxuICAgIH0sXG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAhdmFsIHx8IC9eKHNtYWxsfGxhcmdlKSQvLnRlc3QodmFsKTsgfVxuICAgIH0sXG4gICAgaG92ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBvYmo7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHNsb3RzID0gcmVmLnNsb3RzO1xuICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTtcbiAgICB2YXIgcGFkZGluZyA9IHByb3BzLnBhZGRpbmc7XG4gICAgdmFyIGhvdmVyID0gcHJvcHMuaG92ZXI7XG4gICAgdmFyIF9zbG90cyA9IHNsb3RzKCk7XG4gICAgdmFyIGJvZHkgPSBfc2xvdHMuYm9keTtcbiAgICBpZiAoIWJvZHkgfHwgIWJvZHkubGVuZ3RoKSB7XG4gICAgICBfc2xvdHMuYm9keSA9IF9zbG90cy5kZWZhdWx0O1xuICAgICAgZGVsZXRlIF9zbG90cy5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gaCgnZGl2JywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLWNhcmQnLCAoIG9iaiA9IHtcbiAgICAgICAgJ3VrLWNhcmQtaG92ZXInOiBob3ZlclxuICAgICAgfSwgb2JqWyhcInVrLWNhcmQtXCIgKyB0eXBlKV0gPSB0eXBlLCBvYmpbKFwidWstY2FyZC1cIiArIHBhZGRpbmcpXSA9IHBhZGRpbmcsIG9iaildXG4gICAgfSksIFtcbiAgICAgIF9zbG90cy5kZWZhdWx0ICYmIF9zbG90cy5kZWZhdWx0LFxuICAgICAgX3Nsb3RzWydtZWRpYS10b3AnXSAmJiBoKCdkaXYnLCB7IGNsYXNzOiAndWstY2FyZC1tZWRpYS10b3AnIH0sIF9zbG90c1snbWVkaWEtdG9wJ10pLFxuICAgICAgX3Nsb3RzLmJhZGdlICYmIGgoJ2RpdicsIHsgY2xhc3M6ICd1ay1jYXJkLWJhZGdlJyB9LCBfc2xvdHMuYmFkZ2UpLFxuICAgICAgX3Nsb3RzLmhlYWRlciAmJiBoKCdkaXYnLCB7IGNsYXNzOiAndWstY2FyZC1oZWFkZXInIH0sIF9zbG90cy5oZWFkZXIpLFxuICAgICAgX3Nsb3RzWydtZWRpYSddICYmIGgoJ2RpdicsIHsgY2xhc3M6ICd1ay1jYXJkLW1lZGlhJyB9LCBfc2xvdHNbJ21lZGlhJ10pLFxuICAgICAgX3Nsb3RzLmJvZHkgJiYgaCgnZGl2JywgeyBjbGFzczogJ3VrLWNhcmQtYm9keScgfSwgX3Nsb3RzLmJvZHkpLFxuICAgICAgX3Nsb3RzLmZvb3RlciAmJiBoKCdkaXYnLCB7IGNsYXNzOiAndWstY2FyZC1mb290ZXInIH0sIF9zbG90cy5mb290ZXIpLFxuICAgICAgX3Nsb3RzWydtZWRpYS1ib3R0b20nXSAmJiBoKCdkaXYnLCB7IGNsYXNzOiAndWstY2FyZC1tZWRpYS1ib3R0b20nIH0sIF9zbG90c1snbWVkaWEtYm90dG9tJ10pXG4gICAgXSlcbiAgfVxufVxuXG52YXIgRWxlbWVudENhcmRUaXRsZSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdoMydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgocHJvcHMudGFnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6ICd1ay1jYXJkLXRpdGxlJ1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgY2FyZCA9IHtcbiAgbmFtZTogJ1ZrQ2FyZCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50Q2FyZC5wcm9wcyxcbiAgcmVuZGVyOiBFbGVtZW50Q2FyZC5yZW5kZXJcbn1cblxudmFyIGNhcmRfVGl0bGUgPSB7XG4gIG5hbWU6ICdWa0NhcmRUaXRsZScsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50Q2FyZFRpdGxlLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnRDYXJkVGl0bGUucmVuZGVyXG59XG5cbnZhciBWa1Jvb3QgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgdm5vZGUuY29udGV4dC4kcm9vdC4kZWwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSAoKSB7fVxudmFyIHdhcm4gPSBub29wJDE7XG52YXIgdGlwID0gbm9vcCQxO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVpa2l0IHdhcm5dOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWlraXQgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuICB2YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXG4gICAgICA/IHZtXG4gICAgICA6IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICAgID8gdm0ub3B0aW9ucy5uYW1lXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgICA6IHZtLm5hbWU7XG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpcnMgPSB7XG4gIHdpZHRoOiBbJ3gnLCAnbGVmdCcsICdyaWdodCddLFxuICBoZWlnaHQ6IFsneScsICd0b3AnLCAnYm90dG9tJ11cbn07XG5mdW5jdGlvbiBwb3NpdGlvbkF0IChlbGVtZW50LCB0YXJnZXQsIGVsQXR0YWNoLCB0YXJnZXRBdHRhY2gsIGVsT2Zmc2V0LCB0YXJnZXRPZmZzZXQsIGZsaXAsIGJvdW5kYXJ5KSB7XG4gIGVsQXR0YWNoID0gZ2V0UG9zKGVsQXR0YWNoKTtcbiAgdGFyZ2V0QXR0YWNoID0gZ2V0UG9zKHRhcmdldEF0dGFjaCk7XG4gIHZhciBmbGlwcGVkID0ge2VsZW1lbnQ6IGVsQXR0YWNoLCB0YXJnZXQ6IHRhcmdldEF0dGFjaH07XG4gIGlmICghZWxlbWVudCB8fCAhdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZsaXBwZWRcbiAgfVxuICB2YXIgZGltID0gZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgdmFyIHRhcmdldERpbSA9IGdldERpbWVuc2lvbnModGFyZ2V0KTtcbiAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0RGltO1xuICBtb3ZlVG8ocG9zaXRpb24sIGVsQXR0YWNoLCBkaW0sIC0xKTtcbiAgbW92ZVRvKHBvc2l0aW9uLCB0YXJnZXRBdHRhY2gsIHRhcmdldERpbSwgMSk7XG4gIGVsT2Zmc2V0ID0gZ2V0T2Zmc2V0cyhlbE9mZnNldCwgZGltLndpZHRoLCBkaW0uaGVpZ2h0KTtcbiAgdGFyZ2V0T2Zmc2V0ID0gZ2V0T2Zmc2V0cyh0YXJnZXRPZmZzZXQsIHRhcmdldERpbS53aWR0aCwgdGFyZ2V0RGltLmhlaWdodCk7XG4gIGVsT2Zmc2V0Wyd4J10gKz0gdGFyZ2V0T2Zmc2V0Wyd4J107XG4gIGVsT2Zmc2V0Wyd5J10gKz0gdGFyZ2V0T2Zmc2V0Wyd5J107XG4gIHBvc2l0aW9uLmxlZnQgKz0gZWxPZmZzZXRbJ3gnXTtcbiAgcG9zaXRpb24udG9wICs9IGVsT2Zmc2V0Wyd5J107XG4gIGJvdW5kYXJ5ID0gZ2V0RGltZW5zaW9ucyhib3VuZGFyeSB8fCB3aW5kb3ckMShlbGVtZW50KSk7XG4gIGlmIChmbGlwKSB7XG4gICAgZWFjaChkaXJzLCBmdW5jdGlvbiAocmVmLCBwcm9wKSB7XG4gICAgICB2YXIgZGlyID0gcmVmWzBdO1xuICAgICAgdmFyIGFsaWduID0gcmVmWzFdO1xuICAgICAgdmFyIGFsaWduRmxpcCA9IHJlZlsyXTtcbiAgICAgIGlmICghKGZsaXAgPT09IHRydWUgfHwgaW5jbHVkZXMoZmxpcCwgZGlyKSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgZWxlbU9mZnNldCA9IGVsQXR0YWNoW2Rpcl0gPT09IGFsaWduXG4gICAgICAgID8gLWRpbVtwcm9wXVxuICAgICAgICA6IGVsQXR0YWNoW2Rpcl0gPT09IGFsaWduRmxpcFxuICAgICAgICAgID8gZGltW3Byb3BdXG4gICAgICAgICAgOiAwO1xuICAgICAgdmFyIHRhcmdldE9mZnNldCA9IHRhcmdldEF0dGFjaFtkaXJdID09PSBhbGlnblxuICAgICAgICA/IHRhcmdldERpbVtwcm9wXVxuICAgICAgICA6IHRhcmdldEF0dGFjaFtkaXJdID09PSBhbGlnbkZsaXBcbiAgICAgICAgICA/IC10YXJnZXREaW1bcHJvcF1cbiAgICAgICAgICA6IDA7XG4gICAgICBpZiAocG9zaXRpb25bYWxpZ25dIDwgYm91bmRhcnlbYWxpZ25dIHx8IHBvc2l0aW9uW2FsaWduXSArIGRpbVtwcm9wXSA+IGJvdW5kYXJ5W2FsaWduRmxpcF0pIHtcbiAgICAgICAgdmFyIGNlbnRlck9mZnNldCA9IGRpbVtwcm9wXSAvIDI7XG4gICAgICAgIHZhciBjZW50ZXJUYXJnZXRPZmZzZXQgPSB0YXJnZXRBdHRhY2hbZGlyXSA9PT0gJ2NlbnRlcicgPyAtdGFyZ2V0RGltW3Byb3BdIC8gMiA6IDA7XG4gICAgICAgIGVsQXR0YWNoW2Rpcl0gPT09ICdjZW50ZXInICYmIChcbiAgICAgICAgICBhcHBseShjZW50ZXJPZmZzZXQsIGNlbnRlclRhcmdldE9mZnNldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYXBwbHkoLWNlbnRlck9mZnNldCwgLWNlbnRlclRhcmdldE9mZnNldClcbiAgICAgICAgKSB8fCBhcHBseShlbGVtT2Zmc2V0LCB0YXJnZXRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXBwbHkgKGVsZW1PZmZzZXQsIHRhcmdldE9mZnNldCkge1xuICAgICAgICB2YXIgbmV3VmFsID0gcG9zaXRpb25bYWxpZ25dICsgZWxlbU9mZnNldCArIHRhcmdldE9mZnNldCAtIGVsT2Zmc2V0W2Rpcl0gKiAyO1xuICAgICAgICBpZiAobmV3VmFsID49IGJvdW5kYXJ5W2FsaWduXSAmJiBuZXdWYWwgKyBkaW1bcHJvcF0gPD0gYm91bmRhcnlbYWxpZ25GbGlwXSkge1xuICAgICAgICAgIHBvc2l0aW9uW2FsaWduXSA9IG5ld1ZhbDtcbiAgICAgICAgICBbJ2VsZW1lbnQnLCAndGFyZ2V0J10uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGZsaXBwZWRbZWxdW2Rpcl0gPSAhZWxlbU9mZnNldFxuICAgICAgICAgICAgICA/IGZsaXBwZWRbZWxdW2Rpcl1cbiAgICAgICAgICAgICAgOiBmbGlwcGVkW2VsXVtkaXJdID09PSBkaXJzW3Byb3BdWzFdXG4gICAgICAgICAgICAgICAgPyBkaXJzW3Byb3BdWzJdXG4gICAgICAgICAgICAgICAgOiBkaXJzW3Byb3BdWzFdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvZmZzZXQoZWxlbWVudCwgcG9zaXRpb24pO1xuICByZXR1cm4gZmxpcHBlZFxufVxuZnVuY3Rpb24gb2Zmc2V0IChlbGVtZW50LCBjb29yZGluYXRlcykge1xuICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICBpZiAoY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgY3VycmVudE9mZnNldCA9IG9mZnNldChlbGVtZW50KTtcbiAgICB2YXIgcG9zID0gY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpO1xuICAgIFsnbGVmdCcsICd0b3AnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBpZiAocHJvcCBpbiBjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgdmFsdWUgPSBjc3MoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSAoKGNvb3JkaW5hdGVzW3Byb3BdIC0gY3VycmVudE9mZnNldFtwcm9wXSkgK1xuICAgICAgICAgICAgICAgIHRvRmxvYXQocG9zID09PSAnYWJzb2x1dGUnICYmIHZhbHVlID09PSAnYXV0bycgPyBwb3NpdGlvbihlbGVtZW50KVtwcm9wXSA6IHZhbHVlKSkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGdldERpbWVuc2lvbnMoZWxlbWVudClcbn1cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMgKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgdmFyIHJlZiA9IHdpbmRvdyQxKGVsZW1lbnQpO1xuICB2YXIgdG9wID0gcmVmLnBhZ2VZT2Zmc2V0O1xuICB2YXIgbGVmdCA9IHJlZi5wYWdlWE9mZnNldDtcbiAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgdmFyIGhlaWdodCA9IGVsZW1lbnQuaW5uZXJIZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gZWxlbWVudC5pbm5lcldpZHRoO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0LFxuICAgICAgcmlnaHQ6IGxlZnQgKyB3aWR0aFxuICAgIH1cbiAgfVxuICB2YXIgZGlzcGxheSA9IGZhbHNlO1xuICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfVxuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmIChkaXNwbGF5ICE9PSBmYWxzZSkge1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIHRvcDogcmVjdC50b3AgKyB0b3AsXG4gICAgbGVmdDogcmVjdC5sZWZ0ICsgbGVmdCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tICsgdG9wLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgbGVmdFxuICB9XG59XG5mdW5jdGlvbiBwb3NpdGlvbiAoZWxlbWVudCkge1xuICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICB2YXIgcGFyZW50ID0gb2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuICB2YXIgcGFyZW50T2Zmc2V0ID0gcGFyZW50ID09PSBkb2NFbChlbGVtZW50KSA/IHt0b3A6IDAsIGxlZnQ6IDB9IDogb2Zmc2V0KHBhcmVudCk7XG4gIHZhciByZWYgPSBbJ3RvcCcsICdsZWZ0J10ucmVkdWNlKGZ1bmN0aW9uIChwcm9wcywgcHJvcCkge1xuICAgIHZhciBwcm9wTmFtZSQkMSA9IHVjZmlyc3QocHJvcCk7XG4gICAgcHJvcHNbcHJvcF0gLT0gcGFyZW50T2Zmc2V0W3Byb3BdICtcbiAgICAgICAgICAgICh0b0Zsb2F0KGNzcyhlbGVtZW50LCAoXCJtYXJnaW5cIiArIHByb3BOYW1lJCQxKSkpIHx8IDApICtcbiAgICAgICAgICAgICh0b0Zsb2F0KGNzcyhwYXJlbnQsIChcImJvcmRlclwiICsgcHJvcE5hbWUkJDEgKyBcIldpZHRoXCIpKSkgfHwgMCk7XG4gICAgcmV0dXJuIHByb3BzXG4gIH0sIG9mZnNldChlbGVtZW50KSk7XG4gIHZhciB0b3AgPSByZWYudG9wO1xuICB2YXIgbGVmdCA9IHJlZi5sZWZ0O1xuICByZXR1cm4ge3RvcDogdG9wLCBsZWZ0OiBsZWZ0fVxufVxuZnVuY3Rpb24gb2Zmc2V0UGFyZW50IChlbGVtZW50KSB7XG4gIHZhciBwYXJlbnQgPSB0b05vZGUoZWxlbWVudCkub2Zmc2V0UGFyZW50O1xuICB3aGlsZSAocGFyZW50ICYmIGNzcyhwYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHBhcmVudCB8fCBkb2NFbChlbGVtZW50KVxufVxudmFyIGhlaWdodCA9IGRpbWVuc2lvbignaGVpZ2h0Jyk7XG52YXIgd2lkdGggPSBkaW1lbnNpb24oJ3dpZHRoJyk7XG5mdW5jdGlvbiBkaW1lbnNpb24gKHByb3ApIHtcbiAgdmFyIHByb3BOYW1lJCQxID0gdWNmaXJzdChwcm9wKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZSkge1xuICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50WyhcImlubmVyXCIgKyBwcm9wTmFtZSQkMSldXG4gICAgICB9XG4gICAgICBpZiAoaXNEb2N1bWVudChlbGVtZW50KSkge1xuICAgICAgICB2YXIgZG9jID0gZWxlbWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChkb2NbKFwib2Zmc2V0XCIgKyBwcm9wTmFtZSQkMSldLCBkb2NbKFwic2Nyb2xsXCIgKyBwcm9wTmFtZSQkMSldKVxuICAgICAgfVxuICAgICAgdmFsdWUgPSBjc3MoZWxlbWVudCwgcHJvcCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSAnYXV0bycgPyBlbGVtZW50WyhcIm9mZnNldFwiICsgcHJvcE5hbWUkJDEpXSA6IHRvRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgICByZXR1cm4gZ2V0Q29udGVudFNpemUocHJvcCwgZWxlbWVudCwgdmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNzcyhlbGVtZW50LCBwcm9wLCAhdmFsdWUgJiYgdmFsdWUgIT09IDBcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IGdldENvbnRlbnRTaXplKHByb3AsIGVsZW1lbnQsIHZhbHVlKSArICdweCdcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDb250ZW50U2l6ZSAocHJvcCwgZWxlbWVudCwgdmFsdWUpIHtcbiAgcmV0dXJuIGNzcyhlbGVtZW50LCAnYm94U2l6aW5nJykgPT09ICdib3JkZXItYm94JyA/IGRpcnNbcHJvcF0uc2xpY2UoMSkubWFwKHVjZmlyc3QpLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIHByb3ApIHsgcmV0dXJuIHZhbHVlIC1cbiAgICAgICAgdG9GbG9hdChjc3MoZWxlbWVudCwgKFwicGFkZGluZ1wiICsgcHJvcCkpKSAtXG4gICAgICAgIHRvRmxvYXQoY3NzKGVsZW1lbnQsIChcImJvcmRlclwiICsgcHJvcCArIFwiV2lkdGhcIikpKTsgfVxuICAgICwgdmFsdWUpIDogdmFsdWVcbn1cbmZ1bmN0aW9uIG1vdmVUbyAocG9zaXRpb24sIGF0dGFjaCwgZGltLCBmYWN0b3IpIHtcbiAgZWFjaChkaXJzLCBmdW5jdGlvbiAocmVmLCBwcm9wKSB7XG4gICAgdmFyIGRpciA9IHJlZlswXTtcbiAgICB2YXIgYWxpZ24gPSByZWZbMV07XG4gICAgdmFyIGFsaWduRmxpcCA9IHJlZlsyXTtcbiAgICBpZiAoYXR0YWNoW2Rpcl0gPT09IGFsaWduRmxpcCkge1xuICAgICAgcG9zaXRpb25bYWxpZ25dICs9IGRpbVtwcm9wXSAqIGZhY3RvcjtcbiAgICB9IGVsc2UgaWYgKGF0dGFjaFtkaXJdID09PSAnY2VudGVyJykge1xuICAgICAgcG9zaXRpb25bYWxpZ25dICs9IGRpbVtwcm9wXSAqIGZhY3RvciAvIDI7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBvcyAocG9zKSB7XG4gIHZhciB4ID0gL2xlZnR8Y2VudGVyfHJpZ2h0LztcbiAgdmFyIHkgPSAvdG9wfGNlbnRlcnxib3R0b20vO1xuICBwb3MgPSAocG9zIHx8ICcnKS5zcGxpdCgnICcpO1xuICBpZiAocG9zLmxlbmd0aCA9PT0gMSkge1xuICAgIHBvcyA9IHgudGVzdChwb3NbMF0pXG4gICAgICA/IHBvcy5jb25jYXQoWydjZW50ZXInXSlcbiAgICAgIDogeS50ZXN0KHBvc1swXSlcbiAgICAgICAgPyBbJ2NlbnRlciddLmNvbmNhdChwb3MpXG4gICAgICAgIDogWydjZW50ZXInLCAnY2VudGVyJ107XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB4LnRlc3QocG9zWzBdKSA/IHBvc1swXSA6ICdjZW50ZXInLFxuICAgIHk6IHkudGVzdChwb3NbMV0pID8gcG9zWzFdIDogJ2NlbnRlcidcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0cyAob2Zmc2V0cywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgcmVmID0gKG9mZnNldHMgfHwgJycpLnNwbGl0KCcgJyk7XG4gIHZhciB4ID0gcmVmWzBdO1xuICB2YXIgeSA9IHJlZlsxXTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ID8gdG9GbG9hdCh4KSAqIChlbmRzV2l0aCh4LCAnJScpID8gd2lkdGggLyAxMDAgOiAxKSA6IDAsXG4gICAgeTogeSA/IHRvRmxvYXQoeSkgKiAoZW5kc1dpdGgoeSwgJyUnKSA/IGhlaWdodCAvIDEwMCA6IDEpIDogMFxuICB9XG59XG5mdW5jdGlvbiBmbGlwUG9zaXRpb24gKHBvcykge1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuICdyaWdodCdcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gJ2xlZnQnXG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHJldHVybiAnYm90dG9tJ1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICByZXR1cm4gJ3RvcCdcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBvc1xuICB9XG59XG5mdW5jdGlvbiBpc0luVmlldyAoZWxlbWVudCwgdG9wLCBsZWZ0KSB7XG4gIGlmICggdG9wID09PSB2b2lkIDAgKSB0b3AgPSAwO1xuICBpZiAoIGxlZnQgPT09IHZvaWQgMCApIGxlZnQgPSAwO1xuICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICB2YXIgd2luID0gd2luZG93JDEoZWxlbWVudCk7XG4gIHJldHVybiBpbnRlcnNlY3RSZWN0KGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHtcbiAgICB0b3A6IHRvcCxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0KHdpbiksXG4gICAgcmlnaHQ6IGxlZnQgKyB3aWR0aCh3aW4pXG4gIH0pXG59XG5mdW5jdGlvbiB3aW5kb3ckMSAoZWxlbWVudCkge1xuICByZXR1cm4gaXNXaW5kb3coZWxlbWVudCkgPyBlbGVtZW50IDogZG9jdW1lbnQkMShlbGVtZW50KS5kZWZhdWx0Vmlld1xufVxuZnVuY3Rpb24gZG9jdW1lbnQkMSAoZWxlbWVudCkge1xuICByZXR1cm4gdG9Ob2RlKGVsZW1lbnQpLm93bmVyRG9jdW1lbnRcbn1cbmZ1bmN0aW9uIGRvY0VsIChlbGVtZW50KSB7XG4gIHJldHVybiBkb2N1bWVudCQxKGVsZW1lbnQpLmRvY3VtZW50RWxlbWVudFxufVxuXG52YXIgQkVGT1JFX1BPU0lUSU9OID0gJ3YtdmstcG9zaXRpb246YmVmb3JlJztcbnZhciBBRlRFUl9QT1NJVElPTiA9ICd2LXZrLXBvc2l0aW9uOmFmdGVyJztcblxudmFyIERpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgIHBvc2l0aW9uJDEoY3R4KTtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIHZhciBjdHggPSBnZXRDb250ZXh0KGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgaWYgKGN0eCkge1xuICAgICAgcG9zaXRpb24kMShjdHgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zaXRpb24kMSAoY3R4KSB7XG4gIHZhciBlbCA9IGN0eC5lbDtcbiAgdmFyIHByb3BzID0gY3R4LnByb3BzO1xuICB2YXIgdm5vZGUgPSBjdHgudm5vZGU7XG4gIHZhciB0YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gIHZhciBwb3NpdGlvbiQkMSA9IHByb3BzLnBvc2l0aW9uO1xuICB2YXIgb2Zmc2V0JCQxID0gcHJvcHMub2Zmc2V0O1xuICB2YXIgYm91bmRhcnkgPSBwcm9wcy5ib3VuZGFyeTtcbiAgdmFyIGZsaXAgPSBwcm9wcy5mbGlwO1xuICB2YXIgbWFpbkNsYXNzID0gcHJvcHMubWFpbkNsYXNzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhcG9zaXRpb24kJDEubWF0Y2goL14oKHRvcHxib3R0b20pLShsZWZ0fGNlbnRlcnxyaWdodCkpfCgobGVmdHxyaWdodCktKHRvcHxjZW50ZXJ8Ym90dG9tKSkkLykpIHtcbiAgICB3YXJuKChcInYtcG9zaXRpb24gLT4gJ1wiICsgcG9zaXRpb24kJDEgKyBcIicgLT4gbm8gdmFsaWQgcG9zaXRpb25cIiksIHZub2RlKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoIXRhcmdldCB8fCAhdGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgd2FybihcInYtcG9zaXRpb24gLT4gbm8gdmFsaWQgdGFyZ2V0XCIsIHZub2RlKTtcbiAgfVxuICB2YXIgcmVmID0gcG9zaXRpb24kJDEuc3BsaXQoJy0nKTtcbiAgdmFyIGRpciA9IHJlZlswXTtcbiAgdmFyIGFsaWduID0gcmVmWzFdO1xuICB0cmlnZ2VyKGVsLCBCRUZPUkVfUE9TSVRJT04pO1xuICB2YXIgY2xhc3Nlc1J4ID0gbmV3IFJlZ0V4cCgobWFpbkNsYXNzICsgXCItKHRvcHxib3R0b218bGVmdHxyaWdodCkoLVthLXpdKyk/XCIpKTtcbiAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UoY2xhc3Nlc1J4LCAnJyk7XG4gIGNzcyhlbCwgeyB0b3A6ICcnLCBsZWZ0OiAnJyB9KTtcbiAgdmFyIGF4aXMgPSBnZXRQb3NpdGlvbkF4aXMocG9zaXRpb24kJDEpO1xuICB2YXIgZWxBdHRhY2ggPSBheGlzID09PSAneCdcbiAgICA/ICgoZmxpcFBvc2l0aW9uKGRpcikpICsgXCIgXCIgKyBhbGlnbilcbiAgICA6IChhbGlnbiArIFwiIFwiICsgKGZsaXBQb3NpdGlvbihkaXIpKSk7XG4gIHZhciB0YXJnZXRBdHRhY2ggPSBheGlzID09PSAneCdcbiAgICA/IChkaXIgKyBcIiBcIiArIGFsaWduKVxuICAgIDogKGFsaWduICsgXCIgXCIgKyBkaXIpO1xuICB2YXIgZWxPZmZzZXQgPSBheGlzID09PSAneCdcbiAgICA/IChcIlwiICsgKGRpciA9PT0gJ2xlZnQnID8gLTEgKiBvZmZzZXQkJDEgOiBvZmZzZXQkJDEpKVxuICAgIDogKFwiIFwiICsgKGRpciA9PT0gJ3RvcCcgPyAtMSAqIG9mZnNldCQkMSA6IG9mZnNldCQkMSkpO1xuICB2YXIgdGFyZ2V0T2Zmc2V0ID0gbnVsbDtcbiAgdmFyIHJlZiQxID0gcG9zaXRpb25BdChcbiAgICBlbCxcbiAgICB0YXJnZXQsXG4gICAgZWxBdHRhY2gsXG4gICAgdGFyZ2V0QXR0YWNoLFxuICAgIGVsT2Zmc2V0LFxuICAgIHRhcmdldE9mZnNldCxcbiAgICBmbGlwLFxuICAgIGJvdW5kYXJ5XG4gICkudGFyZ2V0O1xuICB2YXIgeCA9IHJlZiQxLng7XG4gIHZhciB5ID0gcmVmJDEueTtcbiAgZGlyID0gYXhpcyA9PT0gJ3gnID8geCA6IHk7XG4gIGFsaWduID0gYXhpcyA9PT0gJ3gnID8geSA6IHg7XG4gIHRvZ2dsZUNsYXNzKGVsLCAobWFpbkNsYXNzICsgXCItXCIgKyBkaXIgKyBcIi1cIiArIGFsaWduKSwgb2Zmc2V0JCQxID09PSBmYWxzZSk7XG4gIHRyaWdnZXIoZWwsIEFGVEVSX1BPU0lUSU9OKTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbnMgKGN0eCkge1xuICB2YXIgdm5vZGUgPSBjdHgudm5vZGU7XG4gIHZhciByZWYgPSBjdHguYmluZGluZztcbiAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoaXNVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdCh2YWx1ZSkpKSB7XG4gICAgd2Fybigndi1wb3NpdGlvbiAtPiBjb25maWd1cmF0aW9uIGlzIG1pc3Npbmcgb3IgaXMgbm90IGFuIE9iamVjdCcsIHZub2RlLmNvbnRleHQpO1xuICB9XG4gIHZhciBvcHRpb25zID0gYXNzaWduKHtcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgcG9zaXRpb246ICd0b3AtY2VudGVyJyxcbiAgICBib3VuZGFyeTogd2luZG93LFxuICAgIGZsaXA6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICBtYWluQ2xhc3M6ICcnXG4gIH0sIHZhbHVlKTtcbiAgcmV0dXJuIG9wdGlvbnNcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICB2YXIgY3R4ID0geyBlbDogZWwsIGJpbmRpbmc6IGJpbmRpbmcsIHZub2RlOiB2bm9kZSB9O1xuICBjdHgucHJvcHMgPSBnZXRPcHRpb25zKGN0eCk7XG4gIGlmICghY3R4LnByb3BzKSB7XG4gICAgYmluZGluZy5kZWYudW5iaW5kKGVsLCBiaW5kaW5nKTtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gY3R4XG59XG5mdW5jdGlvbiBnZXRQb3NpdGlvbkF4aXMgKHBvc2l0aW9uJCQxKSB7XG4gIHZhciByZWYgPSBwb3NpdGlvbiQkMS5zcGxpdCgnLScpO1xuICB2YXIgZGlyID0gcmVmWzBdO1xuICByZXR1cm4gZGlyID09PSAndG9wJyB8fCBkaXIgPT09ICdib3R0b20nXG4gICAgPyAneSdcbiAgICA6ICd4J1xufVxuXG52YXIgRXZlbnRzTWl4aW4gPSB7XG4gIG1ldGhvZHM6IHtcbiAgICBvbjogZnVuY3Rpb24gb24kMSAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgICAgIHRoaXMuX3ZrX2V2ZW50c19vZmYucHVzaChvbi5hcHBseSh2b2lkIDAsIGFyZ3MpKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmJDEgKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICBvZmYuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuX3ZrX2V2ZW50c19vZmYgPSBbXTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5fdmtfZXZlbnRzX29mZi5mb3JFYWNoKGZ1bmN0aW9uIChvZmYkJDEpIHsgcmV0dXJuIG9mZiQkMSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiAkIChzZWxlY3RvciwgY29udGV4dCkge1xuICByZXR1cm4gIWlzU3RyaW5nKHNlbGVjdG9yKVxuICAgID8gdG9Ob2RlKHNlbGVjdG9yKVxuICAgIDogaXNIdG1sKHNlbGVjdG9yKVxuICAgICAgPyB0b05vZGUoZnJhZ21lbnQoc2VsZWN0b3IpKVxuICAgICAgOiBmaW5kKHNlbGVjdG9yLCBjb250ZXh0KVxufVxuZnVuY3Rpb24gJCQgKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gIHJldHVybiAhaXNTdHJpbmcoc2VsZWN0b3IpXG4gICAgPyB0b05vZGVzKHNlbGVjdG9yKVxuICAgIDogaXNIdG1sKHNlbGVjdG9yKVxuICAgICAgPyB0b05vZGVzKGZyYWdtZW50KHNlbGVjdG9yKSlcbiAgICAgIDogZmluZEFsbChzZWxlY3RvciwgY29udGV4dClcbn1cbmZ1bmN0aW9uIGlzSHRtbCAoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0gPT09ICc8JyB8fCBzdHIubWF0Y2goL15cXHMqPC8pXG59XG5cbmZ1bmN0aW9uIE1vdXNlVHJhY2tlciAoKSB7fVxuTW91c2VUcmFja2VyLnByb3RvdHlwZSA9IHtcbiAgcG9zaXRpb25zOiBbXSxcbiAgcG9zaXRpb246IG51bGwsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHRoaXMucG9zaXRpb25zID0gW107XG4gICAgdGhpcy5wb3NpdGlvbiA9IG51bGw7XG4gICAgdmFyIHRpY2tpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnVuYmluZCA9IG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aWNraW5nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMkMS5wb3NpdGlvbnM7XG4gICAgICAgIHZhciBsZW5ndGggPSByZWYubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoICYmICh0aW1lIC0gdGhpcyQxLnBvc2l0aW9uc1tsZW5ndGggLSAxXS50aW1lID4gMTAwKSkge1xuICAgICAgICAgIHRoaXMkMS5wb3NpdGlvbnMuc3BsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcyQxLnBvc2l0aW9ucy5wdXNoKHt0aW1lOiB0aW1lLCB4OiBlLnBhZ2VYLCB5OiBlLnBhZ2VZfSk7XG4gICAgICAgIGlmICh0aGlzJDEucG9zaXRpb25zLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICB0aGlzJDEucG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgfSwgNSk7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSxcbiAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwgKCkge1xuICAgIGlmICh0aGlzLnVuYmluZCkge1xuICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gIH0sXG4gIG1vdmVzVG86IGZ1bmN0aW9uIG1vdmVzVG8gKHRhcmdldCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdmFyIHAgPSBvZmZzZXQodGFyZ2V0KTtcbiAgICB2YXIgcG9zaXRpb24kJDEgPSB0aGlzLnBvc2l0aW9uc1t0aGlzLnBvc2l0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcmVmID0gdGhpcy5wb3NpdGlvbnM7XG4gICAgdmFyIHByZXZQb3MgPSByZWZbMF07XG4gICAgaWYgKHAubGVmdCA8PSBwb3NpdGlvbiQkMS54ICYmIHBvc2l0aW9uJCQxLnggPD0gcC5yaWdodCAmJiBwLnRvcCA8PSBwb3NpdGlvbiQkMS55ICYmIHBvc2l0aW9uJCQxLnkgPD0gcC5ib3R0b20pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgW3t4OiBwLmxlZnQsIHk6IHAudG9wfSwge3g6IHAucmlnaHQsIHk6IHAuYm90dG9tfV0sXG4gICAgICBbe3g6IHAucmlnaHQsIHk6IHAudG9wfSwge3g6IHAubGVmdCwgeTogcC5ib3R0b219XVxuICAgIF07XG4gICAgaWYgKHAucmlnaHQgPD0gcG9zaXRpb24kJDEueCkge1xuICAgIH0gZWxzZSBpZiAocC5sZWZ0ID49IHBvc2l0aW9uJCQxLngpIHtcbiAgICAgIHBvaW50c1swXS5yZXZlcnNlKCk7XG4gICAgICBwb2ludHNbMV0ucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSBpZiAocC5ib3R0b20gPD0gcG9zaXRpb24kJDEueSkge1xuICAgICAgcG9pbnRzWzBdLnJldmVyc2UoKTtcbiAgICB9IGVsc2UgaWYgKHAudG9wID49IHBvc2l0aW9uJCQxLnkpIHtcbiAgICAgIHBvaW50c1sxXS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiAhIXBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcG9pbnQpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoc2xvcGUocHJldlBvcywgcG9pbnRbMF0pIDwgc2xvcGUocG9zaXRpb24kJDEsIHBvaW50WzBdKSAmJiBzbG9wZShwcmV2UG9zLCBwb2ludFsxXSkgPiBzbG9wZShwb3NpdGlvbiQkMSwgcG9pbnRbMV0pKVxuICAgIH0sIDApXG4gIH1cbn07XG5mdW5jdGlvbiBzbG9wZSAoYSwgYikge1xuICByZXR1cm4gKGIueSAtIGEueSkgLyAoYi54IC0gYS54KVxufVxuXG52YXIgZG9jJDEgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50O1xudmFyIHdpbiQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93O1xudmFyIG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvcjtcbnZhciBpc1J0bCA9IGRvYyQxICYmIGF0dHIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnZGlyJykgPT09ICdydGwnO1xudmFyIGhhc1RvdWNoRXZlbnRzID0gd2luJDEgJiYgJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xudmFyIGhhc1BvaW50ZXJFdmVudHMgPSB3aW4kMSAmJiB3aW5kb3cuUG9pbnRlckV2ZW50O1xudmFyIGhhc1RvdWNoID0gaGFzVG91Y2hFdmVudHMgfHxcbiAgKHdpbiQxICYmIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSAmJiAoZG9jJDEgJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCkgfHxcbiAgbmF2ICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cztcbnZhciBwb2ludGVyRG93biA9ICFoYXNUb3VjaCA/ICdtb3VzZWRvd24nIDogKFwibW91c2Vkb3duIFwiICsgKGhhc1RvdWNoRXZlbnRzID8gJ3RvdWNoc3RhcnQnIDogJ3BvaW50ZXJkb3duJykpO1xudmFyIHBvaW50ZXJNb3ZlID0gIWhhc1RvdWNoID8gJ21vdXNlbW92ZScgOiAoXCJtb3VzZW1vdmUgXCIgKyAoaGFzVG91Y2hFdmVudHMgPyAndG91Y2htb3ZlJyA6ICdwb2ludGVybW92ZScpKTtcbnZhciBwb2ludGVyVXAgPSAhaGFzVG91Y2ggPyAnbW91c2V1cCcgOiAoXCJtb3VzZXVwIFwiICsgKGhhc1RvdWNoRXZlbnRzID8gJ3RvdWNoZW5kJyA6ICdwb2ludGVydXAnKSk7XG52YXIgcG9pbnRlckVudGVyID0gaGFzVG91Y2ggJiYgaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyZW50ZXInIDogJ21vdXNlZW50ZXInO1xudmFyIHBvaW50ZXJMZWF2ZSA9IGhhc1RvdWNoICYmIGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmxlYXZlJyA6ICdtb3VzZWxlYXZlJztcblxudmFyIHByb3BzJDEgPSB7XG4gIHRhcmdldDoge30sXG4gIGJvdW5kYXJ5OiB7fSxcbiAgYm91bmRhcnlBbGlnbjoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgZmxpcDoge1xuICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgcG9zaXRpb246IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogKFwiYm90dG9tLVwiICsgKGlzUnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JykpLFxuICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gL14odG9wfGJvdHRvbSktKGxlZnR8cmlnaHR8Y2VudGVyfGp1c3RpZnkpJC8udGVzdChwb3MpIHx8XG4gICAgICAvXihsZWZ0fHJpZ2h0KS0odG9wfGJvdHRvbXxjZW50ZXJ8anVzdGlmeSkkLy50ZXN0KHBvcyk7IH1cbiAgfSxcbiAgb2Zmc2V0OiB7XG4gICAgdHlwZTogW0Jvb2xlYW4sIE51bWJlcl0sXG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgYW5pbWF0aW9uOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6ICdmYWRlJ1xuICB9LFxuICBkdXJhdGlvbjoge1xuICAgIHR5cGU6IE51bWJlcixcbiAgICBkZWZhdWx0OiAyMDBcbiAgfSxcbiAgbW9kZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiAnY2xpY2sgaG92ZXInXG4gIH0sXG4gIGRlbGF5U2hvdzoge1xuICAgIHR5cGU6IE51bWJlcixcbiAgICBkZWZhdWx0OiAwXG4gIH0sXG4gIGRlbGF5SGlkZToge1xuICAgIHR5cGU6IE51bWJlcixcbiAgICBkZWZhdWx0OiA4MDBcbiAgfSxcbiAgbWFpbkNsYXNzOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6ICd1ay1kcm9wJ1xuICB9XG59XG5cbnZhciBFbGVtZW50RHJvcCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBzaG93OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHNob3cgPSBwcm9wcy5zaG93O1xuICAgIHJldHVybiBoKCdkaXYnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ3VrLW9wZW4nOiBzaG93XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc2hvdyA/ICdibG9jaycgOiBudWxsXG4gICAgICB9XG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciB3aW4kMiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbnZhciBQcm9taXNlID0gd2luJDIgJiYgJ1Byb21pc2UnIGluIHdpbmRvdyA/IHdpbmRvdy5Qcm9taXNlIDogUHJvbWlzZUZuO1xudmFyIFJFU09MVkVEID0gMDtcbnZhciBSRUpFQ1RFRCA9IDE7XG52YXIgUEVORElORyA9IDI7XG52YXIgYXN5bmMgPSB3aW4kMiAmJiAnc2V0SW1tZWRpYXRlJyBpbiB3aW5kb3cgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0O1xuZnVuY3Rpb24gUHJvbWlzZUZuIChleGVjdXRvcikge1xuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5kZWZlcnJlZCA9IFtdO1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHRyeSB7XG4gICAgZXhlY3V0b3IoXG4gICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICBwcm9taXNlLnJlc29sdmUoeCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb21pc2UucmVqZWN0KGUpO1xuICB9XG59XG5Qcm9taXNlRm4ucmVqZWN0ID0gZnVuY3Rpb24gKHIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlRm4oZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdChyKTtcbiAgfSlcbn07XG5Qcm9taXNlRm4ucmVzb2x2ZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUZuKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXNvbHZlKHgpO1xuICB9KVxufTtcblByb21pc2VGbi5hbGwgPSBmdW5jdGlvbiBhbGwgKGl0ZXJhYmxlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUZuKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBpZiAoaXRlcmFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVyIChpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmVzdWx0W2ldID0geDtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgUHJvbWlzZUZuLnJlc29sdmUoaXRlcmFibGVbaV0pLnRoZW4ocmVzb2x2ZXIoaSksIHJlamVjdCk7XG4gICAgfVxuICB9KVxufTtcblByb21pc2VGbi5yYWNlID0gZnVuY3Rpb24gcmFjZSAoaXRlcmFibGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlRm4oZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIFByb21pc2VGbi5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KVxufTtcbnZhciBwID0gUHJvbWlzZUZuLnByb3RvdHlwZTtcbnAucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKHgpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUEVORElORykge1xuICAgIGlmICh4ID09PSBwcm9taXNlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIHNldHRsZWQgd2l0aCBpdHNlbGYuJylcbiAgICB9XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHggJiYgeC50aGVuO1xuICAgICAgaWYgKHggIT09IG51bGwgJiYgaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgeCxcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBwcm9taXNlLnN0YXRlID0gUkVTT0xWRUQ7XG4gICAgcHJvbWlzZS52YWx1ZSA9IHg7XG4gICAgcHJvbWlzZS5ub3RpZnkoKTtcbiAgfVxufTtcbnAucmVqZWN0ID0gZnVuY3Rpb24gcmVqZWN0IChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUEVORElORykge1xuICAgIGlmIChyZWFzb24gPT09IHByb21pc2UpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2Ugc2V0dGxlZCB3aXRoIGl0c2VsZi4nKVxuICAgIH1cbiAgICBwcm9taXNlLnN0YXRlID0gUkVKRUNURUQ7XG4gICAgcHJvbWlzZS52YWx1ZSA9IHJlYXNvbjtcbiAgICBwcm9taXNlLm5vdGlmeSgpO1xuICB9XG59O1xucC5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgYXN5bmMoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzJDEuc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgIHdoaWxlICh0aGlzJDEuZGVmZXJyZWQubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzJDEuZGVmZXJyZWQuc2hpZnQoKTtcbiAgICAgICAgdmFyIG9uUmVzb2x2ZWQgPSByZWZbMF07XG4gICAgICAgIHZhciBvblJlamVjdGVkID0gcmVmWzFdO1xuICAgICAgICB2YXIgcmVzb2x2ZSA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlamVjdCA9IHJlZlszXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcyQxLnN0YXRlID09PSBSRVNPTFZFRCkge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25SZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShvblJlc29sdmVkLmNhbGwodW5kZWZpbmVkLCB0aGlzJDEudmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyQxLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMkMS5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUob25SZWplY3RlZC5jYWxsKHVuZGVmaW5lZCwgdGhpcyQxLnZhbHVlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QodGhpcyQxLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbnAudGhlbiA9IGZ1bmN0aW9uIHRoZW4gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZUZuKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB0aGlzJDEuZGVmZXJyZWQucHVzaChbb25SZXNvbHZlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgdGhpcyQxLm5vdGlmeSgpO1xuICB9KVxufTtcbnAuY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZClcbn07XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb24gKGVsZW1lbnQsIHByb3BzLCBkdXJhdGlvbiwgdGltaW5nKSB7XG4gIGlmICggZHVyYXRpb24gPT09IHZvaWQgMCApIGR1cmF0aW9uID0gNDAwO1xuICBpZiAoIHRpbWluZyA9PT0gdm9pZCAwICkgdGltaW5nID0gJ2xpbmVhcic7XG4gIHJldHVybiBQcm9taXNlLmFsbCh0b05vZGVzKGVsZW1lbnQpLm1hcChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICB2YXIgdmFsdWUgPSBjc3MoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICBjc3MoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKTsgfSwgZHVyYXRpb24pO1xuICAgICAgb25jZShlbGVtZW50LCAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsZWQnLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsICd1ay10cmFuc2l0aW9uJyk7XG4gICAgICAgIGNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnJyxcbiAgICAgICAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6ICcnLFxuICAgICAgICAgICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbic6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICB0eXBlID09PSAndHJhbnNpdGlvbmNhbmNlbGVkJyA/IHJlamVjdCgpIDogcmVzb2x2ZSgpO1xuICAgICAgfSwgZmFsc2UsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHJlZi50YXJnZXQ7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID09PSB0YXJnZXQ7XG4gICAgICB9KTtcbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsICd1ay10cmFuc2l0aW9uJyk7XG4gICAgICBjc3MoZWxlbWVudCwgYXNzaWduKHtcbiAgICAgICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiBPYmplY3Qua2V5cyhwcm9wcykubWFwKHByb3BOYW1lKS5qb2luKCcsJyksXG4gICAgICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogKGR1cmF0aW9uICsgXCJtc1wiKSxcbiAgICAgICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogdGltaW5nXG4gICAgICB9LCBwcm9wcykpO1xuICAgIH0pOyB9XG4gICkpXG59XG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgc3RhcnQ6IHRyYW5zaXRpb24sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AgKGVsZW1lbnQpIHtcbiAgICB0cmlnZ2VyKGVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH0sXG4gIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsIChlbGVtZW50KSB7XG4gICAgdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmNhbmNlbGVkJyk7XG4gIH0sXG4gIGluUHJvZ3Jlc3M6IGZ1bmN0aW9uIGluUHJvZ3Jlc3MgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaGFzQ2xhc3MoZWxlbWVudCwgJ3VrLXRyYW5zaXRpb24nKVxuICB9XG59O1xudmFyIGFuaW1hdGlvblByZWZpeCA9ICd1ay1hbmltYXRpb24tJztcbnZhciBjbHNDYW5jZWxBbmltYXRpb24gPSAndWstY2FuY2VsLWFuaW1hdGlvbic7XG5mdW5jdGlvbiBhbmltYXRlIChlbGVtZW50LCBhbmltYXRpb24sIGR1cmF0aW9uLCBvcmlnaW4sIG91dCkge1xuICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG4gIGlmICggZHVyYXRpb24gPT09IHZvaWQgMCApIGR1cmF0aW9uID0gMjAwO1xuICByZXR1cm4gUHJvbWlzZS5hbGwodG9Ob2RlcyhlbGVtZW50KS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChoYXNDbGFzcyhlbGVtZW50LCBjbHNDYW5jZWxBbmltYXRpb24pKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGUuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMkMSkudGhlbihyZXNvbHZlLCByZWplY3QpOyB9XG4gICAgICAgICAgKTsgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjbHMgPSBhbmltYXRpb24gKyBcIiBcIiArIGFuaW1hdGlvblByZWZpeCArIChvdXQgPyAnbGVhdmUnIDogJ2VudGVyJyk7XG4gICAgICBpZiAoc3RhcnRzV2l0aChhbmltYXRpb24sIGFuaW1hdGlvblByZWZpeCkpIHtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgIGNscyArPSBcIiB1ay10cmFuc2Zvcm0tb3JpZ2luLVwiICsgb3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICBjbHMgKz0gXCIgXCIgKyBhbmltYXRpb25QcmVmaXggKyBcInJldmVyc2VcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzZXQoKTtcbiAgICAgIG9uY2UoZWxlbWVudCwgJ2FuaW1hdGlvbmVuZCBhbmltYXRpb25jYW5jZWwnLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgICAgIHZhciBoYXNSZXNldCA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2FuaW1hdGlvbmNhbmNlbCcpIHtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhhc1Jlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1Jlc2V0KSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBjbHNDYW5jZWxBbmltYXRpb24pO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsc0NhbmNlbEFuaW1hdGlvbik7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBmYWxzZSwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gcmVmLnRhcmdldDtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IHRhcmdldDtcbiAgICAgIH0pO1xuICAgICAgY3NzKGVsZW1lbnQsICdhbmltYXRpb25EdXJhdGlvbicsIChkdXJhdGlvbiArIFwibXNcIikpO1xuICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgY2xzKTtcbiAgICAgIGZ1bmN0aW9uIHJlc2V0ICgpIHtcbiAgICAgICAgY3NzKGVsZW1lbnQsICdhbmltYXRpb25EdXJhdGlvbicsICcnKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCAoYW5pbWF0aW9uUHJlZml4ICsgXCJcXFxcUypcIikpO1xuICAgICAgfVxuICAgIH0pOyB9XG4gICkpXG59XG52YXIgaW5Qcm9ncmVzcyA9IG5ldyBSZWdFeHAoKGFuaW1hdGlvblByZWZpeCArIFwiKGVudGVyfGxlYXZlKVwiKSk7XG52YXIgQW5pbWF0aW9uID0ge1xuICBpbjogZnVuY3Rpb24gaW4kMSAoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luKSB7XG4gICAgcmV0dXJuIGFuaW1hdGUoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luLCBmYWxzZSlcbiAgfSxcbiAgb3V0OiBmdW5jdGlvbiBvdXQgKGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbikge1xuICAgIHJldHVybiBhbmltYXRlKGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbiwgdHJ1ZSlcbiAgfSxcbiAgaW5Qcm9ncmVzczogZnVuY3Rpb24gaW5Qcm9ncmVzcyQxIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGluUHJvZ3Jlc3MudGVzdChhdHRyKGVsZW1lbnQsICdjbGFzcycpKVxuICB9LFxuICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCAoZWxlbWVudCkge1xuICAgIHRyaWdnZXIoZWxlbWVudCwgJ2FuaW1hdGlvbmNhbmNlbCcpO1xuICB9XG59O1xuXG52YXIgVHJhbnNpdGlvbiQxID0ge1xuICBuYW1lOiAnVmtUcmFuc2l0aW9uJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgZHVyYXRpb246IHtcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG4gICAgbW9kZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ291dC1pbidcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uO1xuICAgIHZhciByZWYkMSA9IGlzU3RyaW5nKG5hbWUpID8gW25hbWUsIG5hbWVdIDogbmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uSW4gPSByZWYkMVswXTtcbiAgICB2YXIgYW5pbWF0aW9uT3V0ID0gcmVmJDFbMV07XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNzczogZmFsc2UsXG4gICAgICAgIG1vZGU6IHByb3BzLm1vZGVcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIgKGVsLCBkb25lKSB7XG4gICAgICAgICAgYW5pbWF0aW9uSW5cbiAgICAgICAgICAgID8gQW5pbWF0aW9uLmluKGVsLCAoXCJ1ay1hbmltYXRpb24tXCIgKyBhbmltYXRpb25JbiksIGR1cmF0aW9uKS50aGVuKGRvbmUpXG4gICAgICAgICAgICA6IGRvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlIChlbCwgZG9uZSkge1xuICAgICAgICAgIGFuaW1hdGlvbk91dFxuICAgICAgICAgICAgPyBBbmltYXRpb24ub3V0KGVsLCAoXCJ1ay1hbmltYXRpb24tXCIgKyBhbmltYXRpb25PdXQpLCBkdXJhdGlvbikudGhlbihkb25lKVxuICAgICAgICAgICAgOiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoKCd0cmFuc2l0aW9uJywgZGVmLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgcmVuZGVyID0ge1xuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB0aGlzLiRyZWZzLnRhcmdldCA9IHRoaXMucXVlcnlFbGVtZW50KHRoaXMudGFyZ2V0KSB8fCB0aGlzLiRlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIHRoaXMuJHJlZnMuYm91bmRhcnkgPSB0aGlzLnF1ZXJ5RWxlbWVudCh0aGlzLmJvdW5kYXJ5KSB8fCB3aW5kb3c7XG4gICAgdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgb2JqLCBvYmokMTtcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgcG9zaXRpb24kJDEgPSByZWYucG9zaXRpb247XG4gICAgdmFyIHJlZiQxID0gdGhpcy4kcmVmcztcbiAgICB2YXIgYm91bmRhcnkgPSByZWYkMS5ib3VuZGFyeTtcbiAgICB2YXIgdGFyZ2V0ID0gcmVmJDEudGFyZ2V0O1xuICAgIHZhciByZWYkMiA9IHBvc2l0aW9uJCQxLnNwbGl0KCctJyk7XG4gICAgdmFyIGFsaWduID0gcmVmJDJbMV07XG4gICAgdmFyIHJlZiQzID0gdGhpcztcbiAgICB2YXIgYm91bmRhcnlBbGlnbiA9IHJlZiQzLmJvdW5kYXJ5QWxpZ247XG4gICAgdmFyIGFuaW1hdGlvbiA9IHJlZiQzLmFuaW1hdGlvbjtcbiAgICB2YXIgZHVyYXRpb24gPSByZWYkMy5kdXJhdGlvbjtcbiAgICB2YXIgbWFpbkNsYXNzID0gcmVmJDMubWFpbkNsYXNzO1xuICAgIHZhciBmbGlwID0gcmVmJDMuZmxpcDtcbiAgICB2YXIgb2Zmc2V0JCQxID0gcmVmJDMub2Zmc2V0O1xuICAgIGlmICghdGFyZ2V0IHx8ICFib3VuZGFyeSkgeyByZXR1cm4gfVxuICAgIHBvc2l0aW9uJCQxID0gcG9zaXRpb24kJDEucmVwbGFjZSgnanVzdGlmeScsICdjZW50ZXInKTtcbiAgICB0YXJnZXQgPSBib3VuZGFyeUFsaWduID8gYm91bmRhcnkgOiB0YXJnZXQ7XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgIG9uOiAoIG9iaiA9IHt9LCBvYmpbQkVGT1JFX1BPU0lUSU9OXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IHRoaXMkMTtcbiAgICAgICAgICB2YXIgJGVsID0gcmVmLiRlbDtcbiAgICAgICAgICB2YXIgYWxpZ25UbyA9IG9mZnNldCh0YXJnZXQpO1xuICAgICAgICAgIHZhciBib3VuZGFyeU9mZnNldCA9IG9mZnNldChib3VuZGFyeSk7XG4gICAgICAgICAgY3NzKCRlbCwgeyB3aWR0aDogJycsIGhlaWdodDogJycgfSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoJGVsLCAobWFpbkNsYXNzICsgXCItc3RhY2tcIikpO1xuICAgICAgICAgIGlmIChhbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IGdldEF4aXMocG9zaXRpb24kJDEpID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgICAgICBjc3MoJGVsLCBwcm9wLCBhbGlnblRvW3Byb3BdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRlbC5vZmZzZXRXaWR0aCA+IE1hdGgubWF4KGJvdW5kYXJ5T2Zmc2V0LnJpZ2h0IC0gYWxpZ25Uby5sZWZ0LCBhbGlnblRvLnJpZ2h0IC0gYm91bmRhcnlPZmZzZXQubGVmdCkpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKCRlbCwgKG1haW5DbGFzcyArIFwiLXN0YWNrXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9iaiksXG4gICAgICBwcm9wczoge1xuICAgICAgICBzaG93OiB0aGlzLnNob3duXG4gICAgICB9LFxuICAgICAgY2xhc3M6IFttYWluQ2xhc3MsICggb2JqJDEgPSB7fSwgb2JqJDFbKG1haW5DbGFzcyArIFwiLWJvdW5kYXJ5XCIpXSA9IHRoaXMuYm91bmRhcnlBbGlnbiwgb2JqJDEpXSxcbiAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzaG93JyxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5zaG93blxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3ZrLXBvc2l0aW9uJyxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZmxpcDogZmxpcCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0JCQxLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24kJDEsXG4gICAgICAgICAgICBtYWluQ2xhc3M6IG1haW5DbGFzc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbiQxLCB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBuYW1lOiBbYW5pbWF0aW9uXSxcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgICB9XG4gICAgfSwgW1xuICAgICAgaChFbGVtZW50RHJvcCwgZGVmLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICAgIF0pXG4gIH1cbn1cbmZ1bmN0aW9uIGdldEF4aXMgKHBvc2l0aW9uJCQxKSB7XG4gIHZhciByZWYgPSBwb3NpdGlvbiQkMS5zcGxpdCgnLScpO1xuICB2YXIgZGlyID0gcmVmWzBdO1xuICByZXR1cm4gZGlyID09PSAndG9wJyB8fCBkaXIgPT09ICdib3R0b20nXG4gICAgPyAneSdcbiAgICA6ICd4J1xufVxuXG52YXIgU0hPVyA9ICdzaG93JztcbnZhciBISURFID0gJ2hpZGUnO1xuXG52YXIgdG91Y2ggPSB7fSwgY2xpY2tUaW1lb3V0LCBzd2lwZVRpbWVvdXQsIHRhcFRpbWVvdXQsIGNsaWNrZWQ7XG5mdW5jdGlvbiBzd2lwZURpcmVjdGlvbiAocmVmKSB7XG4gIHZhciB4MSA9IHJlZi54MTtcbiAgdmFyIHgyID0gcmVmLngyO1xuICB2YXIgeTEgPSByZWYueTE7XG4gIHZhciB5MiA9IHJlZi55MjtcbiAgcmV0dXJuIE1hdGguYWJzKHgxIC0geDIpID49IE1hdGguYWJzKHkxIC0geTIpID8gKHgxIC0geDIgPiAwID8gJ0xlZnQnIDogJ1JpZ2h0JykgOiAoeTEgLSB5MiA+IDAgPyAnVXAnIDogJ0Rvd24nKVxufVxuZnVuY3Rpb24gY2FuY2VsQWxsICgpIHtcbiAgY2xpY2tUaW1lb3V0ICYmIGNsZWFyVGltZW91dChjbGlja1RpbWVvdXQpO1xuICBzd2lwZVRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHN3aXBlVGltZW91dCk7XG4gIHRhcFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRhcFRpbWVvdXQpO1xuICBjbGlja1RpbWVvdXQgPSBzd2lwZVRpbWVvdXQgPSB0YXBUaW1lb3V0ID0gbnVsbDtcbiAgdG91Y2ggPSB7fTtcbn1cbnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgb24oZG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWNrZWQgPSB0cnVlOyB9LCB0cnVlKTtcbiAgb24oZG9jdW1lbnQsIHBvaW50ZXJEb3duLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICB2YXIgcmVmID0gZ2V0UG9zJDEoZSk7XG4gICAgdmFyIHggPSByZWYueDtcbiAgICB2YXIgeSA9IHJlZi55O1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZShlLnR5cGUpO1xuICAgIGlmICh0b3VjaC50eXBlICYmIHRvdWNoLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0b3VjaC5lbCA9ICd0YWdOYW1lJyBpbiB0YXJnZXQgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICBjbGlja1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KGNsaWNrVGltZW91dCk7XG4gICAgdG91Y2gueDEgPSB4O1xuICAgIHRvdWNoLnkxID0geTtcbiAgICBpZiAodG91Y2gubGFzdCAmJiBub3cgLSB0b3VjaC5sYXN0IDw9IDI1MCkge1xuICAgICAgdG91Y2ggPSB7fTtcbiAgICB9XG4gICAgdG91Y2gudHlwZSA9IHR5cGU7XG4gICAgdG91Y2gubGFzdCA9IG5vdztcbiAgICBjbGlja2VkID0gZS5idXR0b24gPiAwO1xuICB9KTtcbiAgb24oZG9jdW1lbnQsIHBvaW50ZXJNb3ZlLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcmVmID0gZ2V0UG9zJDEoZSk7XG4gICAgdmFyIHggPSByZWYueDtcbiAgICB2YXIgeSA9IHJlZi55O1xuICAgIHRvdWNoLngyID0geDtcbiAgICB0b3VjaC55MiA9IHk7XG4gIH0pO1xuICBvbihkb2N1bWVudCwgcG9pbnRlclVwLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgdGFyZ2V0ID0gcmVmLnRhcmdldDtcbiAgICBpZiAodG91Y2gudHlwZSAhPT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0b3VjaC54MiAmJiBNYXRoLmFicyh0b3VjaC54MSAtIHRvdWNoLngyKSA+IDMwIHx8IHRvdWNoLnkyICYmIE1hdGguYWJzKHRvdWNoLnkxIC0gdG91Y2gueTIpID4gMzApIHtcbiAgICAgIHN3aXBlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodG91Y2guZWwpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRvdWNoLmVsLCAnc3dpcGUnKTtcbiAgICAgICAgICB0cmlnZ2VyKHRvdWNoLmVsLCAoXCJzd2lwZVwiICsgKHN3aXBlRGlyZWN0aW9uKHRvdWNoKSkpKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaCA9IHt9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgnbGFzdCcgaW4gdG91Y2gpIHtcbiAgICAgIHRhcFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyaWdnZXIodG91Y2guZWwsICd0YXAnKTsgfSk7XG4gICAgICBpZiAodG91Y2guZWwgJiYgdHlwZSAhPT0gJ21vdXNldXAnICYmIHdpdGhpbih0YXJnZXQsIHRvdWNoLmVsKSkge1xuICAgICAgICBjbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGlmICh0b3VjaC5lbCAmJiAhY2xpY2tlZCkge1xuICAgICAgICAgICAgdHJpZ2dlcih0b3VjaC5lbCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdWNoID0ge307XG4gICAgICAgIH0sIDM1MCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvdWNoID0ge307XG4gICAgfVxuICB9KTtcbiAgb24oZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIGNhbmNlbEFsbCk7XG4gIG9uKHdpbmRvdywgJ3Njcm9sbCcsIGNhbmNlbEFsbCk7XG59KTtcbnZhciB0b3VjaGluZyA9IGZhbHNlO1xuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgb24oZG9jdW1lbnQsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdG91Y2hpbmcgPSB0cnVlOyB9LCB0cnVlKTtcbiAgb24oZG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uICgpIHsgdG91Y2hpbmcgPSBmYWxzZTsgfSk7XG4gIG9uKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0b3VjaGluZyA9IGZhbHNlOyB9LCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGlzVG91Y2ggKGUpIHtcbiAgcmV0dXJuIHRvdWNoaW5nIHx8IGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCdcbn1cbmZ1bmN0aW9uIGdldFBvcyQxIChlKSB7XG4gIHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuICB2YXIgcmVmID0gdG91Y2hlcyAmJiB0b3VjaGVzWzBdIHx8IGNoYW5nZWRUb3VjaGVzICYmIGNoYW5nZWRUb3VjaGVzWzBdIHx8IGU7XG4gIHZhciB4ID0gcmVmLnBhZ2VYO1xuICB2YXIgeSA9IHJlZi5wYWdlWTtcbiAgcmV0dXJuIHt4OiB4LCB5OiB5fVxufVxuZnVuY3Rpb24gZ2V0VHlwZSAodHlwZSkge1xuICByZXR1cm4gdHlwZS5zbGljZSgwLCA1KVxufVxuXG52YXIgYWN0aXZlO1xuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgb24od2luZG93LCAncmVzaXplJywgZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gcmVmLmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgdmFyIGp1c3RpZmllZCA9IGFjdGl2ZSAmJiAvanVzdGlmeS8udGVzdChhY3RpdmUucG9zaXRpb24pO1xuICAgIGlmICghZGVmYXVsdFByZXZlbnRlZCAmJiBqdXN0aWZpZWQpIHtcbiAgICAgIGFjdGl2ZS4kZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gIH0pO1xuICBvbihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgdGFyZ2V0ID0gcmVmLnRhcmdldDtcbiAgICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IHJlZi5kZWZhdWx0UHJldmVudGVkO1xuICAgIGlmIChkZWZhdWx0UHJldmVudGVkIHx8ICFhY3RpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgY2xpY2tlZEluc2lkZSA9IGZ1bmN0aW9uIChkcm9wKSB7IHJldHVybiB3aXRoaW4odGFyZ2V0LCBkcm9wLiRlbCk7IH07XG4gICAgdmFyIGNsaWNrZWRUYXJnZXQgPSBmdW5jdGlvbiAoZHJvcCkgeyByZXR1cm4gd2l0aGluKHRhcmdldCwgZHJvcC4kcmVmcy50YXJnZXQpOyB9O1xuICAgIHdoaWxlIChhY3RpdmUgJiYgIWNsaWNrZWRJbnNpZGUoYWN0aXZlKSAmJiAhY2xpY2tlZFRhcmdldChhY3RpdmUpKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZmluZFBhcmVudChhY3RpdmUpO1xuICAgICAgYWN0aXZlLl9oaWRlKCk7XG4gICAgICBhY3RpdmUgPSBwYXJlbnQ7XG4gICAgfVxuICB9KTtcbn1cbnZhciB0b2dnbGUgPSB7XG4gIGRhdGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgc2hvd246IGZhbHNlXG4gIH0pOyB9LFxuICBtZXRob2RzOiB7XG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fc2hvdywgdGhpcy5kZWxheVNob3cpO1xuICAgIH0sXG4gICAgX3Nob3c6IGZ1bmN0aW9uIF9zaG93ICgpIHtcbiAgICAgIHdoaWxlIChhY3RpdmUgJiYgIXRoaXMuaXNDaGlsZE9mKGFjdGl2ZSkgJiYgIXRoaXMuaXNQYXJlbnRPZihhY3RpdmUpKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBmaW5kUGFyZW50KGFjdGl2ZSk7XG4gICAgICAgIGFjdGl2ZS5faGlkZSgpO1xuICAgICAgICBhY3RpdmUgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNob3duID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJhY2tlci5pbml0KCk7XG4gICAgICBhY3RpdmUgPSB0aGlzO1xuICAgICAgdGhpcy4kZW1pdChTSE9XKTtcbiAgICB9LFxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUgKCkge1xuICAgICAgdmFyIGhvdmVySWRsZSA9IDIwMDtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgIHRoaXMuaXNEZWxheWluZyA9IHRoaXMudHJhY2tlci5tb3Zlc1RvKHRoaXMuJGVsKTtcbiAgICAgIGlmICh0aGlzLmlzRGVsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZSwgaG92ZXJJZGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlkZVRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9oaWRlLCB0aGlzLmRlbGF5SGlkZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfaGlkZTogZnVuY3Rpb24gX2hpZGUgKCkge1xuICAgICAgdGhpcy5zaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy50cmFja2VyLmNhbmNlbCgpO1xuICAgICAgaWYgKGFjdGl2ZSA9PT0gdGhpcykge1xuICAgICAgICB2YXIgcGFyZW50ID0gZmluZFBhcmVudChhY3RpdmUpO1xuICAgICAgICBhY3RpdmUgPSBwYXJlbnQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuJGVtaXQoSElERSk7XG4gICAgfSxcbiAgICBjbGVhclRpbWVyczogZnVuY3Rpb24gY2xlYXJUaW1lcnMgKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVyKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7XG4gICAgICB0aGlzLnNob3dUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLmhpZGVUaW1lciA9IG51bGw7XG4gICAgfSxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSAoKSB7XG4gICAgICB0aGlzLnNob3duID8gdGhpcy5faGlkZSgpIDogdGhpcy5zaG93KCk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgb24kJDEgPSByZWYub247XG4gICAgdmFyIHNob3cgPSByZWYuc2hvdztcbiAgICB2YXIgaGlkZSA9IHJlZi5oaWRlO1xuICAgIHZhciB0b2dnbGUgPSByZWYudG9nZ2xlO1xuICAgIHZhciBtb2RlID0gcmVmLm1vZGU7XG4gICAgdmFyIGNsZWFyVGltZXJzID0gcmVmLmNsZWFyVGltZXJzO1xuICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgvY2xpY2svLnRlc3QobW9kZSkgfHwgaGFzVG91Y2gpIHtcbiAgICAgICAgb24kJDEodGhpcyQxLiRyZWZzLnRhcmdldCwgJ2NsaWNrJywgdG9nZ2xlKTtcbiAgICAgIH1cbiAgICAgIGlmICgvaG92ZXIvLnRlc3QobW9kZSkpIHtcbiAgICAgICAgb24kJDEodGhpcyQxLiRyZWZzLnRhcmdldCwgcG9pbnRlckVudGVyLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNob3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uJCQxKHRoaXMkMS4kcmVmcy50YXJnZXQsIHBvaW50ZXJMZWF2ZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBoaWRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbiQkMSh0aGlzJDEuJGVsLCBwb2ludGVyTGVhdmUsIGhpZGUpO1xuICAgICAgICBvbiQkMSh0aGlzJDEuJGVsLCBwb2ludGVyRW50ZXIsIGNsZWFyVGltZXJzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG52YXIgRHJvcCA9IHtcbiAgbmFtZTogJ1ZrRHJvcCcsXG4gIG1peGluczogW3JlbmRlciwgdG9nZ2xlLCBFdmVudHNNaXhpbl0sXG4gIGRpcmVjdGl2ZXM6IHtcbiAgICBWa1Jvb3Q6IFZrUm9vdCxcbiAgICBWa1Bvc2l0aW9uOiBEaXJlY3RpdmVcbiAgfSxcbiAgcHJvcHM6IHByb3BzJDEsXG4gIG1ldGhvZHM6IHtcbiAgICBpc1BhcmVudE9mOiBmdW5jdGlvbiBpc1BhcmVudE9mIChpbnN0YW5jZSkge1xuICAgICAgdmFyIHBhcmVudHMgPSBmaW5kUGFyZW50cyhpbnN0YW5jZSk7XG4gICAgICByZXR1cm4gaW5jbHVkZXMocGFyZW50cywgdGhpcylcbiAgICB9LFxuICAgIGlzQ2hpbGRPZjogZnVuY3Rpb24gaXNDaGlsZE9mIChpbnN0YW5jZSkge1xuICAgICAgdmFyIHBhcmVudHMgPSBmaW5kUGFyZW50cyh0aGlzKTtcbiAgICAgIHJldHVybiBpbmNsdWRlcyhwYXJlbnRzLCBpbnN0YW5jZSlcbiAgICB9LFxuICAgIHF1ZXJ5RWxlbWVudDogZnVuY3Rpb24gcXVlcnlFbGVtZW50IChlbCkge1xuICAgICAgcmV0dXJuIGlzTm9kZShlbClcbiAgICAgICAgPyBlbFxuICAgICAgICA6IGlzU3RyaW5nKGVsKVxuICAgICAgICAgID8gKGdldCh0aGlzLiR2bm9kZS5jb250ZXh0LiRyZWZzLCBlbCkgfHwgJChlbCwgdGhpcy4kZWwpKVxuICAgICAgICAgIDogZWxcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMudHJhY2tlciA9IG5ldyBNb3VzZVRyYWNrZXIoKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuJGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuJGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZWwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgRHJvcGRvd24gPSB7XG4gIG5hbWU6ICdWa0Ryb3Bkb3duJyxcbiAgZXh0ZW5kczogRHJvcCxcbiAgcHJvcHM6IHtcbiAgICBtYWluQ2xhc3M6IHtcbiAgICAgIGRlZmF1bHQ6ICd1ay1kcm9wZG93bidcbiAgICB9XG4gIH1cbn1cblxudmFyIEVsZW1lbnRHcmlkID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICB9LFxuICAgIGRpdmlkZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbWF0Y2hlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBndXR0ZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gIXZhbCB8fCAvXihzbWFsbHxtZWRpdW18bGFyZ2V8Y29sbGFwc2UpJC8udGVzdCh2YWwpOyB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHByb3BzLnRhZztcbiAgICB2YXIgZ3V0dGVyID0gcHJvcHMuZ3V0dGVyO1xuICAgIHZhciBkaXZpZGVkID0gcHJvcHMuZGl2aWRlZDtcbiAgICB2YXIgbWF0Y2hlZCA9IHByb3BzLm1hdGNoZWQ7XG4gICAgcmV0dXJuIGgodGFnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IFsndWstZ3JpZCcsICggb2JqID0ge1xuICAgICAgICAndWstZ3JpZC1tYXRjaCc6IG1hdGNoZWQsXG4gICAgICAgICd1ay1ncmlkLWRpdmlkZXInOiBkaXZpZGVkXG4gICAgICB9LCBvYmpbKFwidWstZ3JpZC1cIiArIGd1dHRlcildID0gZ3V0dGVyLCBvYmopXVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgTkFNRVNQQUNFID0gJ19fdmtNYXJnaW4nO1xudmFyIFZrTWFyZ2luID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kJCQxIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFtOQU1FU1BBQ0VdID0ge307XG4gIH0sXG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlKGVsLCB7IGJpbmRpbmc6IGJpbmRpbmcsIHZub2RlOiB2bm9kZSB9KTsgfVxuICAgICk7XG4gICAgZWxbTkFNRVNQQUNFXS51bmJpbmQgPSBvbih3aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGUoZWwsIHsgYmluZGluZzogYmluZGluZywgdm5vZGU6IHZub2RlIH0pOyB9XG4gICAgKTtcbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlKGVsLCB7IGJpbmRpbmc6IGJpbmRpbmcsIHZub2RlOiB2bm9kZSB9KTsgfVxuICAgICk7XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChlbCkge1xuICAgIGlmICghZWxbTkFNRVNQQUNFXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsW05BTUVTUEFDRV0udW5iaW5kKCk7XG4gICAgZGVsZXRlIGVsW05BTUVTUEFDRV07XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZSAoZWwsIGN0eCkge1xuICB2YXIgb3B0cyA9IGdldE9wdGlvbnMkMShjdHgpO1xuICB2YXIgaXRlbXMgPSBlbC5jaGlsZHJlbjtcbiAgaWYgKCFpdGVtcy5sZW5ndGggfHwgIWlzVmlzaWJsZShlbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgZGF0YSA9IGdldFJvd3MoaXRlbXMpO1xuICBkYXRhLnJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpKSB7IHJldHVybiByb3cuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGopIHtcbiAgICAgIHRvZ2dsZUNsYXNzKGVsLCBvcHRzLm1hcmdpbiwgaSAhPT0gMCk7XG4gICAgICB0b2dnbGVDbGFzcyhlbCwgb3B0cy5maXJzdENvbHVtbiwgaiA9PT0gMCk7XG4gICAgfSk7IH1cbiAgKTtcbiAgb3B0cy5vblVwZGF0ZShlbCwgZGF0YSk7XG59XG5mdW5jdGlvbiBnZXRPcHRpb25zJDEgKGN0eCkge1xuICB2YXIgcmVmID0gY3R4LmJpbmRpbmc7XG4gIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oJ3YtdmstbWFnaW4gLT4gT2JqZWN0IGV4cGVjdGVkIGFzIGNvbmZpZ3VyYXRpb24nLCBjdHgudm5vZGUuY29udGV4dCk7XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSBhc3NpZ24oe1xuICAgIG9uVXBkYXRlOiBub29wLFxuICAgIG1hcmdpbjogJ3VrLW1hcmdpbi1zbWFsbC10b3AnLFxuICAgIGZpcnN0Q29sdW1uOiAndWstZmlyc3QtY29sdW1uJ1xuICB9LCB2YWx1ZSk7XG4gIHJldHVybiBvcHRpb25zXG59XG5mdW5jdGlvbiBnZXRSb3dzIChpdGVtcykge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgcm93cyA9IFtbXV07XG4gIGRhdGEuc3RhY2tzID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGl0ZW1zW2ldO1xuICAgIHZhciBkaW0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWRpbS5oZWlnaHQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGZvciAodmFyIGogPSByb3dzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcm93ID0gcm93c1tqXTtcbiAgICAgIGlmICghcm93WzBdKSB7XG4gICAgICAgIHJvdy5wdXNoKGVsKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHZhciBsZWZ0RGltID0gcm93WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKGRpbS50b3AgPj0gTWF0aC5mbG9vcihsZWZ0RGltLmJvdHRvbSkpIHtcbiAgICAgICAgcm93cy5wdXNoKFtlbF0pO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguZmxvb3IoZGltLmJvdHRvbSkgPiBsZWZ0RGltLnRvcCkge1xuICAgICAgICBkYXRhLnN0YWNrcyA9IGZhbHNlO1xuICAgICAgICBpZiAoZGltLmxlZnQgPCBsZWZ0RGltLmxlZnQgJiYgIWlzUnRsKSB7XG4gICAgICAgICAgcm93LnVuc2hpZnQoZWwpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcm93LnB1c2goZWwpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgcm93cy51bnNoaWZ0KFtlbF0pO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkYXRhLnJvd3MgPSByb3dzO1xuICByZXR1cm4gZGF0YVxufVxuXG52YXIgR3JpZCA9IHtcbiAgbmFtZTogJ1ZrR3JpZCcsXG4gIGRpcmVjdGl2ZXM6IHsgVmtNYXJnaW46IFZrTWFyZ2luIH0sXG4gIHByb3BzOiBhc3NpZ24oe30sIEVsZW1lbnRHcmlkLnByb3BzLCB7XG4gICAgbWFyZ2luOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndWstZ3JpZC1tYXJnaW4nXG4gICAgfSxcbiAgICBmaXJzdENvbHVtbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3VrLWZpcnN0LWNvbHVtbidcbiAgICB9XG4gIH0pLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciBjbHNTdGFjayA9ICd1ay1ncmlkLXN0YWNrJztcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgbWFyZ2luID0gcmVmLm1hcmdpbjtcbiAgICB2YXIgZmlyc3RDb2x1bW4gPSByZWYuZmlyc3RDb2x1bW47XG4gICAgcmV0dXJuIGgoRWxlbWVudEdyaWQsIHtcbiAgICAgIHByb3BzOiB0aGlzLiRwcm9wcyxcbiAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgIG5hbWU6ICd2ay1tYXJnaW4nLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgICAgIGZpcnN0Q29sdW1uOiBmaXJzdENvbHVtbixcbiAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKGVsLCByZWYpIHtcbiAgICAgICAgICAgIHZhciBzdGFja3MgPSByZWYuc3RhY2tzO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIGNsc1N0YWNrLCBzdGFja3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59XG5cbnZhciBjb3JlID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICByYXRpbzoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgaWNvbiA9IHByb3BzLmljb247XG4gICAgdmFyIHJhdGlvID0gcHJvcHMucmF0aW87XG4gICAgdmFyIHJlZiQxID0gZGF0YS5hdHRycyB8fCB7fTtcbiAgICB2YXIgd2lkdGggPSByZWYkMS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcmVmJDEuaGVpZ2h0O1xuICAgIHZhciB2aWV3Qm94ID0gcmVmJDEudmlld0JveDtcbiAgICB2YXIgSWNvbiA9IGgoKFwidmstaWNvbnMtXCIgKyBpY29uKSwge1xuICAgICAgYXR0cnM6IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdmlld0JveDogdmlld0JveCB9XG4gICAgfSk7XG4gICAgaWYgKHJhdGlvICE9PSAxKSB7XG4gICAgICBJY29uLmRhdGEuYXR0cnMud2lkdGggKj0gcmF0aW87XG4gICAgICBJY29uLmRhdGEuYXR0cnMuaGVpZ2h0ICo9IHJhdGlvO1xuICAgICAgSWNvbi5kYXRhLmF0dHJzLnJhdGlvID0gcmF0aW87XG4gICAgfVxuICAgIHJldHVybiBJY29uXG4gIH1cbn1cblxudmFyIEVsZW1lbnRJY29uID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIChoLCByZWYpIHtcbiAgICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgICByZXR1cm4gaCgnc3BhbicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLWljb24nXG4gICAgfSksIGNoaWxkcmVuKTtcbn1cbn1cblxudmFyIEVsZW1lbnRJY29uTGluayA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICByZXNldDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciByZXNldCA9IHByb3BzLnJlc2V0O1xuICAgIHJldHVybiBoKCdhJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLWljb24nLCB7XG4gICAgICAgICd1ay1pY29uLWxpbmsnOiByZXNldFxuICAgICAgfV1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRJY29uQnV0dG9uID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgoJ2EnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6ICd1ay1pY29uIHVrLWljb24tYnV0dG9uJ1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudEljb25JbWFnZSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBzcmM6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHNyYyA9IHByb3BzLnNyYztcbiAgICByZXR1cm4gaCgnc3BhbicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLWljb24gdWstaWNvbi1pbWFnZScsXG4gICAgICBzdHlsZToge1xuICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IChcInVybChcIiArIHNyYyArIFwiKVwiKVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbnZhciBpY29uID0ge1xuICBuYW1lOiAnVmtJY29uJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IGNvcmUucHJvcHMsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICByZXR1cm4gaChFbGVtZW50SWNvbiwgZGF0YSwgW1xuICAgICAgaChjb3JlLCBtZXJnZURhdGEoZGF0YSwgeyBwcm9wczogcHJvcHMgfSkpXG4gICAgXSlcbiAgfVxufVxuXG52YXIgaWNvbkxpbmsgPSB7XG4gIG5hbWU6ICdWa0ljb25MaW5rJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IGFzc2lnbih7fSwgY29yZS5wcm9wcywgRWxlbWVudEljb25MaW5rLnByb3BzKSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkZWYgPSBtZXJnZURhdGEoZGF0YSwgeyBwcm9wczogcHJvcHMgfSk7XG4gICAgcmV0dXJuIGgoRWxlbWVudEljb25MaW5rLCBkZWYsIFsgaChjb3JlLCBkZWYpIF0pXG4gIH1cbn1cblxudmFyIGljb25CdXR0b24gPSB7XG4gIG5hbWU6ICdWa0ljb25CdXR0b24nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogY29yZS5wcm9wcyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHJldHVybiBoKEVsZW1lbnRJY29uQnV0dG9uLCBkYXRhLCBbXG4gICAgICBoKGNvcmUsIG1lcmdlRGF0YShkYXRhLCB7IHByb3BzOiBwcm9wcyB9KSlcbiAgICBdKVxuICB9XG59XG5cbnZhciBpY29uSW1hZ2UgPSB7XG4gIG5hbWU6ICdWa0ljb25JbWFnZScsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50SWNvbkltYWdlLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnRJY29uSW1hZ2UucmVuZGVyXG59XG5cbnZhciBFbGVtZW50SWNvbm5hdiA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiBoKCd1bCcsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLWljb25uYXYnXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50SWNvbm5hdlZlcnRpY2FsID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgoJ3VsJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndWstaWNvbm5hdiB1ay1pY29ubmF2LXZlcnRpY2FsJ1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudEljb25uYXZJdGVtID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGhyZWY6IFN0cmluZyxcbiAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICBhY3RpdmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgYWN0aXZlID0gcHJvcHMuYWN0aXZlO1xuICAgIHZhciBocmVmID0gcHJvcHMuaHJlZjtcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgIHJldHVybiBoKCdsaScsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogeyAndWstYWN0aXZlJzogYWN0aXZlIH1cbiAgICB9KSwgW1xuICAgICAgaChFbGVtZW50SWNvbkxpbmssIHtcbiAgICAgICAgYXR0cnM6IHsgaHJlZjogaHJlZiwgdGFyZ2V0OiB0YXJnZXQgfVxuICAgICAgfSwgY2hpbGRyZW4pXG4gICAgXSlcbiAgfVxufVxuXG52YXIgaWNvbm5hdiA9IHtcbiAgbmFtZTogJ1ZrSWNvbm5hdicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogRWxlbWVudEljb25uYXYucmVuZGVyXG59XG5cbnZhciBpY29ubmF2VmVydGljYWwgPSB7XG4gIG5hbWU6ICdWa0ljb25uYXZWZXJ0aWNhbCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogRWxlbWVudEljb25uYXZWZXJ0aWNhbC5yZW5kZXJcbn1cblxudmFyIGljb25uYXZfSXRlbSA9IHtcbiAgbmFtZTogJ1ZrSWNvbm5hdkl0ZW0nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogYXNzaWduKHtcbiAgICBpY29uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSwgRWxlbWVudEljb25uYXZJdGVtLnByb3BzKSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHJldHVybiBoKEVsZW1lbnRJY29ubmF2SXRlbSwgbWVyZ2VEYXRhKGRhdGEsIHsgcHJvcHM6IHByb3BzIH0pLCBbXG4gICAgICBoKChcInZrLWljb25zLVwiICsgKHByb3BzLmljb24pKSlcbiAgICBdKVxuICB9XG59XG5cbnZhciBFbGVtZW50TGFiZWwgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAhdmFsIHx8IC9eKHN1Y2Nlc3N8d2FybmluZ3xkYW5nZXIpJC8udGVzdCh2YWwpOyB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuICAgIHJldHVybiBoKCdzcGFuJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLWxhYmVsJywgKCBvYmogPSB7fSwgb2JqWyhcInVrLWxhYmVsLVwiICsgdHlwZSldID0gdHlwZSwgb2JqKV1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIGxhYmVsID0ge1xuICBuYW1lOiAnVmtMYWJlbCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50TGFiZWwucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudExhYmVsLnJlbmRlclxufVxuXG52YXIgU0hPV04gPSAnc2hvd24nO1xudmFyIEhJRERFTiA9ICdoaWRkZW4nO1xudmFyIFRPR0dMRSA9ICd1cGRhdGU6c2hvdyc7XG52YXIgS0VZVVAgPSAna2V5dXAnO1xuXG52YXIgZG9jJDIgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbnZhciBhY3RpdmUkMTtcbnZhciBhY3RpdmVNb2RhbHM7XG52YXIgVHJhbnNpdGlvbiQyID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIG1vZGFsID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGVmID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY3NzOiBmYWxzZSxcbiAgICAgICAgYXBwZWFyOiB0cnVlXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgYmVmb3JlRW50ZXI6IGZ1bmN0aW9uIGJlZm9yZUVudGVyICgpIHtcbiAgICAgICAgICBhZGRDbGFzcyhkb2MkMiwgJ3VrLW1vZGFsLXBhZ2UnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyIChlbCwgZG9uZSkge1xuICAgICAgICAgIHZhciBwcmV2ID0gYWN0aXZlJDEgIT09IG1vZGFsICYmIGFjdGl2ZSQxO1xuICAgICAgICAgIGlmIChwcmV2ICYmICFtb2RhbC5zdGFjaykge1xuICAgICAgICAgICAgcHJldi5oaWRlKCk7XG4gICAgICAgICAgICBvbmNlKHByZXYuJGVsLCAndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvRW50ZXIoZWwsIGRvbmUpOyB9LCBmYWxzZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0ID09PSBwcmV2LiRlbDsgfSk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkb0VudGVyKGVsLCBkb25lKTsgfSwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFmdGVyRW50ZXI6IGZ1bmN0aW9uIGFmdGVyRW50ZXIgKGVsKSB7XG4gICAgICAgICAgYWN0aXZlTW9kYWxzKys7XG4gICAgICAgICAgYWN0aXZlJDEgPSBtb2RhbDtcbiAgICAgICAgICBhY3RpdmUkMS4kZW1pdChTSE9XTik7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZUxlYXZlOiBmdW5jdGlvbiBiZWZvcmVMZWF2ZSAoZWwpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgJ3VrLW9wZW4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlIChlbCwgZG9uZSkge1xuICAgICAgICAgIG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldCA9PT0gZWw7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlckxlYXZlOiBmdW5jdGlvbiBhZnRlckxlYXZlIChlbCkge1xuICAgICAgICAgIGFjdGl2ZU1vZGFscy0tO1xuICAgICAgICAgIGlmICghYWN0aXZlTW9kYWxzKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhkb2MkMiwgJ3VrLW1vZGFsLXBhZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGl2ZSQxID09PSBtb2RhbCkge1xuICAgICAgICAgICAgYWN0aXZlJDEgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RhbC4kZW1pdChISURERU4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkb0VudGVyIChlbCwgZG9uZSkge1xuICAgICAgbW9kYWwuJHJvb3QuJGVsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIGVsLm9mZnNldFdpZHRoO1xuICAgICAgb25jZShlbCwgJ3RyYW5zaXRpb25lbmQnLCBkb25lLCBmYWxzZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0ID09PSBlbDsgfSk7XG4gICAgICBhZGRDbGFzcyhlbCwgJ3VrLW9wZW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGgoJ3RyYW5zaXRpb24nLCBkZWYsIGNoaWxkcmVuKVxuICB9XG59XG5vbihkb2MkMiwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgaWYgKCFhY3RpdmUkMSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBjbGlja2VkT3V0ID0gZS50YXJnZXQgPT09IGFjdGl2ZSQxLiRlbDtcbiAgaWYgKGNsaWNrZWRPdXQgJiYgIWFjdGl2ZSQxLnN0dWNrKSB7XG4gICAgYWN0aXZlJDEuJGVtaXQoVE9HR0xFLCBmYWxzZSk7XG4gIH1cbn0pO1xub24oZG9jJDIsICdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gIGFjdGl2ZSQxICYmIGFjdGl2ZSQxLiRlbWl0KEtFWVVQLCBlKTtcbn0pO1xuXG52YXIgZG9jJDMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbnZhciBjb3JlJDEgPSB7XG4gIG1peGluczogW0V2ZW50c01peGluXSxcbiAgcHJvcHM6IHtcbiAgICBzaG93OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlICgpIHtcbiAgICAgIHRoaXMuJGVtaXQoVE9HR0xFLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy4kZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy4kZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLiRlbCk7XG4gICAgfVxuICAgIGlmICghYWN0aXZlTW9kYWxzKSB7XG4gICAgICByZW1vdmVDbGFzcyhkb2MkMywgJ3VrLW1vZGFsLXBhZ2UnKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFZrTW9kYWxPdmVyZmxvd0F1dG8gPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCBiaW5kaW5nKSB7XG4gICAgZWwudmtNb2RhbE92ZXJmbG93QXV0b09mZiA9IG9uKHdpbmRvdywgJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZSQxKGVsLCBiaW5kaW5nKTsgfSk7XG4gICAgYWRkQ2xhc3MoZWwsICd1ay1vdmVyZmxvdy1hdXRvJyk7XG4gIH0sXG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlJDEoZWwsIGJpbmRpbmcpOyB9KTtcbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcpIHtcbiAgICB1cGRhdGUkMShlbCwgYmluZGluZyk7XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChlbCkge1xuICAgIGVsLnZrTW9kYWxPdmVyZmxvd0F1dG9PZmYoKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlJDEgKGVsLCBiaW5kaW5nKSB7XG4gIHZhciBtb2RhbCA9IGNsb3Nlc3QoZWwsICcudWstbW9kYWwnKTtcbiAgdmFyIHBhbmVsID0gY2xvc2VzdChlbCwgJy51ay1tb2RhbC1kaWFsb2cnKTtcbiAgaWYgKCFwYW5lbCB8fCAhbW9kYWwpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgY3VycmVudCA9IGNzcyhlbCwgJ21heEhlaWdodCcpO1xuICBjc3MoZWwsICdtYXhIZWlnaHQnLCAxNTApO1xuICBjc3MoZWwsICdtYXhIZWlnaHQnLCBNYXRoLm1heCgxNTAsIDE1MCArIGhlaWdodChtb2RhbCkgLSBwYW5lbC5vZmZzZXRIZWlnaHQpKTtcbiAgaWYgKGN1cnJlbnQgIT09IGNzcyhlbCwgJ21heEhlaWdodCcpKSB7XG4gICAgdXBkYXRlJDEoZWwsIGJpbmRpbmcpO1xuICB9XG59XG5cbnZhciBFbGVtZW50TW9kYWwgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgZXhwYW5kOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGV4cGFuZCA9IHByb3BzLmV4cGFuZDtcbiAgICByZXR1cm4gaCgnZGl2JywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLW1vZGFsJywge1xuICAgICAgICAndWstbW9kYWwtY29udGFpbmVyJzogZXhwYW5kXG4gICAgICB9XSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRNb2RhbEZ1bGwgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW1vZGFsIHVrLW1vZGFsLWZ1bGwnLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgfVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgSWNvbkNsb3NlID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIChoLCBjdHgpIHtcbiAgICB2YXIgcHJvcHMgPSBjdHgucHJvcHM7XG4gICAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGggfHwgMTQ7XG4gICAgdmFyIGhlaWdodCA9IHByb3BzLmhlaWdodCB8fCAxNDtcbiAgICB2YXIgdmlld0JveCA9IHByb3BzLnZpZXdCb3ggfHwgJzAgMCAxNCAxNCc7XG4gICAgcmV0dXJuIGgoJ3N2ZycsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHZlcnNpb246ICcxLjEnLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB2aWV3Qm94OiB2aWV3Qm94XG4gICAgICB9LFxuICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgaW5uZXJIVE1MOiAnPHBhdGggZmlsbD1cIm5vbmVcIiBzdHJva2U9XCIjMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMS4xXCIgZD1cIk0xIDFsMTIgMTJNMTMgMUwxIDEzXCIvPidcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbnZhciBJY29uQ2xvc2VMYXJnZSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgdmFyIHByb3BzID0gY3R4LnByb3BzO1xuICAgIHZhciB3aWR0aCA9IHByb3BzLndpZHRoIHx8IDIwO1xuICAgIHZhciBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgMjA7XG4gICAgdmFyIHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94IHx8ICcwIDAgMjAgMjAnO1xuICAgIHJldHVybiBoKCdzdmcnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB2ZXJzaW9uOiAnMS4xJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdmlld0JveDogdmlld0JveFxuICAgICAgfSxcbiAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgIGlubmVySFRNTDogJzxwYXRoIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjEuNFwiIGQ9XCJNMSAxbDE4IDE4TTE5IDFMMSAxOVwiLz4nXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG52YXIgRWxlbWVudE1vZGFsQ2xvc2UgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbGFyZ2U6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgb3V0c2lkZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgbGFyZ2UgPSBwcm9wcy5sYXJnZTtcbiAgICB2YXIgb3V0c2lkZSA9IHByb3BzLm91dHNpZGU7XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgIGNsYXNzOiBbJ3VrLWNsb3NlIHVrLWljb24nLCAoIG9iaiA9IHtcbiAgICAgICAgJ3VrLWNsb3NlLWxhcmdlJzogbGFyZ2VcbiAgICAgIH0sIG9ialtcInVrLW1vZGFsLWNsb3NlLW91dHNpZGVcIl0gPSBvdXRzaWRlLCBvYmpbXCJ1ay1tb2RhbC1jbG9zZS1kZWZhdWx0XCJdID0gIW91dHNpZGUsIG9iaildLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoKCdidXR0b24nLCBtZXJnZURhdGEoZGF0YSwgZGVmKSwgW1xuICAgICAgaChsYXJnZSA/IEljb25DbG9zZUxhcmdlIDogSWNvbkNsb3NlKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRNb2RhbEZ1bGxDbG9zZSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBsYXJnZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGxhcmdlID0gcHJvcHMubGFyZ2U7XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgIGNsYXNzOiBbJ3VrLWNsb3NlIHVrLWljb24gdWstbW9kYWwtY2xvc2UtZnVsbCcsIHtcbiAgICAgICAgJ3VrLWNsb3NlLWxhcmdlJzogbGFyZ2VcbiAgICAgIH1dLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoKCdidXR0b24nLCBtZXJnZURhdGEoZGF0YSwgZGVmKSwgW1xuICAgICAgaChsYXJnZSA/IEljb25DbG9zZUxhcmdlIDogSWNvbkNsb3NlKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRNb2RhbFRpdGxlID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2gyJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gcHJvcHMudGFnO1xuICAgIHJldHVybiBoKHRhZywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndWstbW9kYWwtdGl0bGUnXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50TW9kYWxCb2R5ID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiBoKCdkaXYnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6ICd1ay1tb2RhbC1ib2R5J1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudE1vZGFsRGlhbG9nID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiBoKCdkaXYnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6ICd1ay1tb2RhbC1kaWFsb2cnXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50TW9kYWxGb290ZXIgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW1vZGFsLWZvb3RlcidcbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRNb2RhbEhlYWRlciA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICByZXR1cm4gaCgnZGl2JywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndWstbW9kYWwtaGVhZGVyJ1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgbW9kYWwgPSB7XG4gIG5hbWU6ICdWa01vZGFsJyxcbiAgZXh0ZW5kczogY29yZSQxLFxuICBkaXJlY3RpdmVzOiB7XG4gICAgVmtNb2RhbE92ZXJmbG93QXV0bzogVmtNb2RhbE92ZXJmbG93QXV0b1xuICB9LFxuICBwcm9wczoge1xuICAgIHN0dWNrOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG92ZXJmbG93QXV0bzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjZW50ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHN0YWNrOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgd2lkdGhDbGFzc2VzOiBmdW5jdGlvbiB3aWR0aENsYXNzZXMgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZVxuICAgICAgICA/IHRoaXMuc2l6ZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gKFwidWstd2lkdGgtXCIgKyBzaXplKTsgfSlcbiAgICAgICAgOiAnJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgZGVmID0ge1xuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ3VrLWZsZXggdWstZmxleC10b3AnOiB0aGlzLmNlbnRlclxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRoaXMuY2VudGVyID8gJ2ZsZXgnIDogJ2Jsb2NrJ1xuICAgICAgfSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGV4cGFuZDogdGhpcy5zaXplID09PSAnY29udGFpbmVyJ1xuICAgICAgfSxcbiAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcbiAgICAgICAgdmFsdWU6IHRoaXMuc2hvd1xuICAgICAgfV0sXG4gICAgICBvbjoge1xuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmtleXModGhpcy4kc2xvdHMpLmZvckVhY2goZnVuY3Rpb24gKHNsb3QpIHsgcmV0dXJuIGVhY2godGhpcyQxLiRzbG90c1tzbG90XSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmZuT3B0aW9ucyAmJiBub2RlLmZuT3B0aW9ucy5uYW1lID09PSAnVmtNb2RhbENsb3NlJykge1xuICAgICAgICBhc3NpZ24obm9kZS5kYXRhLCB7XG4gICAgICAgICAgb246IGFzc2lnbih7IGNsaWNrOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGhpcyQxLiRlbWl0KFRPR0dMRSwgZmFsc2UpOyB9IH0sIG5vZGUuZGF0YS5vbiB8fCB7fSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7IH0pO1xuICAgIHZhciBtb2RhbCA9IGgoRWxlbWVudE1vZGFsLCBkZWYsIFtcbiAgICAgIGgoRWxlbWVudE1vZGFsRGlhbG9nLCB7XG4gICAgICAgIGNsYXNzOiBbdGhpcy53aWR0aENsYXNzZXMsIHtcbiAgICAgICAgICAndWstbWFyZ2luLWF1dG8tdmVydGljYWwnOiB0aGlzLmNlbnRlclxuICAgICAgICB9XVxuICAgICAgfSwgW1xuICAgICAgICB0aGlzLiRzbG90cy5kaWFsb2cgJiYgdGhpcy4kc2xvdHMuZGlhbG9nLFxuICAgICAgICB0aGlzLiRzbG90cy5oZWFkZXIgJiYgaChFbGVtZW50TW9kYWxIZWFkZXIsIHRoaXMuJHNsb3RzLmhlYWRlciksXG4gICAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHQgJiYgaChFbGVtZW50TW9kYWxCb2R5LCB7XG4gICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5vdmVyZmxvd0F1dG9cbiAgICAgICAgICAgID8gW3sgbmFtZTogJ3ZrLW1vZGFsLW92ZXJmbG93LWF1dG8nIH1dXG4gICAgICAgICAgICA6IFtdXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpLFxuICAgICAgICB0aGlzLiRzbG90cy5mb290ZXIgJiYgaChFbGVtZW50TW9kYWxGb290ZXIsIHRoaXMuJHNsb3RzLmZvb3RlcilcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbiQyLCBbIG1vZGFsIF0pXG4gIH1cbn1cblxudmFyIE5BTUVTUEFDRSQxID0gJ19fdmtIZWlnaHRWaWV3cG9ydCc7XG52YXIgVmtIZWlnaHRWaWV3cG9ydCA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCQkMSAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbTkFNRVNQQUNFJDFdID0ge307XG4gIH0sXG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlJDIoZWwsIHsgYmluZGluZzogYmluZGluZywgdm5vZGU6IHZub2RlIH0pOyB9XG4gICAgKTtcbiAgICBlbFtOQU1FU1BBQ0UkMV0udW5iaW5kID0gb24od2luZG93LCAncmVzaXplJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlJDIoZWwsIHsgYmluZGluZzogYmluZGluZywgdm5vZGU6IHZub2RlIH0pOyB9XG4gICAgKTtcbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlJDIoZWwsIHsgYmluZGluZzogYmluZGluZywgdm5vZGU6IHZub2RlIH0pOyB9XG4gICAgKTtcbiAgfSxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKGVsKSB7XG4gICAgaWYgKCFlbFtOQU1FU1BBQ0UkMV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbFtOQU1FU1BBQ0UkMV0udW5iaW5kKCk7XG4gICAgZGVsZXRlIGVsW05BTUVTUEFDRSQxXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3B0aW9ucyQyIChjdHgpIHtcbiAgdmFyIHJlZiA9IGN0eC5iaW5kaW5nO1xuICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSByZWYubW9kaWZpZXJzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpKSB7XG4gICAgd2Fybigndi12ay1oZWlnaHQtdmlld3BvcnQgLT4gT2JqZWN0IGV4cGVjdGVkIGFzIGNvbmZpZ3VyYXRpb24nLCBjdHgudm5vZGUuY29udGV4dCk7XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSBhc3NpZ24oe1xuICAgIG1pbkhlaWdodDogMCxcbiAgICBleHBhbmQ6IGZhbHNlLFxuICAgIG9mZnNldFRvcDogZmFsc2UsXG4gICAgb2Zmc2V0Qm90dG9tOiBmYWxzZVxuICB9LCBtb2RpZmllcnMsIHZhbHVlKTtcbiAgcmV0dXJuIG9wdGlvbnNcbn1cbmZ1bmN0aW9uIHVwZGF0ZSQyIChlbCwgY3R4KSB7XG4gIHZhciBvcHRzID0gZ2V0T3B0aW9ucyQyKGN0eCk7XG4gIGNzcyhlbCwgJ2JveFNpemluZycsICdib3JkZXItYm94Jyk7XG4gIHZhciB2aWV3cG9ydCA9IGhlaWdodCh3aW5kb3cpO1xuICB2YXIgbWluSGVpZ2h0O1xuICB2YXIgb2Zmc2V0VG9wID0gMDtcbiAgaWYgKG9wdHMuZXhwYW5kKSB7XG4gICAgY3NzKGVsLCB7aGVpZ2h0OiAnJywgbWluSGVpZ2h0OiAnJ30pO1xuICAgIHZhciBkaWZmID0gdmlld3BvcnQgLSBvZmZzZXRIZWlnaHQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIG1pbkhlaWdodCA9IG9mZnNldEhlaWdodChlbCkgKyBkaWZmO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVmID0gb2Zmc2V0KGVsKTtcbiAgICB2YXIgdG9wID0gcmVmLnRvcDtcbiAgICBpZiAodG9wIDwgdmlld3BvcnQgLyAyICYmIG9wdHMub2Zmc2V0VG9wKSB7XG4gICAgICBvZmZzZXRUb3AgKz0gdG9wO1xuICAgIH1cbiAgICBpZiAob3B0cy5vZmZzZXRCb3R0b20gPT09IHRydWUpIHtcbiAgICAgIG9mZnNldFRvcCArPSBvZmZzZXRIZWlnaHQoZWwubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtZXJpYyhvcHRzLm9mZnNldEJvdHRvbSkpIHtcbiAgICAgIG9mZnNldFRvcCArPSAodmlld3BvcnQgLyAxMDApICogb3B0cy5vZmZzZXRCb3R0b207XG4gICAgfSBlbHNlIGlmIChvcHRzLm9mZnNldEJvdHRvbSAmJiBlbmRzV2l0aChvcHRzLm9mZnNldEJvdHRvbSwgJ3B4JykpIHtcbiAgICAgIG9mZnNldFRvcCArPSB0b0Zsb2F0KG9wdHMub2Zmc2V0Qm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKG9wdHMub2Zmc2V0Qm90dG9tKSkge1xuICAgICAgb2Zmc2V0VG9wICs9IG9mZnNldEhlaWdodChxdWVyeShvcHRzLm9mZnNldEJvdHRvbSwgZWwpKTtcbiAgICB9XG4gICAgbWluSGVpZ2h0ID0gb2Zmc2V0VG9wID8gKFwiY2FsYygxMDB2aCAtIFwiICsgb2Zmc2V0VG9wICsgXCJweClcIikgOiAnMTAwdmgnO1xuICB9XG4gIGlmICghbWluSGVpZ2h0KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY3NzKGVsLCB7IGhlaWdodDogJycsIG1pbkhlaWdodDogbWluSGVpZ2h0IH0pO1xuICB2YXIgZWxIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gIGlmIChvcHRzLm1pbkhlaWdodCAmJiBvcHRzLm1pbkhlaWdodCA+IGVsSGVpZ2h0KSB7XG4gICAgY3NzKGVsLCAnbWluSGVpZ2h0Jywgb3B0cy5taW5IZWlnaHQpO1xuICB9XG4gIGlmICh2aWV3cG9ydCAtIG9mZnNldFRvcCA+PSBlbEhlaWdodCkge1xuICAgIGNzcyhlbCwgJ2hlaWdodCcsIG1pbkhlaWdodCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9mZnNldEhlaWdodCAoZWwpIHtcbiAgcmV0dXJuIGVsICYmIChlbC5vZmZzZXRIZWlnaHQgfHwgMClcbn1cblxudmFyIG1vZGFsRnVsbCA9IHtcbiAgbmFtZTogJ1ZrTW9kYWxGdWxsJyxcbiAgZXh0ZW5kczogY29yZSQxLFxuICBkaXJlY3RpdmVzOiB7XG4gICAgVmtIZWlnaHRWaWV3cG9ydDogVmtIZWlnaHRWaWV3cG9ydFxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHZhciBkZWYgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBleHBhbmQ6ICdmdWxsJ1xuICAgICAgfSxcbiAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcbiAgICAgICAgdmFsdWU6IHRoaXMuc2hvd1xuICAgICAgfV1cbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKHRoaXMuJHNsb3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChzbG90KSB7IHJldHVybiBlYWNoKHRoaXMkMS4kc2xvdHNbc2xvdF0sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5mbk9wdGlvbnMgJiYgbm9kZS5mbk9wdGlvbnMubmFtZSA9PT0gJ1ZrTW9kYWxGdWxsQ2xvc2UnKSB7XG4gICAgICAgIGFzc2lnbihub2RlLmRhdGEsIHtcbiAgICAgICAgICBvbjogYXNzaWduKHsgY2xpY2s6IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzJDEuJGVtaXQoVE9HR0xFLCBmYWxzZSk7IH0gfSwgbm9kZS5kYXRhLm9uIHx8IHt9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTsgfSk7XG4gICAgdmFyIG1vZGFsID0gaChFbGVtZW50TW9kYWxGdWxsLCBkZWYsIFtcbiAgICAgIGgoRWxlbWVudE1vZGFsRGlhbG9nLCB7XG4gICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgbmFtZTogJ3ZrLWhlaWdodC12aWV3cG9ydCdcbiAgICAgICAgfV1cbiAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpXG4gICAgXSk7XG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbiQyLCBbIG1vZGFsIF0pXG4gIH1cbn1cblxudmFyIG1vZGFsX0Nsb3NlID0ge1xuICBuYW1lOiAnVmtNb2RhbENsb3NlJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnRNb2RhbENsb3NlLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnRNb2RhbENsb3NlLnJlbmRlclxufVxuXG52YXIgbW9kYWxGdWxsX0Nsb3NlID0ge1xuICBuYW1lOiAnVmtNb2RhbEZ1bGxDbG9zZScsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50TW9kYWxGdWxsQ2xvc2UucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudE1vZGFsRnVsbENsb3NlLnJlbmRlclxufVxuXG52YXIgbW9kYWxfVGl0bGUgPSB7XG4gIG5hbWU6ICdWa01vZGFsVGl0bGUnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogRWxlbWVudE1vZGFsVGl0bGUucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudE1vZGFsVGl0bGUucmVuZGVyXG59XG5cbnZhciBFbGVtZW50TmF2ID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGNlbnRlcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eKGRlZmF1bHR8cHJpbWFyeXxibGFuaykkLy50ZXN0KHZhbCk7IH1cbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgb2JqO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgY2VudGVyID0gcHJvcHMuY2VudGVyO1xuICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTtcbiAgICByZXR1cm4gaCgndWwnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IFsndWstbmF2JywgKCBvYmogPSB7XG4gICAgICAgICd1ay1uYXYtY2VudGVyJzogY2VudGVyXG4gICAgICB9LCBvYmpbKFwidWstbmF2LVwiICsgdHlwZSldID0gdHlwZSwgb2JqKV1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnROYXZEcm9wZG93biA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiBoKCd1bCcsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdiB1ay1kcm9wZG93bi1uYXYnXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50TmF2SXRlbSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiB7fSxcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBhY3RpdmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBhY3RpdmUgPSBwcm9wcy5hY3RpdmU7XG4gICAgdmFyIGljb24kJDEgPSBwcm9wcy5pY29uO1xuICAgIHZhciB0aXRsZSA9IHByb3BzLnRpdGxlO1xuICAgIHZhciBocmVmID0gcHJvcHMuaHJlZjtcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgIHZhciBjb250ZW50ID0gdGl0bGU7XG4gICAgaWYgKGljb24kJDEpIHtcbiAgICAgIGNvbnRlbnQgPSBbXG4gICAgICAgIGgoRWxlbWVudEljb24sIHtcbiAgICAgICAgICBjbGFzczogJ3VrLW1hcmdpbi1zbWFsbC1yaWdodCdcbiAgICAgICAgfSwgWyBpY29uJCQxIF0pLFxuICAgICAgICBoKCdzcGFuJywge1xuICAgICAgICAgIGNsYXNzOiAndWstdGV4dC1taWRkbGUnXG4gICAgICAgIH0sIHRpdGxlKVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIGgoJ2xpJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiB7ICd1ay1hY3RpdmUnOiBhY3RpdmUgfVxuICAgIH0pLCBbXG4gICAgICBoKCdhJywge1xuICAgICAgICBhdHRyczogeyBocmVmOiBocmVmLCB0YXJnZXQ6IHRhcmdldCB9XG4gICAgICB9LCBjb250ZW50KVxuICAgIF0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnROYXZJdGVtRGl2aWRlciA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgcmV0dXJuIGgoJ2xpJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndWstbmF2LWRpdmlkZXInXG4gICAgfSkpXG4gIH1cbn1cblxudmFyIEVsZW1lbnROYXZJdGVtSGVhZGVyID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHRpdGxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHJldHVybiBoKCdsaScsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdi1oZWFkZXInXG4gICAgfSksIHByb3BzLnRpdGxlKVxuICB9XG59XG5cbnZhciBFbGVtZW50TmF2SXRlbVBhcmVudCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciB0aXRsZSA9IHByb3BzLnRpdGxlO1xuICAgIHZhciBocmVmID0gcHJvcHMuaHJlZjtcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgIHJldHVybiBoKCdsaScsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLXBhcmVudCdcbiAgICB9KSwgW1xuICAgICAgaCgnYScsIHtcbiAgICAgICAgYXR0cnM6IHsgaHJlZjogaHJlZiwgdGFyZ2V0OiB0YXJnZXQgfVxuICAgICAgfSwgWyB0aXRsZSBdKSxcbiAgICAgIGgoJ3VsJywge1xuICAgICAgICBjbGFzczogJ3VrLW5hdi1zdWInXG4gICAgICB9LCBjaGlsZHJlbilcbiAgICBdKVxuICB9XG59XG5cbnZhciBuYXYkMSA9IHtcbiAgbmFtZTogJ1ZrTmF2JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnROYXYucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudE5hdi5yZW5kZXJcbn1cblxudmFyIG5hdkRyb3Bkb3duID0ge1xuICBuYW1lOiAnVmtOYXZEcm9wZG93bicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogRWxlbWVudE5hdkRyb3Bkb3duLnJlbmRlclxufVxuXG52YXIgbmF2X0l0ZW0gPSB7XG4gIG5hbWU6ICdWa05hdkl0ZW0nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogYXNzaWduKHt9LCBFbGVtZW50TmF2SXRlbS5wcm9wcywge1xuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH1cbiAgfSksXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICBwcm9wcy5pY29uID0gcHJvcHMuaWNvbiAmJiBoKChcInZrLWljb25zLVwiICsgKHByb3BzLmljb24pKSk7XG4gICAgcmV0dXJuIGgoRWxlbWVudE5hdkl0ZW0sIG1lcmdlRGF0YShkYXRhLCB7IHByb3BzOiBwcm9wcyB9KSlcbiAgfVxufVxuXG52YXIgbmF2X0l0ZW1EaXZpZGVyID0ge1xuICBuYW1lOiAnVmtOYXZJdGVtRGl2aWRlcicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogRWxlbWVudE5hdkl0ZW1EaXZpZGVyLnJlbmRlclxufVxuXG52YXIgbmF2X0l0ZW1IZWFkZXIgPSB7XG4gIG5hbWU6ICdWa05hdkl0ZW1IZWFkZXInLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogRWxlbWVudE5hdkl0ZW1IZWFkZXIucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudE5hdkl0ZW1IZWFkZXIucmVuZGVyXG59XG5cbnZhciBuYXZfSXRlbVBhcmVudCA9IHtcbiAgbmFtZTogJ1ZrTmF2SXRlbVBhcmVudCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50TmF2SXRlbVBhcmVudC5wcm9wcyxcbiAgcmVuZGVyOiBFbGVtZW50TmF2SXRlbVBhcmVudC5yZW5kZXJcbn1cblxudmFyIEVsZW1lbnROYXZiYXJOYXZpZ2F0aW9uID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbGVmdCcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eKGxlZnR8Y2VudGVyKC1sZWZ0fC1yaWdodCk/fHJpZ2h0KSQvLnRlc3QodmFsKTsgfVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICB2YXIgd3JhcENvbnRlbnQgPSAvY2VudGVyLShsZWZ0fHJpZ2h0KS8udGVzdChhbGlnbik7XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogKFwidWstbmF2YmFyLVwiICsgYWxpZ24pXG4gICAgfSksIFtcbiAgICAgIHdyYXBDb250ZW50XG4gICAgICAgID8gaCgnZGl2JywgY2hpbGRyZW4pXG4gICAgICAgIDogY2hpbGRyZW5cbiAgICBdKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNsb3RzIChoLCBzbG90cykge1xuICByZXR1cm4gW1xuICAgIChzbG90cy5sZWZ0IHx8IHNsb3RzLmRlZmF1bHQpICYmIGgoRWxlbWVudE5hdmJhck5hdmlnYXRpb24sIFtcbiAgICAgIHNsb3RzLmxlZnQsIHNsb3RzLmRlZmF1bHRcbiAgICBdKSxcbiAgICAoc2xvdHMuY2VudGVyIHx8IHNsb3RzWydjZW50ZXItbGVmdCddIHx8IHNsb3RzWydjZW50ZXItcmlnaHQnXSkgJiYgaChFbGVtZW50TmF2YmFyTmF2aWdhdGlvbiwge1xuICAgICAgcHJvcHM6IHsgYWxpZ246ICdjZW50ZXInIH1cbiAgICB9LCBbXG4gICAgICBzbG90c1snY2VudGVyLWxlZnQnXSAmJiBoKEVsZW1lbnROYXZiYXJOYXZpZ2F0aW9uLCB7XG4gICAgICAgIHByb3BzOiB7IGFsaWduOiAnY2VudGVyLWxlZnQnIH1cbiAgICAgIH0sIHNsb3RzWydjZW50ZXItbGVmdCddKSxcbiAgICAgIHNsb3RzLmNlbnRlciAmJiBzbG90cy5jZW50ZXIsXG4gICAgICBzbG90c1snY2VudGVyLXJpZ2h0J10gJiYgaChFbGVtZW50TmF2YmFyTmF2aWdhdGlvbiwge1xuICAgICAgICBwcm9wczogeyBhbGlnbjogJ2NlbnRlci1yaWdodCcgfVxuICAgICAgfSwgc2xvdHNbJ2NlbnRlci1yaWdodCddKVxuICAgIF0pLFxuICAgIHNsb3RzLnJpZ2h0ICYmIGgoRWxlbWVudE5hdmJhck5hdmlnYXRpb24sIHtcbiAgICAgIHByb3BzOiB7IGFsaWduOiAncmlnaHQnIH1cbiAgICB9LCBzbG90cy5yaWdodClcbiAgXVxufVxuXG52YXIgRWxlbWVudE5hdmJhciA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBjb250YWluZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICB0cmFuc3BhcmVudDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHNsb3RzID0gcmVmLnNsb3RzO1xuICAgIHZhciBjb250YWluZXIgPSBwcm9wcy5jb250YWluZXI7XG4gICAgdmFyIHRyYW5zcGFyZW50ID0gcHJvcHMudHJhbnNwYXJlbnQ7XG4gICAgcmV0dXJuIGgoJ25hdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogWyd1ay1uYXZiYXInLCB7XG4gICAgICAgICd1ay1uYXZiYXItY29udGFpbmVyJzogY29udGFpbmVyICYmICF0cmFuc3BhcmVudCxcbiAgICAgICAgJ3VrLW5hdmJhci10cmFuc3BhcmVudCc6IHRyYW5zcGFyZW50XG4gICAgICB9XVxuICAgIH0pLCByZW5kZXJTbG90cyhoLCBzbG90cygpKSlcbiAgfVxufVxuXG52YXIgRWxlbWVudE5hdmJhckZ1bGwgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgZXhwYW5kZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdHJhbnNwYXJlbnQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBzbG90cyA9IHJlZi5zbG90cztcbiAgICB2YXIgZXhwYW5kZWQgPSBwcm9wcy5leHBhbmRlZDtcbiAgICB2YXIgdHJhbnNwYXJlbnQgPSBwcm9wcy50cmFuc3BhcmVudDtcbiAgICByZXR1cm4gaCgnbmF2JywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLW5hdmJhci1jb250YWluZXInLCB7XG4gICAgICAgICd1ay1uYXZiYXItdHJhbnNwYXJlbnQnOiB0cmFuc3BhcmVudFxuICAgICAgfV1cbiAgICB9KSwgW1xuICAgICAgaCgnZGl2Jywge1xuICAgICAgICBjbGFzczogWyd1ay1jb250YWluZXInLCB7XG4gICAgICAgICAgJ3VrLWNvbnRhaW5lci1leHBhbmQnOiBleHBhbmRlZFxuICAgICAgICB9XVxuICAgICAgfSwgW1xuICAgICAgICBoKCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICd1ay1uYXZiYXInXG4gICAgICAgIH0sIHJlbmRlclNsb3RzKGgsIHNsb3RzKCkpKVxuICAgICAgXSlcbiAgICBdKVxuICB9XG59XG5cbnZhciBFbGVtZW50TmF2YmFyRHJvcGJhciA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBzbGlkZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHNsaWRlID0gcHJvcHMuc2xpZGU7XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogWyd1ay1uYXZiYXItZHJvcGJhcicsIHtcbiAgICAgICAgJ3VrLW5hdmJhci1kcm9wYmFyLXNsaWRlJzogc2xpZGVcbiAgICAgIH1dXG4gICAgfSkpXG4gIH1cbn1cblxudmFyIEVsZW1lbnROYXZiYXJJdGVtID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdmJhci1pdGVtJ1xuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudE5hdmJhckxvZ28gPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICByZXR1cm4gaCgnc3BhbicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdmJhci1pdGVtIHVrLWxvZ28nXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBJY29uVG9nZ2xlID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIChoLCBjdHgpIHtcbiAgICB2YXIgcHJvcHMgPSBjdHgucHJvcHM7XG4gICAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGggfHwgMjA7XG4gICAgdmFyIGhlaWdodCA9IHByb3BzLmhlaWdodCB8fCAyMDtcbiAgICB2YXIgdmlld0JveCA9IHByb3BzLnZpZXdCb3ggfHwgJzAgMCAyMCAyMCc7XG4gICAgcmV0dXJuIGgoJ3N2ZycsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHZlcnNpb246ICcxLjEnLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB2aWV3Qm94OiB2aWV3Qm94XG4gICAgICB9LFxuICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgaW5uZXJIVE1MOiAnPHBhdGggZD1cIk0wIDloMjB2Mkgwek0wIDNoMjB2Mkgwek0wIDE1aDIwdjJIMHpcIi8+J1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnROYXZiYXJUb2dnbGUgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBpY29uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgaWNvbiQkMSA9IHByb3BzLmljb247XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIEljb24gPSBpY29uJCQxICYmIGgoRWxlbWVudEljb24sIHtcbiAgICAgIGNsYXNzOiAndWstbmF2YmFyLXRvZ2dsZS1pY29uJ1xuICAgIH0sIFsgaChJY29uVG9nZ2xlKSBdKTtcbiAgICByZXR1cm4gaCgnYScsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdmJhci10b2dnbGUnXG4gICAgfSksIFtcbiAgICAgIEljb24sXG4gICAgICB0aXRsZSAmJiBoKCdzcGFuJywge1xuICAgICAgICBjbGFzczogJ3VrLW1hcmdpbi1zbWFsbC1sZWZ0J1xuICAgICAgfSwgdGl0bGUpXG4gICAgXSlcbiAgfVxufVxuXG52YXIgRWxlbWVudE5hdmJhck5hdiA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiBoKCd1bCcsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdmJhci1uYXYnXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50TmF2YmFyTmF2SXRlbSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiB7fSxcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgc3VidGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGFjdGl2ZSA9IHByb3BzLmFjdGl2ZTtcbiAgICB2YXIgdGl0bGUgPSBwcm9wcy50aXRsZTtcbiAgICB2YXIgc3VidGl0bGUgPSBwcm9wcy5zdWJ0aXRsZTtcbiAgICB2YXIgaWNvbiQkMSA9IHByb3BzLmljb247XG4gICAgdmFyIGhyZWYgPSBwcm9wcy5ocmVmO1xuICAgIHZhciB0YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gICAgdmFyIEljb24gPSBpY29uJCQxICYmIGgoRWxlbWVudEljb24sIHtcbiAgICAgIGNsYXNzOiAndWstbWFyZ2luLXNtYWxsLXJpZ2h0J1xuICAgIH0sIFsgaWNvbiQkMSBdKTtcbiAgICB2YXIgU3VidGl0bGUgPSBzdWJ0aXRsZSAmJiBoKCdkaXYnLCBbIHRpdGxlLCBoKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdmJhci1zdWJ0aXRsZSdcbiAgICB9LCBzdWJ0aXRsZSkgXSk7XG4gICAgcmV0dXJuIGgoJ2xpJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiB7ICd1ay1hY3RpdmUnOiBhY3RpdmUgfVxuICAgIH0pLCBbXG4gICAgICBoKCdhJywge1xuICAgICAgICBhdHRyczogeyBocmVmOiBocmVmLCB0YXJnZXQ6IHRhcmdldCB9XG4gICAgICB9LCBbXG4gICAgICAgIEljb24sXG4gICAgICAgIFN1YnRpdGxlIHx8IHRpdGxlXG4gICAgICBdKSxcbiAgICAgIGNoaWxkcmVuXG4gICAgXSlcbiAgfVxufVxuXG52YXIgRWxlbWVudE5hdmJhck5hdkRyb3Bkb3duTmF2ID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgoJ3VsJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndWstbmF2IHVrLW5hdmJhci1kcm9wZG93bi1uYXYnXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBuYXZiYXIgPSB7XG4gIG5hbWU6ICdWa05hdmJhcicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50TmF2YmFyLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnROYXZiYXIucmVuZGVyXG59XG5cbnZhciBuYXZiYXJGdWxsID0ge1xuICBuYW1lOiAnVmtOYXZiYXJGdWxsJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnROYXZiYXJGdWxsLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnROYXZiYXJGdWxsLnJlbmRlclxufVxuXG52YXIgU0hPVyQxID0gU0hPVztcbnZhciBISURFJDEgPSBISURFO1xudmFyIG5hdmJhckRyb3BiYXIgPSB7XG4gIG5hbWU6ICdWa05hdmJhckRyb3BiYXInLFxuICBwcm9wczoge1xuICAgIG1vZGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdzbGlkZScsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eKHNsaWRlfHB1c2gpJC8udGVzdCh2YWwpOyB9XG4gICAgfSxcbiAgICBkdXJhdGlvbjoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMjAwXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdHJhbnNpdGlvbkRyb3BiYXI6IGZ1bmN0aW9uIHRyYW5zaXRpb25Ecm9wYmFyIChkcm9wZG93bkVsKSB7XG4gICAgICB2YXIgZWwgPSBkcm9wZG93bkVsO1xuICAgICAgdmFyIG1hcmdpblRvcCA9IHRvRmxvYXQoY3NzKGVsLCAnbWFyZ2luLXRvcCcpKTtcbiAgICAgIHZhciBtYXJnaW5Cb3R0b20gPSB0b0Zsb2F0KGNzcyhlbCwgJ21hcmdpbi1ib3R0b20nKSk7XG4gICAgICB2YXIgaGVpZ2h0JCQxID0gZWwub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luVG9wICsgbWFyZ2luQm90dG9tO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVG8oaGVpZ2h0JCQxLCBlbCk7XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uVG86IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAobmV3SGVpZ2h0LCBlbCkge1xuICAgICAgdmFyIGRyb3BiYXIgPSB0aGlzLiRyZWZzLmRyb3BiYXI7XG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gaXNWaXNpYmxlKGRyb3BiYXIpID8gaGVpZ2h0KGRyb3BiYXIpIDogMDtcbiAgICAgIGVsID0gb2xkSGVpZ2h0IDwgbmV3SGVpZ2h0ICYmIGVsO1xuICAgICAgY3NzKGVsLCB7IGhlaWdodDogb2xkSGVpZ2h0LCBvdmVyZmxvdzogJ2hpZGRlbicgfSk7XG4gICAgICBoZWlnaHQoZHJvcGJhciwgb2xkSGVpZ2h0KTtcbiAgICAgIFRyYW5zaXRpb24uY2FuY2VsKFtlbCwgZHJvcGJhcl0pO1xuICAgICAgcmV0dXJuIFRyYW5zaXRpb25cbiAgICAgICAgLnN0YXJ0KFtlbCwgZHJvcGJhcl0sIHsgaGVpZ2h0OiBuZXdIZWlnaHQgfSwgdGhpcy5kdXJhdGlvbilcbiAgICAgICAgLmNhdGNoKG5vb3ApXG4gICAgICAgIC5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNzcyhlbCwgeyBoZWlnaHQ6ICcnLCBvdmVyZmxvdzogJycgfSk7IH0pXG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgZHJvcGRvd25zID0gZ2V0KHRoaXMsICckY2hpbGRyZW4nLCBbXSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvTmF2YmFyTmF2RHJvcGRvd24vLnRlc3QoY2hpbGQuJG9wdGlvbnMubmFtZSk7IH0pXG4gICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLiRjaGlsZHJlblswXTsgfSk7XG4gICAgZHJvcGRvd25zLmZvckVhY2goZnVuY3Rpb24gKGRyb3ApIHtcbiAgICAgIGRyb3AuJHZub2RlLmRhdGEuY2xhc3NbJ3VrLW5hdmJhci1kcm9wZG93bi1kcm9wYmFyJ10gPSB0cnVlO1xuICAgICAgZHJvcC4kb24oU0hPVyQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMkMS4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS50cmFuc2l0aW9uRHJvcGJhcihkcm9wLiRlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBkcm9wLiRvbihISURFJDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcyQxLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRoZXJlQXJlQWN0aXZlRHJvcHMgPSBhY3RpdmUgJiYgd2l0aGluKGFjdGl2ZS4kZWwsIHRoaXMkMS4kZWwpO1xuICAgICAgICAgIGlmICghdGhlcmVBcmVBY3RpdmVEcm9wcykge1xuICAgICAgICAgICAgdGhpcyQxLnRyYW5zaXRpb25Ecm9wYmFyKGRyb3AuJGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgIGNsYXNzOiAndWstcG9zaXRpb24tcmVsYXRpdmUnXG4gICAgfSwgW1xuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdCxcbiAgICAgIGgoRWxlbWVudE5hdmJhckRyb3BiYXIsIHtcbiAgICAgICAgcmVmOiAnZHJvcGJhcicsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgc2xpZGU6IHRoaXMubW9kZSA9PT0gJ3NsaWRlJ1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pXG4gIH1cbn1cblxudmFyIG5hdmJhcl9JdGVtID0ge1xuICBuYW1lOiAnVmtOYXZiYXJJdGVtJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBFbGVtZW50TmF2YmFySXRlbS5yZW5kZXJcbn1cblxudmFyIG5hdmJhcl9Mb2dvID0ge1xuICBuYW1lOiAnVmtOYXZiYXJMb2dvJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBFbGVtZW50TmF2YmFyTG9nby5yZW5kZXJcbn1cblxudmFyIG5hdmJhcl9Ub2dnbGUgPSB7XG4gIG5hbWU6ICdWa05hdmJhclRvZ2dsZScsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50TmF2YmFyVG9nZ2xlLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnROYXZiYXJUb2dnbGUucmVuZGVyXG59XG5cbnZhciBuYXZiYXJfTmF2ID0ge1xuICBuYW1lOiAnVmtOYXZiYXJOYXYnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IEVsZW1lbnROYXZiYXJOYXYucmVuZGVyXG59XG5cbnZhciBuYXZiYXJfTmF2X0l0ZW0gPSB7XG4gIG5hbWU6ICdWa05hdmJhck5hdkl0ZW0nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogYXNzaWduKHt9LCBFbGVtZW50TmF2YmFyTmF2SXRlbS5wcm9wcywge1xuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH1cbiAgfSksXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICBwcm9wcy5pY29uID0gcHJvcHMuaWNvbiAmJiBoKChcInZrLWljb25zLVwiICsgKHByb3BzLmljb24pKSk7XG4gICAgcmV0dXJuIGgoRWxlbWVudE5hdmJhck5hdkl0ZW0sIG1lcmdlRGF0YShkYXRhLCB7IHByb3BzOiBwcm9wcyB9KSlcbiAgfVxufVxuXG52YXIgU0hPVyQyID0gU0hPVztcbnZhciBuYXZiYXJfTmF2X0Ryb3Bkb3duID0ge1xuICBuYW1lOiAnVmtOYXZiYXJOYXZEcm9wZG93bicsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBzdWJ0aXRsZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcbiAgICBqdXN0aWZpZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYWxpZ246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGlzUnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gL14obGVmdHxjZW50ZXJ8cmlnaHQpJC8udGVzdCh2YWwpOyB9XG4gICAgfSxcbiAgICBuYXZiYXJBbGlnbmVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG1vZGU6IERyb3AucHJvcHMubW9kZSxcbiAgICBvZmZzZXQ6IERyb3AucHJvcHMub2Zmc2V0LFxuICAgIGFuaW1hdGlvbjogRHJvcC5wcm9wcy5hbmltYXRpb24sXG4gICAgZHVyYXRpb246IERyb3AucHJvcHMuZHVyYXRpb24sXG4gICAgZGVsYXlTaG93OiBEcm9wLnByb3BzLmRlbGF5U2hvdyxcbiAgICBkZWxheUhpZGU6IERyb3AucHJvcHMuZGVsYXlIaWRlXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbmF2YmFyOiBmdW5jdGlvbiBuYXZiYXIgKCkge1xuICAgICAgcmV0dXJuIHF1ZXJ5KCchLnVrLW5hdmJhcicsIHRoaXMuJGVsKVxuICAgIH0sXG4gICAgZHJvcGJhcjogZnVuY3Rpb24gZHJvcGJhciAoKSB7XG4gICAgICByZXR1cm4gL05hdmJhckRyb3BiYXIvLnRlc3QoZ2V0KHRoaXMsICckcGFyZW50LiRvcHRpb25zLm5hbWUnLCAnJykpXG4gICAgICAgID8gdGhpcy4kcGFyZW50XG4gICAgICAgIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBtb2RlID0gcmVmLm1vZGU7XG4gICAgdmFyIHJlZiQxID0gdGhpcy4kcmVmcy5kcm9wO1xuICAgIHZhciBvbiA9IHJlZiQxLm9uO1xuICAgIHZhciB0b2dnbGUgPSByZWYkMS50b2dnbGU7XG4gICAgdmFyIHNob3cgPSByZWYkMS5zaG93O1xuICAgIHZhciBoaWRlID0gcmVmJDEuaGlkZTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy4kcmVmcy5kcm9wLiRyZWZzLnRhcmdldDtcbiAgICBpZiAoL2NsaWNrLy50ZXN0KG1vZGUpIHx8IGhhc1RvdWNoKSB7XG4gICAgICBvbih0YXJnZXQsICdjbGljaycsIHRvZ2dsZSk7XG4gICAgfVxuICAgIGlmICgvaG92ZXIvLnRlc3QobW9kZSkpIHtcbiAgICAgIG9uKHRhcmdldCwgcG9pbnRlckVudGVyLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoaXNUb3VjaChlKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2hvdygpO1xuICAgICAgfSk7XG4gICAgICBvbih0aGlzLmRyb3BiYXIgPyB0aGlzLmRyb3BiYXIuJGVsIDogdGFyZ2V0LCBwb2ludGVyTGVhdmUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBoaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgdmFyIG9iaiwgb2JqJDEsIG9iaiQyO1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciB0aXRsZSA9IHJlZi50aXRsZTtcbiAgICB2YXIganVzdGlmaWVkID0gcmVmLmp1c3RpZmllZDtcbiAgICB2YXIgbW9kZSA9IHJlZi5tb2RlO1xuICAgIHZhciBhbGlnbiA9IHJlZi5hbGlnbjtcbiAgICB2YXIgbmF2YmFyQWxpZ25lZCA9IHJlZi5uYXZiYXJBbGlnbmVkO1xuICAgIHZhciBzdWJ0aXRsZSA9IHJlZi5zdWJ0aXRsZTtcbiAgICB2YXIgZGVmYXVsdFNsb3RzID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW5Ob2RlcyA9IGRlZmF1bHRTbG90cy5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udGFnOyB9KTtcbiAgICB2YXIgY29sQ291bnQgPSBjaGlsZHJlbk5vZGVzLmxlbmd0aDtcbiAgICB2YXIgU3VidGl0bGUgPSBzdWJ0aXRsZSAmJiBoKCdkaXYnLCBbIHRpdGxlLCBoKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3VrLW5hdmJhci1zdWJ0aXRsZSdcbiAgICB9LCBzdWJ0aXRsZSkgXSk7XG4gICAgcmV0dXJuIGgoJ2xpJywgW1xuICAgICAgaCgnYScsIFtTdWJ0aXRsZSB8fCB0aXRsZV0pLFxuICAgICAgaChEcm9wLCB7XG4gICAgICAgIG9uOiAoIG9iaiA9IHt9LCBvYmpbU0hPVyQyXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfSwgb2JqKSxcbiAgICAgICAgbmF0aXZlT246ICggb2JqJDEgPSB7fSwgb2JqJDFbcG9pbnRlckVudGVyXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzJDEuJHJlZnMuZHJvcC5jbGVhclRpbWVycygpO1xuICAgICAgICAgICAgaWYgKC9ob3Zlci8udGVzdChtb2RlKSkge1xuICAgICAgICAgICAgICB0aGlzJDEuJHJlZnMuZHJvcC5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgb2JqJDFbcG9pbnRlckxlYXZlXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMkMS5kcm9wYmFyICYmIC9ob3Zlci8udGVzdChtb2RlKSkge1xuICAgICAgICAgICAgICB0aGlzJDEuJHJlZnMuZHJvcC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgb2JqJDEpLFxuICAgICAgICByZWY6ICdkcm9wJyxcbiAgICAgICAgY2xhc3M6ICggb2JqJDIgPSB7XG4gICAgICAgICAgJ3VrLW5hdmJhci1kcm9wZG93bi1kcm9wYmFyJzogQm9vbGVhbih0aGlzLmRyb3BiYXIpLFxuICAgICAgICAgICd1ay1uYXZiYXItZHJvcGRvd24tYm91bmRhcnknOiBqdXN0aWZpZWQgfHwgbmF2YmFyQWxpZ25lZFxuICAgICAgICB9LCBvYmokMlsoXCJ1ay1uYXZiYXItZHJvcGRvd24td2lkdGgtXCIgKyBjb2xDb3VudCldID0gY29sQ291bnQgPiAxICYmICFqdXN0aWZpZWQsIG9iaiQyKSxcbiAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgdGhpcy4kcHJvcHMsIHtcbiAgICAgICAgICBtb2RlOiAnJyxcbiAgICAgICAgICBwb3NpdGlvbjoganVzdGlmaWVkXG4gICAgICAgICAgICA/ICdib3R0b20tanVzdGlmeSdcbiAgICAgICAgICAgIDogKFwiYm90dG9tLVwiICsgYWxpZ24pLFxuICAgICAgICAgIG1haW5DbGFzczogJ3VrLW5hdmJhci1kcm9wZG93bicsXG4gICAgICAgICAgZmxpcDoganVzdGlmaWVkID8gJ3gnIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGJvdW5kYXJ5OiAnIW5hdicsXG4gICAgICAgICAgYm91bmRhcnlBbGlnbjoganVzdGlmaWVkIHx8IG5hdmJhckFsaWduZWRcbiAgICAgICAgfSlcbiAgICAgIH0sIFtcbiAgICAgICAgY29sQ291bnQgPj0gMlxuICAgICAgICAgID8gaChHcmlkLCB7XG4gICAgICAgICAgICBjbGFzczogW1xuICAgICAgICAgICAgICAndWstbmF2YmFyLWRyb3Bkb3duLWdyaWQnLFxuICAgICAgICAgICAgICAoXCJ1ay1jaGlsZC13aWR0aC0xLVwiICsgY29sQ291bnQgKyAoY29sQ291bnQgPiAyID8gJ0BtJyA6ICcnKSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LCBjaGlsZHJlbk5vZGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGgoJ2RpdicsIFsgY2hpbGQgXSk7IH1cbiAgICAgICAgICApKVxuICAgICAgICAgIDogZGVmYXVsdFNsb3RzXG4gICAgICBdKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIG5hdmJhcl9OYXZfRHJvcGRvd25fTmF2ID0ge1xuICBuYW1lOiAnVmtOYXZiYXJOYXZEcm9wZG93bk5hdicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogRWxlbWVudE5hdmJhck5hdkRyb3Bkb3duTmF2LnJlbmRlclxufVxuXG52YXIgTkFNRVNQQUNFJDIgPSAnX192a05vdGlmaWNhdGlvbic7XG52YXIgTWVzc2FnZURpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFtOQU1FU1BBQ0UkMl0gPSB7fTtcbiAgICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb0Nsb3NlKGVsLCB2bm9kZSk7IH07XG4gICAgdmFyIG9wdHMgPSBlbFtOQU1FU1BBQ0UkMl0ub3B0aW9ucyA9IGJpbmRpbmcudmFsdWU7XG4gICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgZWxbTkFNRVNQQUNFJDJdLnRpbWVyID0gc2V0VGltZW91dChjbG9zZSwgb3B0cy50aW1lb3V0KTtcbiAgICB9XG4gICAgb24oZWwsICdjbGljaycsIGNsb3NlKTtcbiAgICBvbihlbCwgcG9pbnRlckVudGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZWxbTkFNRVNQQUNFJDJdLnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChlbFtOQU1FU1BBQ0UkMl0udGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9uKGVsLCBwb2ludGVyTGVhdmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICAgICAgZWxbTkFNRVNQQUNFJDJdLnRpbWVyID0gc2V0VGltZW91dChjbG9zZSwgb3B0cy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKGVsKSB7XG4gICAgaWYgKCFlbFtOQU1FU1BBQ0UkMl0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoZWxbTkFNRVNQQUNFJDJdLnRpbWVyKTtcbiAgICBkZWxldGUgZWxbTkFNRVNQQUNFJDJdO1xuICB9XG59XG5mdW5jdGlvbiBkb0Nsb3NlIChlbCwgdm5vZGUpIHtcbiAgY2xlYXJUaW1lb3V0KGVsW05BTUVTUEFDRSQyXS50aW1lcik7XG4gIHRyaWdnZXIoZWwsICdjbG9zZScpO1xufVxuXG52YXIgTWVzc2FnZVRyYW5zaXRpb24gPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGVmID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY3NzOiBmYWxzZSxcbiAgICAgICAgYXBwZWFyOiB0cnVlLFxuICAgICAgICB0YWc6ICdkaXYnXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyIChlbCwgZG9uZSkge1xuICAgICAgICAgIHZhciBtYXJnaW5Cb3R0b20gPSB0b0Zsb2F0KGNzcyhlbCwgJ21hcmdpbkJvdHRvbScpKTtcbiAgICAgICAgICBjc3MoZWwsIHsgb3BhY2l0eTogMCwgbWFyZ2luVG9wOiAtZWwub2Zmc2V0SGVpZ2h0LCBtYXJnaW5Cb3R0b206IDAgfSk7XG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChlbCwge1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogbWFyZ2luQm90dG9tXG4gICAgICAgICAgfSkudGhlbihkb25lKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlIChlbCwgZG9uZSkge1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoZWwsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IC1lbC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206IDBcbiAgICAgICAgICB9KS50aGVuKGRvbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaCgndHJhbnNpdGlvbi1ncm91cCcsIG1lcmdlRGF0YShkYXRhLCBkZWYpLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudE5vdGlmaWNhdGlvbiA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3RvcC1jZW50ZXInLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAvXih0b3B8Ym90dG9tKS0obGVmdHxjZW50ZXJ8cmlnaHQpJC8udGVzdCh2YWwpOyB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICAgIHJldHVybiBoKCdkaXYnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IFtcbiAgICAgICAgJ3VrLW5vdGlmaWNhdGlvbicsXG4gICAgICAgIChcInVrLW5vdGlmaWNhdGlvbi1cIiArIHBvc2l0aW9uKVxuICAgICAgXVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudE5vdGlmaWNhdGlvbkNsb3NlID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICByZXR1cm4gaChFbGVtZW50SWNvbkxpbmssIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW5vdGlmaWNhdGlvbi1jbG9zZSB1ay1jbG9zZSdcbiAgICB9KSwgW1xuICAgICAgaChJY29uQ2xvc2UpXG4gICAgXSlcbiAgfVxufVxuXG52YXIgRWxlbWVudE5vdGlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgc3RhdHVzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gIXZhbCB8fCAvXihwcmltYXJ5fHN1Y2Nlc3N8d2FybmluZ3xkYW5nZXIpJC8udGVzdCh2YWwpOyB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHN0YXR1cyA9IHByb3BzLnN0YXR1cztcbiAgICByZXR1cm4gaCgnZGl2JywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLW5vdGlmaWNhdGlvbi1tZXNzYWdlJywgKCBvYmogPSB7fSwgb2JqWyhcInVrLW5vdGlmaWNhdGlvbi1tZXNzYWdlLVwiICsgc3RhdHVzKV0gPSBzdGF0dXMsIG9iaildXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBpc05vdFByb2QgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xudmFyIG5vdGlmaWNhdGlvbiA9IHtcbiAgbmFtZTogJ1ZrTm90aWZpY2F0aW9uJyxcbiAgZGlyZWN0aXZlczoge1xuICAgIE1lc3NhZ2VEaXJlY3RpdmU6IE1lc3NhZ2VEaXJlY3RpdmVcbiAgfSxcbiAgcHJvcHM6IGFzc2lnbih7fSwgRWxlbWVudE5vdGlmaWNhdGlvbi5wcm9wcywge1xuICAgIHRpbWVvdXQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDUwMDBcbiAgICB9LFxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGlmICghdmFsLmV2ZXJ5KGZ1bmN0aW9uIChtKSB7IHJldHVybiBpc09iamVjdChtKSB8fCBpc1N0cmluZyhtKTsgfSkpIHtcbiAgICAgICAgICBpc05vdFByb2QgJiYgd2Fybigndmstbm90aWZpY2F0aW9uIC0+IGVhY2ggbWVzc2FnZSBpcyBleHBlY3RlZCBhcyBPYmplY3Qgb3IgU3RyaW5nJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0YXR1czogRWxlbWVudE5vdGlmaWNhdGlvbk1lc3NhZ2UucHJvcHMuc3RhdHVzXG4gIH0pLFxuICBjb21wdXRlZDoge1xuICAgICRtZXNzYWdlczogZnVuY3Rpb24gJG1lc3NhZ2VzICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgdmFyIG1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcy5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgbXNnID0gaXNTdHJpbmcodmFsKSA/IHsgbWVzc2FnZTogdmFsIH0gOiB2YWw7XG4gICAgICAgIHJldHVybiBhc3NpZ24oeyBzdGF0dXM6IHRoaXMkMS5zdGF0dXMsIHRpbWVvdXQ6IHRoaXMkMS50aW1lb3V0IH0sIG1zZylcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZXMgPSB0aGlzLnJlbW92ZUR1cGxpY2F0ZXMobWVzc2FnZXMpO1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdHJpZ2dlclJlbW92ZTogZnVuY3Rpb24gdHJpZ2dlclJlbW92ZSAobXNnKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgIHRoaXMuY2xvc2VRdWV1ZSA9IHRoaXMuY2xvc2VRdWV1ZSB8fCBbXTtcbiAgICAgIHRoaXMuY2xvc2VRdWV1ZS5wdXNoKG1zZyk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdLmNvbmNhdCggdGhpcyQxLmNsb3NlUXVldWUgKTtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gW10uY29uY2F0KCB0aGlzJDEuJG1lc3NhZ2VzICk7XG4gICAgICAgIHRoaXMkMS5jbG9zZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgIHZhciBpbmRleCA9IG1lc3NhZ2VzLmluZGV4T2YobWVzc2FnZXMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtID09PSBtc2c7IH0pWzBdKTtcbiAgICAgICAgICBtZXNzYWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcyQxLiRlbWl0KCd1cGRhdGU6bWVzc2FnZXMnLCBtZXNzYWdlcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlbW92ZUR1cGxpY2F0ZXM6IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMgKHZhbHVlcykge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBbXTtcbiAgICAgIHZhciBpc0R1cGxpY2F0ZWQgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBtZXNzYWdlcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMkMS5nZXRNZXNzYWdlSWQobSkgPT09IHRoaXMkMS5nZXRNZXNzYWdlSWQobXNnKVxuICAgICAgfSkubGVuZ3RoOyB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRHVwbGljYXRlZCh2YWx1ZXNbaV0pKSB7XG4gICAgICAgICAgaXNOb3RQcm9kICYmIHRpcCgndmstbm90aWZpY2F0aW9uIC0+IGR1cGxpY2F0ZSBtZXNzYWdlcyBhcmUgZmlsdGVyZWQgb3V0LCBjb25zaWRlciBhZGRpbmcgYSB1bmlxdWUgYGtleWAgdG8gdGhvc2UuJyk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlcy5wdXNoKHZhbHVlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZXNcbiAgICB9LFxuICAgIGdldE1lc3NhZ2VJZDogZnVuY3Rpb24gZ2V0TWVzc2FnZUlkIChtc2cpIHtcbiAgICAgIHZhciB2YWxpZEtleXMgPSBbJ21lc3NhZ2UnLCAnc3RhdHVzJywgJ2tleScsICd0aW1lb3V0J107XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMobXNnKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiB2YWxpZEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrOyB9KVswXTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gbXNnW2tdOyB9KVxuICAgICAgICAuam9pbignOicpXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBwb3NpdGlvbiA9IHJlZi5wb3NpdGlvbjtcbiAgICB2YXIgTWVzc2FnZVNsb3QgPSBnZXQodGhpcywgJyRzY29wZWRTbG90cy5kZWZhdWx0JywgZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gbXNnLm1lc3NhZ2U7IH0pO1xuICAgIHJldHVybiBoKEVsZW1lbnROb3RpZmljYXRpb24sIHtcbiAgICAgIHByb3BzOiB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9XG4gICAgfSwgW1xuICAgICAgaChNZXNzYWdlVHJhbnNpdGlvbiwgW1xuICAgICAgICB0aGlzLiRtZXNzYWdlcy5tYXAoZnVuY3Rpb24gKG1zZywgaW5kZXgpIHsgcmV0dXJuIGgoRWxlbWVudE5vdGlmaWNhdGlvbk1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGtleTogdGhpcyQxLmdldE1lc3NhZ2VJZChtc2cpLFxuICAgICAgICAgICAgcHJvcHM6IG1zZyxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgIG5hbWU6ICdtZXNzYWdlLWRpcmVjdGl2ZScsXG4gICAgICAgICAgICAgIHZhbHVlOiBtc2dcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS50cmlnZ2VyUmVtb3ZlKG1zZyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBbXG4gICAgICAgICAgICBNZXNzYWdlU2xvdChtc2cpLFxuICAgICAgICAgICAgaChFbGVtZW50Tm90aWZpY2F0aW9uQ2xvc2UpXG4gICAgICAgICAgXSk7IH1cbiAgICAgICAgKVxuICAgICAgXSlcbiAgICBdKVxuICB9XG59XG5cbnZhciBTSE9XTiQxID0gJ3Nob3duJztcbnZhciBISURERU4kMSA9ICdoaWRkZW4nO1xudmFyIFRPR0dMRSQxID0gJ3VwZGF0ZTpzaG93JztcbnZhciBLRVlVUCQxID0gJ2tleXVwJztcblxudmFyIGFjdGl2ZSQyO1xudmFyIHNjcm9sbGJhcldpZHRoO1xudmFyIHdpbiQzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93O1xudmFyIGJvZHkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmJvZHk7XG52YXIgZG9jJDQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbnZhciBzY3JvbGw7XG52YXIgZ2V0U2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aWR0aCh3aW4kMykgLSBkb2MkNC5vZmZzZXRXaWR0aDsgfTtcbnZhciBldmVudHMgPSB7XG4gIGJlZm9yZUVudGVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgcmVmID0gZWwuX192a09mZmNhbnZhcztcbiAgICB2YXIgJHJlZnMgPSByZWYuJHJlZnM7XG4gICAgdmFyICRwcm9wcyA9IHJlZi4kcHJvcHM7XG4gICAgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgIHNjcm9sbCA9IHNjcm9sbCB8fCB7IHg6IHdpbiQzLnBhZ2VYT2Zmc2V0LCB5OiB3aW4kMy5wYWdlWU9mZnNldCB9O1xuICAgIGFkZENsYXNzKGRvYyQ0LCAndWstb2ZmY2FudmFzLXBhZ2UnKTtcbiAgICBhZGRDbGFzcyhib2R5LCAndWstb2ZmY2FudmFzLWNvbnRhaW5lcicpO1xuICAgIGlmICgkcHJvcHMuZmxpcHBlZCkge1xuICAgICAgYWRkQ2xhc3MoJHJlZnMuYmFyLCAndWstb2ZmY2FudmFzLWJhci1mbGlwJyk7XG4gICAgICBhZGRDbGFzcygkcmVmcy5jb250ZW50LnBhcmVudE5vZGUsICd1ay1vZmZjYW52YXMtZmxpcCcpO1xuICAgIH1cbiAgICBpZiAoJHByb3BzLm92ZXJsYXkpIHtcbiAgICAgIGFkZENsYXNzKGJvZHksICd1ay1vZmZjYW52YXMtb3ZlcmxheScpO1xuICAgIH1cbiAgICBoZWlnaHQoZWwpO1xuICB9LFxuICBhZnRlckVudGVyOiBmdW5jdGlvbiBhZnRlckVudGVyIChlbCkge1xuICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICB2YXIgJHByb3BzID0gcmVmLiRwcm9wcztcbiAgICBpZiAoJHByb3BzLm92ZXJsYXkpIHtcbiAgICAgIHdpZHRoKCRyZWZzLmNvbnRlbnQsIHdpZHRoKHdpbiQzKSAtIHNjcm9sbGJhcldpZHRoKTtcbiAgICAgIGhlaWdodCgkcmVmcy5jb250ZW50LCBoZWlnaHQod2luJDMpKTtcbiAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgJHJlZnMuY29udGVudC5zY3JvbGxUb3AgPSBzY3JvbGwueTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlJDIgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgIGFjdGl2ZSQyLiRlbWl0KFNIT1dOJDEpO1xuICB9LFxuICBhZnRlckxlYXZlOiBmdW5jdGlvbiBhZnRlckxlYXZlIChlbCkge1xuICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICB2YXIgJHByb3BzID0gcmVmLiRwcm9wcztcbiAgICBpZiAoISRwcm9wcy5vdmVybGF5KSB7XG4gICAgICBzY3JvbGwgPSB7IHg6IHdpbiQzLnBhZ2VYT2Zmc2V0LCB5OiB3aW4kMy5wYWdlWU9mZnNldCB9O1xuICAgIH0gZWxzZSBpZiAoIXNjcm9sbCkge1xuICAgICAgdmFyIHJlZiQxID0gJHJlZnMuY29udGVudDtcbiAgICAgIHZhciB4ID0gcmVmJDEuc2Nyb2xsTGVmdDtcbiAgICAgIHZhciB5ID0gcmVmJDEuc2Nyb2xsVG9wO1xuICAgICAgc2Nyb2xsID0geyB4OiB4LCB5OiB5IH07XG4gICAgfVxuICAgIHJlbW92ZUNsYXNzKCRyZWZzLmJhciwgJ3VrLW9mZmNhbnZhcy1iYXItZmxpcCcpO1xuICAgIHJlbW92ZUNsYXNzKCRyZWZzLmNvbnRlbnQucGFyZW50Tm9kZSwgJ3VrLW9mZmNhbnZhcy1mbGlwJyk7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jJDQsICd1ay1vZmZjYW52YXMtcGFnZScpO1xuICAgIHJlbW92ZUNsYXNzKGJvZHksICd1ay1vZmZjYW52YXMtY29udGFpbmVyJyk7XG4gICAgcmVtb3ZlQ2xhc3MoYm9keSwgJ3VrLW9mZmNhbnZhcy1vdmVybGF5Jyk7XG4gICAgYm9keS5zY3JvbGxUb3AgPSBzY3JvbGwueTtcbiAgICBjc3MoYm9keSwgJ292ZXJmbG93WScsICcnKTtcbiAgICBjc3MoZG9jJDQsICdvdmVyZmxvd1knLCAnJyk7XG4gICAgd2lkdGgoJHJlZnMuY29udGVudCwgJycpO1xuICAgIGhlaWdodCgkcmVmcy5jb250ZW50LCAnJyk7XG4gICAgd2luJDMuc2Nyb2xsVG8oc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgICBzY3JvbGwgPSBudWxsO1xuICAgIGlmIChhY3RpdmUkMiA9PT0gZWwuX192a09mZmNhbnZhcykge1xuICAgICAgYWN0aXZlJDIgPSBudWxsO1xuICAgIH1cbiAgICBlbC5fX3ZrT2ZmY2FudmFzLiRlbWl0KEhJRERFTiQxKTtcbiAgfVxufTtcbm9uKGRvYyQ0LCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICBpZiAoIWFjdGl2ZSQyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyICRyZWZzID0gYWN0aXZlJDIuJHJlZnM7XG4gIHZhciAkcHJvcHMgPSBhY3RpdmUkMi4kcHJvcHM7XG4gIHZhciBjbGlja2VkT3V0ID0gISRyZWZzLmJhci5jb250YWlucyhlLnRhcmdldCk7XG4gIGlmIChjbGlja2VkT3V0ICYmICEkcHJvcHMuc3R1Y2spIHtcbiAgICBhY3RpdmUkMi4kZW1pdChUT0dHTEUkMSwgZmFsc2UpO1xuICB9XG59KTtcbm9uKGRvYyQ0LCAna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICBhY3RpdmUkMiAmJiBhY3RpdmUkMi4kZW1pdChLRVlVUCQxLCBlKTtcbn0pO1xuXG52YXIgRWxlbWVudE9mZmNhbnZhcyA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiBoKCdkaXYnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6ICd1ay1vZmZjYW52YXMnLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgfVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudE9mZmNhbnZhc0NvbnRlbnQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICByZXR1cm4gaCgnZGl2JywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndWstb2ZmY2FudmFzLWNvbnRlbnQnXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50T2ZmY2FudmFzQmFyID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3VrLW9mZmNhbnZhcy1iYXInXG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBFbGVtZW50T2ZmY2FudmFzQ2xvc2UgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbGFyZ2U6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBsYXJnZSA9IHByb3BzLmxhcmdlO1xuICAgIHZhciBkZWYgPSB7XG4gICAgICBjbGFzczogWyd1ay1vZmZjYW52YXMtY2xvc2UgdWstY2xvc2UgdWstaWNvbicsIHtcbiAgICAgICAgJ3VrLWNsb3NlLWxhcmdlJzogbGFyZ2VcbiAgICAgIH1dLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoKCdidXR0b24nLCBtZXJnZURhdGEoZGF0YSwgZGVmKSwgW1xuICAgICAgaChsYXJnZSA/IEljb25DbG9zZUxhcmdlIDogSWNvbkNsb3NlKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIFRyYW5zaXRpb25Ob25lID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNzczogZmFsc2VcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKGVsLCBkb25lKSB7IHJldHVybiBkb25lKCk7IH0sXG4gICAgICAgIGxlYXZlOiBmdW5jdGlvbiAoZWwsIGRvbmUpIHsgcmV0dXJuIGRvbmUoKTsgfSxcbiAgICAgICAgYmVmb3JlRW50ZXI6IGZ1bmN0aW9uIGJlZm9yZUVudGVyIChlbCkge1xuICAgICAgICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgICAgICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICAgICAgICB2YXIgJHByb3BzID0gcmVmLiRwcm9wcztcbiAgICAgICAgICBldmVudHMuYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICAgIGNzcyhkb2MkNCwgJ292ZXJmbG93WScsIHNjcm9sbGJhcldpZHRoICYmICRwcm9wcy5vdmVybGF5XG4gICAgICAgICAgICA/ICdzY3JvbGwnXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhZGRDbGFzcyhlbCwgJ3VrLW9wZW4nKTtcbiAgICAgICAgICBhZGRDbGFzcygkcmVmcy5iYXIsICd1ay1vZmZjYW52YXMtbm9uZScpO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlckVudGVyOiBmdW5jdGlvbiBhZnRlckVudGVyIChlbCkge1xuICAgICAgICAgIGV2ZW50cy5hZnRlckVudGVyKGVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJMZWF2ZTogZnVuY3Rpb24gYWZ0ZXJMZWF2ZSAoZWwpIHtcbiAgICAgICAgICB2YXIgcmVmID0gZWwuX192a09mZmNhbnZhcztcbiAgICAgICAgICB2YXIgJHJlZnMgPSByZWYuJHJlZnM7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsICd1ay1vcGVuJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoJHJlZnMuYmFyLCAndWstb2ZmY2FudmFzLW5vbmUnKTtcbiAgICAgICAgICBldmVudHMuYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoKCd0cmFuc2l0aW9uJywgbWVyZ2VEYXRhKGRlZiwgZGF0YSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBUcmFuc2l0aW9uUHVzaCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBkZWYgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjc3M6IGZhbHNlXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgYmVmb3JlRW50ZXI6IGZ1bmN0aW9uIGJlZm9yZUVudGVyIChlbCkge1xuICAgICAgICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgICAgICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICAgICAgICB2YXIgJHByb3BzID0gcmVmLiRwcm9wcztcbiAgICAgICAgICBldmVudHMuYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICAgIGNzcyhkb2MkNCwgJ292ZXJmbG93WScsICRwcm9wcy5mbGlwcGVkICYmIHNjcm9sbGJhcldpZHRoICYmICRwcm9wcy5vdmVybGF5XG4gICAgICAgICAgICA/ICdzY3JvbGwnXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhZGRDbGFzcygkcmVmcy5iYXIsICd1ay1vZmZjYW52YXMtYmFyLWFuaW1hdGlvbiB1ay1vZmZjYW52YXMtcHVzaCcpO1xuICAgICAgICB9LFxuICAgICAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIgKGVsLCBkb25lKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsLl9fdmtPZmZjYW52YXM7XG4gICAgICAgICAgdmFyICRyZWZzID0gcmVmLiRyZWZzO1xuICAgICAgICAgIGhlaWdodChlbCk7XG4gICAgICAgICAgYWRkQ2xhc3MoZWwsICd1ay1vcGVuJyk7XG4gICAgICAgICAgYWRkQ2xhc3MoJHJlZnMuY29udGVudCwgJ3VrLW9mZmNhbnZhcy1jb250ZW50LWFuaW1hdGlvbicpO1xuICAgICAgICAgIG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldCA9PT0gJHJlZnMuYmFyOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJFbnRlcjogZnVuY3Rpb24gYWZ0ZXJFbnRlciAoZWwpIHtcbiAgICAgICAgICBldmVudHMuYWZ0ZXJFbnRlcihlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZUxlYXZlOiBmdW5jdGlvbiBiZWZvcmVMZWF2ZSAoZWwpIHtcbiAgICAgICAgICB2YXIgcmVmID0gZWwuX192a09mZmNhbnZhcztcbiAgICAgICAgICB2YXIgJHJlZnMgPSByZWYuJHJlZnM7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsICd1ay1vcGVuJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoJHJlZnMuY29udGVudCwgJ3VrLW9mZmNhbnZhcy1jb250ZW50LWFuaW1hdGlvbicpO1xuICAgICAgICB9LFxuICAgICAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUgKGVsLCBkb25lKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsLl9fdmtPZmZjYW52YXM7XG4gICAgICAgICAgdmFyICRyZWZzID0gcmVmLiRyZWZzO1xuICAgICAgICAgIHZhciBiYXIgPSAkcmVmcy5iYXI7XG4gICAgICAgICAgb25jZShlbCwgJ3RyYW5zaXRpb25lbmQnLCBkb25lLCBmYWxzZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0ID09PSBiYXI7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlckxlYXZlOiBmdW5jdGlvbiBhZnRlckxlYXZlIChlbCkge1xuICAgICAgICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgICAgICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICAgICAgICByZW1vdmVDbGFzcygkcmVmcy5iYXIsICd1ay1vZmZjYW52YXMtYmFyLWFuaW1hdGlvbiB1ay1vZmZjYW52YXMtcHVzaCcpO1xuICAgICAgICAgIGV2ZW50cy5hZnRlckxlYXZlKGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGgoJ3RyYW5zaXRpb24nLCBtZXJnZURhdGEoZGVmLCBkYXRhKSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIFRyYW5zaXRpb25TbGlkZSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBkZWYgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjc3M6IGZhbHNlXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgYmVmb3JlRW50ZXI6IGZ1bmN0aW9uIGJlZm9yZUVudGVyIChlbCkge1xuICAgICAgICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgICAgICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICAgICAgICB2YXIgJHByb3BzID0gcmVmLiRwcm9wcztcbiAgICAgICAgICBldmVudHMuYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICAgIGNzcyhkb2MkNCwgJ292ZXJmbG93WScsIHNjcm9sbGJhcldpZHRoICYmICRwcm9wcy5vdmVybGF5XG4gICAgICAgICAgICA/ICdzY3JvbGwnXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhZGRDbGFzcygkcmVmcy5iYXIsICd1ay1vZmZjYW52YXMtYmFyLWFuaW1hdGlvbiB1ay1vZmZjYW52YXMtc2xpZGUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyIChlbCwgZG9uZSkge1xuICAgICAgICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgICAgICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICAgICAgICBoZWlnaHQoZWwpO1xuICAgICAgICAgIGFkZENsYXNzKGVsLCAndWstb3BlbicpO1xuICAgICAgICAgIG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldCA9PT0gJHJlZnMuYmFyOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJFbnRlcjogZnVuY3Rpb24gYWZ0ZXJFbnRlciAoZWwpIHtcbiAgICAgICAgICBldmVudHMuYWZ0ZXJFbnRlcihlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZUxlYXZlOiBmdW5jdGlvbiBiZWZvcmVMZWF2ZSAoZWwpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgJ3VrLW9wZW4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlIChlbCwgZG9uZSkge1xuICAgICAgICAgIHZhciByZWYgPSBlbC5fX3ZrT2ZmY2FudmFzO1xuICAgICAgICAgIHZhciAkcmVmcyA9IHJlZi4kcmVmcztcbiAgICAgICAgICBvbmNlKGVsLCAndHJhbnNpdGlvbmVuZCcsIGRvbmUsIGZhbHNlLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50YXJnZXQgPT09ICRyZWZzLmJhcjsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFmdGVyTGVhdmU6IGZ1bmN0aW9uIGFmdGVyTGVhdmUgKGVsKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsLl9fdmtPZmZjYW52YXM7XG4gICAgICAgICAgdmFyICRyZWZzID0gcmVmLiRyZWZzO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKCRyZWZzLmJhciwgJ3VrLW9mZmNhbnZhcy1iYXItYW5pbWF0aW9uIHVrLW9mZmNhbnZhcy1zbGlkZScpO1xuICAgICAgICAgIGV2ZW50cy5hZnRlckxlYXZlKGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGgoJ3RyYW5zaXRpb24nLCBtZXJnZURhdGEoZGVmLCBkYXRhKSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIFRyYW5zaXRpb25SZXZlYWwgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgZGVmID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY3NzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIGJlZm9yZUVudGVyOiBmdW5jdGlvbiBiZWZvcmVFbnRlciAoZWwpIHtcbiAgICAgICAgICB2YXIgcmVmID0gZWwuX192a09mZmNhbnZhcztcbiAgICAgICAgICB2YXIgJHJlZnMgPSByZWYuJHJlZnM7XG4gICAgICAgICAgdmFyICRwcm9wcyA9IHJlZi4kcHJvcHM7XG4gICAgICAgICAgZXZlbnRzLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgICB3aWR0aCgkcmVmcy5jb250ZW50LCB3aWR0aCh3aW4kMykgLSBzY3JvbGxiYXJXaWR0aCk7XG4gICAgICAgICAgY3NzKGRvYyQ0LCAnb3ZlcmZsb3dZJywgJHByb3BzLmZsaXBwZWQgJiYgc2Nyb2xsYmFyV2lkdGggJiYgJHByb3BzLm92ZXJsYXlcbiAgICAgICAgICAgID8gJ3Njcm9sbCdcbiAgICAgICAgICAgIDogJydcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIgKGVsLCBkb25lKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsLl9fdmtPZmZjYW52YXM7XG4gICAgICAgICAgdmFyICRyZWZzID0gcmVmLiRyZWZzO1xuICAgICAgICAgIGhlaWdodChlbCk7XG4gICAgICAgICAgYWRkQ2xhc3MoZWwsICd1ay1vcGVuJyk7XG4gICAgICAgICAgYWRkQ2xhc3MoJHJlZnMuY29udGVudCwgJ3VrLW9mZmNhbnZhcy1jb250ZW50LWFuaW1hdGlvbicpO1xuICAgICAgICAgIG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldCA9PT0gJHJlZnMucmV2ZWFsOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJFbnRlcjogZnVuY3Rpb24gYWZ0ZXJFbnRlciAoZWwpIHtcbiAgICAgICAgICBldmVudHMuYWZ0ZXJFbnRlcihlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZUxlYXZlOiBmdW5jdGlvbiBiZWZvcmVMZWF2ZSAoZWwpIHtcbiAgICAgICAgICB2YXIgcmVmID0gZWwuX192a09mZmNhbnZhcztcbiAgICAgICAgICB2YXIgJHJlZnMgPSByZWYuJHJlZnM7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsICd1ay1vcGVuJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoJHJlZnMuY29udGVudCwgJ3VrLW9mZmNhbnZhcy1jb250ZW50LWFuaW1hdGlvbicpO1xuICAgICAgICB9LFxuICAgICAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUgKGVsLCBkb25lKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsLl9fdmtPZmZjYW52YXM7XG4gICAgICAgICAgdmFyICRyZWZzID0gcmVmLiRyZWZzO1xuICAgICAgICAgIG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldCA9PT0gJHJlZnMucmV2ZWFsOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJMZWF2ZTogZnVuY3Rpb24gYWZ0ZXJMZWF2ZSAoZWwpIHtcbiAgICAgICAgICBldmVudHMuYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoKCd0cmFuc2l0aW9uJywgbWVyZ2VEYXRhKGRlZiwgZGF0YSksIGNoaWxkcmVuKVxuICB9XG59XG5cbnZhciBUcmFuc2l0aW9ucyA9IHtcbiAgbm9uZTogVHJhbnNpdGlvbk5vbmUsXG4gIHB1c2g6IFRyYW5zaXRpb25QdXNoLFxuICBzbGlkZTogVHJhbnNpdGlvblNsaWRlLFxuICByZXZlYWw6IFRyYW5zaXRpb25SZXZlYWxcbn07XG52YXIgb2ZmY2FudmFzID0ge1xuICBwcm9wczoge1xuICAgIHNob3c6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZmxpcHBlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzdHVjazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBvdmVybGF5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG1vZGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdzbGlkZScsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eKG5vbmV8c2xpZGV8cHVzaHxyZXZlYWwpJC8udGVzdCh2YWwpOyB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB0aGlzLiRyZWZzLmNvbnRlbnQgPSBxdWVyeSgnLnVrLW9mZmNhbnZhcy1jb250ZW50Jyk7XG4gICAgdGhpcy4kcmVmcy5iYXIgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcudWstb2ZmY2FudmFzLWJhcicpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0aGlzLiRyZWZzLmNvbnRlbnQpIHtcbiAgICAgIHdhcm4oJ09mZmNhbnZhcyBjb250ZW50IGVsZW1lbnQgbm90IGRldGVjdGVkIC0+IG1ha2Ugc3VyZSB0byB3cmFwIHRoZSBvZmZjYW52YXMgY29udGVudCB3aXRoIGB2ay1vZmZjYW52YXMtY29udGVudGAgY29tcG9uZW50IG9yIGEgY3VzdG9tIGAudWstb2ZmY2FudmFzLWNvbnRlbnRgIG5vZGUuJywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuJGVsLl9fdmtPZmZjYW52YXMgPSB0aGlzO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5zaG93KSB7XG4gICAgICBldmVudHMuYWZ0ZXJMZWF2ZSh0aGlzLiRlbCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciBub2RlcyA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGN1c3RvbUJhciA9IGZpbmRCYXIobm9kZXMpO1xuICAgIHZhciBiYXIgPSBjdXN0b21CYXIgfHwgaChFbGVtZW50T2ZmY2FudmFzQmFyLCBub2Rlcyk7XG4gICAgdmFyIGNvbnRlbnQgPSBoKEVsZW1lbnRPZmZjYW52YXMsIHtcbiAgICAgIGtleTogdGhpcy5tb2RlLFxuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ3VrLW9mZmNhbnZhcy1vdmVybGF5JzogdGhpcy5vdmVybGF5XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuICAgICAgICB2YWx1ZTogdGhpcy5zaG93XG4gICAgICB9XVxuICAgIH0sIFtcbiAgICAgIHRoaXMubW9kZSA9PT0gJ3JldmVhbCdcbiAgICAgICAgPyBoKCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICd1ay1vZmZjYW52YXMtcmV2ZWFsJyxcbiAgICAgICAgICByZWY6ICdyZXZlYWwnXG4gICAgICAgIH0sIFsgYmFyIF0pXG4gICAgICAgIDogYmFyXG4gICAgXSk7XG4gICAgcmV0dXJuIGgoVHJhbnNpdGlvbnNbdGhpcy5tb2RlXSwgWyBjb250ZW50IF0pXG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRCYXIgKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlc1xuICAgIC5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udGFnICYmIG4uZGF0YSAmJiAvb2ZmY2FudmFzLWJhci8udGVzdChnZXROb2RlQ2xhc3MobikpOyB9KVswXVxufVxuZnVuY3Rpb24gZ2V0Tm9kZUNsYXNzIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5kYXRhLmNsYXNzIHx8IFtdKS5jb25jYXQoIFtub2RlLmRhdGEuc3RhdGljQ2xhc3NdKS5qb2luKCcgJylcbn1cblxudmFyIG9mZmNhbnZhc0NvbnRlbnQgPSB7XG4gIG5hbWU6ICdWa09mZmNhbnZhc0NvbnRlbnQnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IEVsZW1lbnRPZmZjYW52YXNDb250ZW50LnJlbmRlclxufVxuXG52YXIgb2ZmY2FudmFzX0JhciA9IHtcbiAgbmFtZTogJ1ZrT2ZmY2FudmFzQmFyJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBFbGVtZW50T2ZmY2FudmFzQmFyLnJlbmRlclxufVxuXG52YXIgb2ZmY2FudmFzX0Nsb3NlID0ge1xuICBuYW1lOiAnVmtPZmZjYW52YXNDbG9zZScsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50T2ZmY2FudmFzQ2xvc2UucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudE9mZmNhbnZhc0Nsb3NlLnJlbmRlclxufVxuXG52YXIgRWxlbWVudFBhZ2luYXRpb24gPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgYWxpZ246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gL14obGVmdHxjZW50ZXJ8cmlnaHQpJC8udGVzdCh2YWwpOyB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgcmV0dXJuIGgoJ3VsJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLXBhZ2luYXRpb24nLCAoIG9iaiA9IHt9LCBvYmpbKFwidWstZmxleC1cIiArIGFsaWduKV0gPSBhbGlnbiAhPT0gJ2xlZnQnLCBvYmopXVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudFBhZ2luYXRpb25QYWdlID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGFjdGl2ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgYWN0aXZlID0gcHJvcHMuYWN0aXZlO1xuICAgIHZhciB0aXRsZSA9IHByb3BzLnRpdGxlO1xuICAgIHJldHVybiBoKCdsaScsIHtcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgICd1ay1hY3RpdmUnOiBhY3RpdmVcbiAgICAgIH1cbiAgICB9LCBbXG4gICAgICBhY3RpdmVcbiAgICAgICAgPyBoKCdzcGFuJywgdGl0bGUpXG4gICAgICAgIDogaCgnYScsIHsgb246IGRhdGEub24gfSwgdGl0bGUpXG4gICAgXSlcbiAgfVxufVxuXG52YXIgSWNvbiA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgdmFyIHByb3BzID0gY3R4LnByb3BzO1xuICAgIHZhciByYXRpbyA9IHByb3BzLnJhdGlvIHx8IDE7XG4gICAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGggfHwgNztcbiAgICB2YXIgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8IDEyO1xuICAgIHZhciB2aWV3Qm94ID0gcHJvcHMudmlld0JveCB8fCAnMCAwIDcgMTInO1xuICAgIGlmIChyYXRpbyAhPT0gMSkge1xuICAgICAgd2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogcmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoKCdzdmcnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB2ZXJzaW9uOiAnMS4xJyxcbiAgICAgICAgbWV0YTogJ2ljb24tcGFnaW5hdGlvbi1uZXh0IHJhdGlvLScgKyByYXRpbyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdmlld0JveDogdmlld0JveFxuICAgICAgfSxcbiAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgIGlubmVySFRNTDogJzxwYXRoIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjEuMlwiIGQ9XCJNMSAxbDUgNS01IDVcIi8+J1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRQYWdpbmF0aW9uUGFnZU5leHQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBleHBhbmRlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGxpc3RlbmVycyA9IHJlZi5saXN0ZW5lcnM7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIGV4cGFuZGVkID0gcHJvcHMuZXhwYW5kZWQ7XG4gICAgdmFyIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgZGVsZXRlIGRhdGEub247XG4gICAgcmV0dXJuIGgoJ2xpJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgICd1ay1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAndWstbWFyZ2luLWF1dG8tbGVmdCc6IGV4cGFuZGVkXG4gICAgICB9XG4gICAgfSksIFtcbiAgICAgIGgoJ2EnLCB7IG9uOiBsaXN0ZW5lcnMgfSwgW1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgaChFbGVtZW50SWNvbiwge1xuICAgICAgICAgIGNsYXNzOiBbJ3VrLXBhZ2luYXRpb24tcHJldicsIHtcbiAgICAgICAgICAgICd1ay1tYXJnaW4tc21hbGwtbGVmdCc6IHRpdGxlXG4gICAgICAgICAgfV1cbiAgICAgICAgfSwgWyBoKEljb24pIF0pXG4gICAgICBdKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIEljb24kMSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgdmFyIHByb3BzID0gY3R4LnByb3BzO1xuICAgIHZhciByYXRpbyA9IHByb3BzLnJhdGlvIHx8IDE7XG4gICAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGggfHwgNztcbiAgICB2YXIgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8IDEyO1xuICAgIHZhciB2aWV3Qm94ID0gcHJvcHMudmlld0JveCB8fCAnMCAwIDcgMTInO1xuICAgIGlmIChyYXRpbyAhPT0gMSkge1xuICAgICAgd2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogcmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoKCdzdmcnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB2ZXJzaW9uOiAnMS4xJyxcbiAgICAgICAgbWV0YTogJ2ljb24tcGFnaW5hdGlvbi1wcmV2IHJhdGlvLScgKyByYXRpbyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdmlld0JveDogdmlld0JveFxuICAgICAgfSxcbiAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgIGlubmVySFRNTDogJzxwYXRoIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjEuMlwiIGQ9XCJNNiAxTDEgNmw1IDVcIi8+J1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRQYWdpbmF0aW9uUGFnZVByZXYgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBleHBhbmRlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGxpc3RlbmVycyA9IHJlZi5saXN0ZW5lcnM7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIGV4cGFuZGVkID0gcHJvcHMuZXhwYW5kZWQ7XG4gICAgdmFyIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgZGVsZXRlIGRhdGEub247XG4gICAgcmV0dXJuIGgoJ2xpJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgICd1ay1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAndWstbWFyZ2luLWF1dG8tcmlnaHQnOiBleHBhbmRlZFxuICAgICAgfVxuICAgIH0pLCBbXG4gICAgICBoKCdhJywgeyBvbjogbGlzdGVuZXJzIH0sIFtcbiAgICAgICAgaChFbGVtZW50SWNvbiwge1xuICAgICAgICAgIGNsYXNzOiBbJ3VrLXBhZ2luYXRpb24tcHJldicsIHtcbiAgICAgICAgICAgICd1ay1tYXJnaW4tc21hbGwtcmlnaHQnOiB0aXRsZVxuICAgICAgICAgIH1dXG4gICAgICAgIH0sIFsgaChJY29uJDEpIF0pLFxuICAgICAgICB0aXRsZVxuICAgICAgXSlcbiAgICBdKVxuICB9XG59XG5cbmZ1bmN0aW9uIE1hdHJpeCAocmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIHRvdGFsID0gcmVmLnRvdGFsOyBpZiAoIHRvdGFsID09PSB2b2lkIDAgKSB0b3RhbCA9IDIwMDtcbiAgdmFyIHBhZ2UgPSByZWYucGFnZTsgaWYgKCBwYWdlID09PSB2b2lkIDAgKSBwYWdlID0gMTtcbiAgdmFyIHBlclBhZ2UgPSByZWYucGVyUGFnZTsgaWYgKCBwZXJQYWdlID09PSB2b2lkIDAgKSBwZXJQYWdlID0gMTA7XG4gIHZhciByYW5nZSQkMSA9IHJlZi5yYW5nZTsgaWYgKCByYW5nZSQkMSA9PT0gdm9pZCAwICkgcmFuZ2UkJDEgPSAzO1xuICB2YXIgbWF0cml4ID0gW107XG4gIHZhciB0b3RhbFBhZ2VzID0gTWF0aC5jZWlsKHRvdGFsIC8gcGVyUGFnZSk7XG4gIGlmICh0b3RhbFBhZ2VzIDwgMikge1xuICAgIHJldHVybiBbMV1cbiAgfVxuICB2YXIgbWFpblBhZ2VzID0gZ2V0TWFpblBhZ2VzKHsgcGFnZTogcGFnZSwgcmFuZ2U6IHJhbmdlJCQxLCB0b3RhbFBhZ2VzOiB0b3RhbFBhZ2VzIH0pO1xuICB2YXIgZmlyc3QgPSBtYWluUGFnZXNbMF07XG4gIHZhciBsYXN0ID0gbWFpblBhZ2VzW21haW5QYWdlcy5sZW5ndGggLSAxXTtcbiAgdmFyIHByZVBhZ2VzID0gcmFuZ2UoMSwgKGZpcnN0IDw9IDMpID8gZmlyc3QgOiAyKTtcbiAgdmFyIHBvc3RQYWdlcyA9IHJhbmdlKFxuICAgIGxhc3QgPj0gKHRvdGFsUGFnZXMgLSAyKSA/IGxhc3QgKyAxIDogdG90YWxQYWdlcyxcbiAgICB0b3RhbFBhZ2VzICsgMVxuICApO1xuICB2YXIgbmV4dFBhZ2UgPSAxXG4gIDtbXS5jb25jYXQocHJlUGFnZXMsIG1haW5QYWdlcywgcG9zdFBhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgaWYgKHAgPT09IG5leHRQYWdlKSB7XG4gICAgICBtYXRyaXgucHVzaChwKTtcbiAgICAgIG5leHRQYWdlKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdHJpeC5wdXNoKCcuLi4nKTtcbiAgICAgIG1hdHJpeC5wdXNoKHApO1xuICAgICAgbmV4dFBhZ2UgPSBwICsgMTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF0cml4XG59XG52YXIgZ2V0TWFpblBhZ2VzID0gZnVuY3Rpb24gKHJlZikge1xuICB2YXIgcGFnZSA9IHJlZi5wYWdlO1xuICB2YXIgcmFuZ2UkJDEgPSByZWYucmFuZ2U7XG4gIHZhciB0b3RhbFBhZ2VzID0gcmVmLnRvdGFsUGFnZXM7XG4gIHZhciBzdGFydCA9IHBhZ2UgLSByYW5nZSQkMTtcbiAgdmFyIGVuZCA9IHBhZ2UgKyByYW5nZSQkMTtcbiAgaWYgKGVuZCA+IHRvdGFsUGFnZXMpIHtcbiAgICBlbmQgPSB0b3RhbFBhZ2VzO1xuICAgIHN0YXJ0ID0gdG90YWxQYWdlcyAtIChyYW5nZSQkMSAqIDIpO1xuICAgIHN0YXJ0ID0gc3RhcnQgPCAxID8gMSA6IHN0YXJ0O1xuICB9XG4gIGlmIChzdGFydCA8PSAxKSB7XG4gICAgc3RhcnQgPSAxO1xuICAgIGVuZCA9IE1hdGgubWluKChyYW5nZSQkMSAqIDIpICsgMSwgdG90YWxQYWdlcyk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlKHN0YXJ0LCBlbmQgKyAxKVxufTtcblxudmFyIHBhZ2luYXRpb24gPSB7XG4gIG5hbWU6ICdQYWdpbmF0aW9uJyxcbiAgZGlyZWN0aXZlczogeyBWa01hcmdpbjogVmtNYXJnaW4gfSxcbiAgcHJvcHM6IGFzc2lnbih7fSwgRWxlbWVudFBhZ2luYXRpb24ucHJvcHMsIHtcbiAgICBwYWdlOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAxXG4gICAgfSxcbiAgICBwZXJQYWdlOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdG90YWw6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICByYW5nZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogM1xuICAgIH1cbiAgfSksXG4gIGNvbXB1dGVkOiB7XG4gICAgcHJldlBhZ2U6IGZ1bmN0aW9uIHByZXZQYWdlICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhZ2UgLSAxXG4gICAgfSxcbiAgICBuZXh0UGFnZTogZnVuY3Rpb24gbmV4dFBhZ2UgKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZSArIDFcbiAgICB9LFxuICAgIHBhZ2VzOiBmdW5jdGlvbiBwYWdlcyAoKSB7XG4gICAgICByZXR1cm4gTWF0cml4KHsgdG90YWw6IHRoaXMudG90YWwsIHBhZ2U6IHRoaXMucGFnZSwgcGVyUGFnZTogdGhpcy5wZXJQYWdlIH0pXG4gICAgfSxcbiAgICBsYXN0UGFnZTogZnVuY3Rpb24gbGFzdFBhZ2UgKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChwYWdlKSB7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6cGFnZScsIHBhZ2UpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgbm9kZXMgPSAodGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnRhZzsgfSk7XG4gICAgcmV0dXJuIGgoRWxlbWVudFBhZ2luYXRpb24sIHtcbiAgICAgIHByb3BzOiB0aGlzLiRwcm9wcyxcbiAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgIG5hbWU6ICd2ay1tYXJnaW4nXG4gICAgICB9XVxuICAgIH0sIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKCFub2RlLmZuT3B0aW9ucykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgd2FybigoXCJ2ay1wYWdpbmF0aW9uIC0+IFwiICsgKG5vZGUudGFnKSArIFwiIGNvbXBvbmVudCBpcyBub3QgZnVuY3Rpb25hbFwiKSwgdGhpcyQxKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS5kYXRhLnJlcmVuZGVyXG4gICAgICAgID8gaChub2RlLmZuT3B0aW9ucywgbWVyZ2VEYXRhKG5vZGUuZGF0YSwge1xuICAgICAgICAgIHJlcmVuZGVyaW5nOiB0cnVlXG4gICAgICAgIH0pKVxuICAgICAgICA6IG5vZGVcbiAgICB9KSlcbiAgfVxufVxuXG52YXIgcGFnaW5hdGlvbl9QYWdlcyA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgaWYgKCFkYXRhLnJlcmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm4gaCgnbGknLCB7XG4gICAgICAgIHJlcmVuZGVyOiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgICB2YXIgY3VycmVudFBhZ2UgPSBwYXJlbnQucGFnZTtcbiAgICByZXR1cm4gcGFyZW50LnBhZ2VzLm1hcChmdW5jdGlvbiAocGFnZSkge1xuICAgICAgdmFyIGlzUGFnZSA9IGlzTnVtYmVyKHBhZ2UpO1xuICAgICAgcmV0dXJuIGlzUGFnZVxuICAgICAgICA/IGgoRWxlbWVudFBhZ2luYXRpb25QYWdlLCB7XG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRpdGxlOiBwYWdlLFxuICAgICAgICAgICAgYWN0aXZlOiBjdXJyZW50UGFnZSA9PT0gcGFnZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gcGFyZW50LiRlbWl0KCd1cGRhdGU6cGFnZScsIHBhZ2UpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICA6IGgoJ2xpJywgWyBoKCdzcGFuJywgJy4uLicpIF0pXG4gICAgfSlcbiAgfVxufVxuXG52YXIgcGFnaW5hdGlvbl9QYWdlRmlyc3QgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50UGFnaW5hdGlvblBhZ2VQcmV2LnByb3BzLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIGV4cGFuZGVkID0gcHJvcHMuZXhwYW5kZWQ7XG4gICAgaWYgKCFkYXRhLnJlcmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm4gaCgnbGknLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgICByZXJlbmRlcjogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICB9KSlcbiAgICB9XG4gICAgcmV0dXJuIGgoRWxlbWVudFBhZ2luYXRpb25QYWdlUHJldiwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgIGRpc2FibGVkOiBwYXJlbnQucHJldlBhZ2UgPCAxXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBwYXJlbnQudXBkYXRlKDEpOyB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG52YXIgcGFnaW5hdGlvbl9QYWdlUHJldiA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnRQYWdpbmF0aW9uUGFnZVByZXYucHJvcHMsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgdGl0bGUgPSBwcm9wcy50aXRsZTtcbiAgICB2YXIgZXhwYW5kZWQgPSBwcm9wcy5leHBhbmRlZDtcbiAgICBpZiAoIWRhdGEucmVyZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybiBoKCdsaScsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICAgIHJlcmVuZGVyOiB0cnVlLFxuICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgIH0pKVxuICAgIH1cbiAgICByZXR1cm4gaChFbGVtZW50UGFnaW5hdGlvblBhZ2VQcmV2LCB7XG4gICAgICBwcm9wczoge1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGV4cGFuZGVkOiBleHBhbmRlZCxcbiAgICAgICAgZGlzYWJsZWQ6IHBhcmVudC5wcmV2UGFnZSA8IDFcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHBhcmVudC51cGRhdGUocGFyZW50LnByZXZQYWdlKTsgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIHBhZ2luYXRpb25fUGFnZU5leHQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50UGFnaW5hdGlvblBhZ2VOZXh0LnByb3BzLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIGV4cGFuZGVkID0gcHJvcHMuZXhwYW5kZWQ7XG4gICAgaWYgKCFkYXRhLnJlcmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm4gaCgnbGknLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgICByZXJlbmRlcjogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICB9KSlcbiAgICB9XG4gICAgcmV0dXJuIGgoRWxlbWVudFBhZ2luYXRpb25QYWdlTmV4dCwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgIGRpc2FibGVkOiBwYXJlbnQubmV4dFBhZ2UgPiBwYXJlbnQubGFzdFBhZ2VcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHBhcmVudC51cGRhdGUocGFyZW50Lm5leHRQYWdlKTsgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIHBhZ2luYXRpb25fUGFnZUxhc3QgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50UGFnaW5hdGlvblBhZ2VOZXh0LnByb3BzLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIGV4cGFuZGVkID0gcHJvcHMuZXhwYW5kZWQ7XG4gICAgaWYgKCFkYXRhLnJlcmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm4gaCgnbGknLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgICByZXJlbmRlcjogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICB9KSlcbiAgICB9XG4gICAgcmV0dXJuIGgoRWxlbWVudFBhZ2luYXRpb25QYWdlTmV4dCwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgIGRpc2FibGVkOiBwYXJlbnQubmV4dFBhZ2UgPiBwYXJlbnQubGFzdFBhZ2VcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHBhcmVudC51cGRhdGUocGFyZW50Lmxhc3RQYWdlKTsgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIGZhc3Rkb20gPSB7XG4gIHJlYWRzOiBbXSxcbiAgd3JpdGVzOiBbXSxcbiAgcmVhZDogZnVuY3Rpb24gcmVhZCAodGFzaykge1xuICAgIHRoaXMucmVhZHMucHVzaCh0YXNrKTtcbiAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgcmV0dXJuIHRhc2tcbiAgfSxcbiAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlICh0YXNrKSB7XG4gICAgdGhpcy53cml0ZXMucHVzaCh0YXNrKTtcbiAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgcmV0dXJuIHRhc2tcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyICh0YXNrKSB7XG4gICAgcmV0dXJuIHJlbW92ZSQxKHRoaXMucmVhZHMsIHRhc2spIHx8IHJlbW92ZSQxKHRoaXMud3JpdGVzLCB0YXNrKVxuICB9LFxuICBmbHVzaDogZnVuY3Rpb24gZmx1c2ggKCkge1xuICAgIHJ1blRhc2tzKHRoaXMucmVhZHMpO1xuICAgIHJ1blRhc2tzKHRoaXMud3JpdGVzLnNwbGljZSgwLCB0aGlzLndyaXRlcy5sZW5ndGgpKTtcbiAgICB0aGlzLnNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnJlYWRzLmxlbmd0aCB8fCB0aGlzLndyaXRlcy5sZW5ndGgpIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzY2hlZHVsZUZsdXNoICgpIHtcbiAgaWYgKCFmYXN0ZG9tLnNjaGVkdWxlZCkge1xuICAgIGZhc3Rkb20uc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmFzdGRvbS5mbHVzaC5iaW5kKGZhc3Rkb20pKTtcbiAgfVxufVxuZnVuY3Rpb24gcnVuVGFza3MgKHRhc2tzKSB7XG4gIHZhciB0YXNrO1xuICB3aGlsZSAoKHRhc2sgPSB0YXNrcy5zaGlmdCgpKSkge1xuICAgIHRhc2soKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlJDEgKGFycmF5LCBpdGVtKSB7XG4gIHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gIHJldHVybiAhIX5pbmRleCAmJiAhIWFycmF5LnNwbGljZShpbmRleCwgMSlcbn1cblxudmFyIERBVEEgPSAnX3ZrX2Zhc3Rkb21fZGF0YSc7XG52YXIgRlJBTUVTID0gJ192a19mYXN0ZG9tX2ZyYW1lcyc7XG52YXIgc2Nyb2xsJDEgPSAwO1xudmFyIGluc3RhbmNlcyA9IFtdO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIG9uKHdpbmRvdywgJ2xvYWQgcmVzaXplJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuZmFzdGRvbVVwZGF0ZSgpOyB9KTsgfVxuICApO1xuICBvbih3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbiAoZSkge1xuICAgIGUuZGlyID0gc2Nyb2xsJDEgPD0gd2luZG93LnBhZ2VZT2Zmc2V0ID8gJ2Rvd24nIDogJ3VwJztcbiAgICBlLnNjcm9sbFkgPSBzY3JvbGwkMSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBpbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdCkgeyByZXR1cm4gaW5zdC5mYXN0ZG9tVXBkYXRlKGUpOyB9KTtcbiAgfSk7XG59XG52YXIgTWl4aW5GYXN0ZG9tID0ge1xuICBtZXRob2RzOiB7XG4gICAgZmFzdGRvbVVwZGF0ZTogZnVuY3Rpb24gZmFzdGRvbVVwZGF0ZSAoZSwgcGFyZW50cykge1xuICAgICAgaWYgKCBwYXJlbnRzID09PSB2b2lkIDAgKSBwYXJlbnRzID0gZmFsc2U7XG4gICAgICBlID0gY3JlYXRlRXZlbnQoZSB8fCAndXBkYXRlJyk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgaWYgKHBhcmVudHMpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5fZmFzdGRvbV9yZWFkeSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuX2Zhc3Rkb21VcGRhdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UuJHBhcmVudCgpO1xuICAgICAgICB9IHdoaWxlIChpbnN0YW5jZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5JDIoaW5zdGFuY2UsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5fZmFzdGRvbV9yZWFkeSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuX2Zhc3Rkb21VcGRhdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9mYXN0ZG9tVXBkYXRlOiBmdW5jdGlvbiBfZmFzdGRvbVVwZGF0ZSAoZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICBlID0gY3JlYXRlRXZlbnQoZSB8fCAndXBkYXRlJyk7XG4gICAgICB2YXIgdHlwZSA9IGUudHlwZTtcbiAgICAgIHZhciB1cGRhdGVzID0gdGhpcy4kb3B0aW9ucy5mYXN0ZG9tO1xuICAgICAgdmFyIHJlZiA9IHRoaXNbRlJBTUVTXTtcbiAgICAgIHZhciByZWFkcyA9IHJlZi5yZWFkcztcbiAgICAgIHZhciB3cml0ZXMgPSByZWYud3JpdGVzO1xuICAgICAgaWYgKCF1cGRhdGVzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYsIGkpIHtcbiAgICAgICAgdmFyIHJlYWQgPSByZWYucmVhZDtcbiAgICAgICAgdmFyIHdyaXRlID0gcmVmLndyaXRlO1xuICAgICAgICB2YXIgZXZlbnRzID0gcmVmLmV2ZW50cztcbiAgICAgICAgaWYgKHR5cGUgIT09ICd1cGRhdGUnICYmICFpbmNsdWRlcyhldmVudHMsIHR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWQgJiYgIWluY2x1ZGVzKGZhc3Rkb20ucmVhZHMsIHJlYWRzW2ldKSkge1xuICAgICAgICAgIHJlYWRzW2ldID0gZmFzdGRvbS5yZWFkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWFkLmNhbGwodGhpcyQxLCB0aGlzJDFbREFUQV0sIGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UgJiYgd3JpdGUpIHtcbiAgICAgICAgICAgICAgZmFzdGRvbS5jbGVhcih3cml0ZXNbaV0pO1xuICAgICAgICAgICAgICBkZWxldGUgd3JpdGVzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgYXNzaWduKHRoaXMkMVtEQVRBXSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSByZWFkc1tpXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JpdGUgJiYgIWluY2x1ZGVzKGZhc3Rkb20ud3JpdGVzLCB3cml0ZXNbaV0pKSB7XG4gICAgICAgICAgd3JpdGVzW2ldID0gZmFzdGRvbS53cml0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3cml0ZS5jYWxsKHRoaXMkMSwgdGhpcyQxW0RBVEFdLCBlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB3cml0ZXNbaV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpc1tEQVRBXSA9IHt9O1xuICAgIHRoaXNbRlJBTUVTXSA9IHsgcmVhZHM6IHt9LCB3cml0ZXM6IHt9IH07XG4gICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHRoaXMuX2Zhc3Rkb21fcmVhZHkgfHwgcmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhvb2sgPSB0aGlzJDEuJG9wdGlvbnMuZG9tUmVhZHk7XG4gICAgICBob29rICYmIGhvb2suY2FsbCh0aGlzJDEpO1xuICAgICAgdGhpcyQxLl9mYXN0ZG9tX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5fZmFzdGRvbVVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX2Zhc3Rkb21VcGRhdGUoKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgdmFyIGluZGV4JCQxID0gaW5zdGFuY2VzLmluZGV4T2YoaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoaW5zdCkgeyByZXR1cm4gaW5zdCA9PT0gdGhpcyQxOyB9KVswXSk7XG4gICAgaW5zdGFuY2VzLnNwbGljZShpbmRleCQkMSwgMSk7XG4gIH1cbn1cblxudmFyIHNjcm9sbHNweSA9IHtcbiAgbmFtZTogJ1ZrU2Nyb2xsc3B5JyxcbiAgYWJzdHJhY3Q6IHRydWUsXG4gIG1peGluczogW0V2ZW50c01peGluLCBNaXhpbkZhc3Rkb21dLFxuICBwcm9wczoge1xuICAgIGNsczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG4gICAgdGFyZ2V0OiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaGlkZGVuOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgb2Zmc2V0VG9wOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICBvZmZzZXRMZWZ0OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICByZXBlYXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGVsYXk6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9XG4gIH0sXG4gIGNsYXNzTWFwcGluZzoge1xuICAgIGluVmlld0NsYXNzOiAndWstc2Nyb2xsc3B5LWludmlldydcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBlbGVtZW50czogZnVuY3Rpb24gZWxlbWVudHMgKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0ID8gJCQodGhpcy50YXJnZXQsIHRoaXMuJGVsKSA6IFsgdGhpcy4kZWwgXVxuICAgIH1cbiAgfSxcbiAgZmFzdGRvbTogW1xuICAgIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSAoKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLmNsYXNzTWFwcGluZztcbiAgICAgICAgdmFyIGluVmlld0NsYXNzID0gcmVmLmluVmlld0NsYXNzO1xuICAgICAgICBpZiAodGhpcy5oaWRkZW4pIHtcbiAgICAgICAgICBjc3MoZmlsdGVyKHRoaXMuZWxlbWVudHMsIChcIjpub3QoLlwiICsgaW5WaWV3Q2xhc3MgKyBcIilcIikpLCAndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCAoZWxzKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgICAgdmFyIGVsRGF0YSA9IGVsc1tpXTtcbiAgICAgICAgICBpZiAoIWVsRGF0YSB8fCBlbERhdGEuZWwgIT09IGVsKSB7XG4gICAgICAgICAgICB2YXIgY2xzID0gZGF0YShlbCwgJ3ZrLXNjcm9sbHNweS1jbGFzcycpO1xuICAgICAgICAgICAgZWxEYXRhID0ge2VsOiBlbCwgdG9nZ2xlczogY2xzICYmIGNscy5zcGxpdCgnLCcpIHx8IHRoaXMkMS5jbHN9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbERhdGEuc2hvdyA9IGlzSW5WaWV3KGVsLCB0aGlzJDEub2Zmc2V0VG9wLCB0aGlzJDEub2Zmc2V0TGVmdCk7XG4gICAgICAgICAgZWxzW2ldID0gZWxEYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUgKGVscykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuJG9wdGlvbnMuY2xhc3NNYXBwaW5nO1xuICAgICAgICB2YXIgaW5WaWV3Q2xhc3MgPSByZWYuaW5WaWV3Q2xhc3M7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZWxlbWVudHMubGVuZ3RoID09PSAxID8gMSA6IDA7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcbiAgICAgICAgICB2YXIgZWxEYXRhID0gZWxzW2ldO1xuICAgICAgICAgIHZhciBjbHMgPSBlbERhdGEudG9nZ2xlc1tpXSB8fCBlbERhdGEudG9nZ2xlc1swXTtcbiAgICAgICAgICBpZiAoZWxEYXRhLnNob3cgJiYgIWVsRGF0YS5pbnZpZXcgJiYgIWVsRGF0YS50aW1lcikge1xuICAgICAgICAgICAgdmFyIHNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNzcyhlbCwgJ3Zpc2liaWxpdHknLCAnJyk7XG4gICAgICAgICAgICAgIGFkZENsYXNzKGVsLCBpblZpZXdDbGFzcyk7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBjbHMpO1xuICAgICAgICAgICAgICB0cmlnZ2VyKGVsLCAnaW52aWV3Jyk7XG4gICAgICAgICAgICAgIHRoaXMkMS5mYXN0ZG9tVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGVsRGF0YS5pbnZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgICBkZWxldGUgZWxEYXRhLnRpbWVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzJDEuZGVsYXkgJiYgaW5kZXgpIHtcbiAgICAgICAgICAgICAgZWxEYXRhLnRpbWVyID0gc2V0VGltZW91dChzaG93LCB0aGlzJDEuZGVsYXkgKiBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWVsRGF0YS5zaG93ICYmIGVsRGF0YS5pbnZpZXcgJiYgdGhpcyQxLnJlcGVhdCkge1xuICAgICAgICAgICAgaWYgKGVsRGF0YS50aW1lcikge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZWxEYXRhLnRpbWVyKTtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsRGF0YS50aW1lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzcyhlbCwgJ3Zpc2liaWxpdHknLCB0aGlzJDEuaGlkZGVuID8gJ2hpZGRlbicgOiAnJyk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgaW5WaWV3Q2xhc3MpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIGNscyk7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnb3V0dmlldycpO1xuICAgICAgICAgICAgdGhpcyQxLmZhc3Rkb21VcGRhdGUoKTtcbiAgICAgICAgICAgIGVsRGF0YS5pbnZpZXcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGV2ZW50czogWydzY3JvbGwnLCAnbG9hZCcsICdyZXNpemUnXVxuICAgIH1cbiAgXSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjaGlsZHJlbiA9IGZpbHRlck91dFRleHROb2RlcyhjaGlsZHJlbik7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKCd2ay1zY3JvbGxzcHkgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50JywgdGhpcy4kcGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdXG4gIH1cbn1cblxudmFyIHNjcm9sbHNweU5hdiA9IHtcbiAgbmFtZTogJ1ZrU2Nyb2xsc3B5TmF2JyxcbiAgYWJzdHJhY3Q6IHRydWUsXG4gIG1peGluczogW0V2ZW50c01peGluLCBNaXhpbkZhc3Rkb21dLFxuICBwcm9wczoge1xuICAgIGNsczoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3VrLWFjdGl2ZSdcbiAgICB9LFxuICAgIGNsb3Nlc3Q6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBvdmVyZmxvdzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIG9mZnNldDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNldENvbXB1dGVkOiBmdW5jdGlvbiBzZXRDb21wdXRlZCAoKSB7XG4gICAgICB0aGlzLmxpbmtzID0gJCQoJ2FbaHJlZl49XCIjXCJdJywgdGhpcy4kZWwpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmhhc2g7IH0pO1xuICAgICAgdGhpcy5lbGVtZW50cyA9IHRoaXMuY2xvc2VzdCA/IGNsb3Nlc3QodGhpcy5saW5rcywgdGhpcy5jbG9zZXN0KSA6IHRoaXMubGlua3M7XG4gICAgICB0aGlzLnRhcmdldHMgPSAkJCh0aGlzLmxpbmtzLm1hcChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmhhc2g7IH0pLmpvaW4oJywnKSk7XG4gICAgfVxuICB9LFxuICBmYXN0ZG9tOiBbXG4gICAge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCAoZGF0YSkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgdmFyIHNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldCArIHRoaXMub2Zmc2V0ICsgMTtcbiAgICAgICAgdmFyIG1heCA9IGhlaWdodChkb2N1bWVudCkgLSBoZWlnaHQod2luZG93KSArIHRoaXMub2Zmc2V0O1xuICAgICAgICBkYXRhLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRhcmdldHMuZXZlcnkoZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IG9mZnNldChlbCk7XG4gICAgICAgICAgdmFyIHRvcCA9IHJlZi50b3A7XG4gICAgICAgICAgdmFyIGxhc3QgPSBpICsgMSA9PT0gdGhpcyQxLnRhcmdldHMubGVuZ3RoO1xuICAgICAgICAgIGlmICghdGhpcyQxLm92ZXJmbG93ICYmIChpID09PSAwICYmIHRvcCA+IHNjcm9sbCB8fCBsYXN0ICYmIHRvcCArIGVsLm9mZnNldFRvcCA8IHNjcm9sbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWxhc3QgJiYgb2Zmc2V0KHRoaXMkMS50YXJnZXRzW2kgKyAxXSkudG9wIDw9IHNjcm9sbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjcm9sbCA+PSBtYXgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSB0aGlzJDEudGFyZ2V0cy5sZW5ndGggLSAxOyBqID4gaTsgai0tKSB7XG4gICAgICAgICAgICAgIGlmIChpc0luVmlldyh0aGlzJDEudGFyZ2V0c1tqXSkpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMkMS50YXJnZXRzW2pdO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICEoZGF0YS5hY3RpdmUgPSAkKGZpbHRlcih0aGlzJDEubGlua3MsIChcIltocmVmPVxcXCIjXCIgKyAoZWwuaWQpICsgXCJcXFwiXVwiKSkpKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUgKHJlZikge1xuICAgICAgICB2YXIgYWN0aXZlID0gcmVmLmFjdGl2ZTtcbiAgICAgICAgdGhpcy5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuYmx1cigpOyB9KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50cywgdGhpcy5jbHMpO1xuICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2FjdGl2ZScsIFthY3RpdmUsIGFkZENsYXNzKHRoaXMuY2xvc2VzdCA/IGNsb3Nlc3QoYWN0aXZlLCB0aGlzLmNsb3Nlc3QpIDogYWN0aXZlLCB0aGlzLmNscyldKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czogWydzY3JvbGwnLCAnbG9hZCcsICdyZXNpemUnXVxuICAgIH1cbiAgXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdGhpcy5zZXRDb21wdXRlZCgpO1xuICB9LFxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuc2V0Q29tcHV0ZWQoKTtcbiAgICAgIHRoaXMkMS5mYXN0ZG9tVXBkYXRlKCk7XG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2hpbGRyZW4gPSBmaWx0ZXJPdXRUZXh0Tm9kZXMoY2hpbGRyZW4pO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2Fybigndmstc2Nyb2xsc3B5IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCcsIHRoaXMuJHBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblswXVxuICB9XG59XG5cbnZhciBFbGVtZW50U2tlbGV0b24gPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgYW5pbWF0ZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IFtCb29sZWFuLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogW0Jvb2xlYW4sIE51bWJlcl0sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBhbmltYXRlZCA9IHByb3BzLmFuaW1hdGVkO1xuICAgIHZhciB3aWR0aCA9IHByb3BzLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YSh7XG4gICAgICBjbGFzczoge1xuICAgICAgICAndmstc2tlbGV0b24tLWFuaW1hdGVkJzogYW5pbWF0ZWRcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogKHdpZHRoICsgXCJweFwiKSxcbiAgICAgICAgaGVpZ2h0OiAoaGVpZ2h0ICsgXCJweFwiKVxuICAgICAgfVxuICAgIH0sIGRhdGEpLCBbXG4gICAgICBoKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAndmstc2tlbGV0b24tY29udGVudCdcbiAgICAgIH0pXG4gICAgXSlcbiAgfVxufVxuXG52YXIgRWxlbWVudFNrZWxldG9uSW1hZ2UgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBhc3NpZ24oe30sIEVsZW1lbnRTa2VsZXRvbi5wcm9wcywge1xuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMTIwXG4gICAgfVxuICB9KSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHJldHVybiBoKEVsZW1lbnRTa2VsZXRvbiwgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndmstc2tlbGV0b24taW1hZ2UnLFxuICAgICAgcHJvcHM6IHByb3BzXG4gICAgfSkpXG4gIH1cbn1cblxudmFyIEVsZW1lbnRTa2VsZXRvblRleHQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50U2tlbGV0b24ucHJvcHMsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICByZXR1cm4gaChFbGVtZW50U2tlbGV0b24sIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogJ3ZrLXNrZWxldG9uLXRleHQnLFxuICAgICAgcHJvcHM6IHByb3BzXG4gICAgfSkpXG4gIH1cbn1cblxudmFyIEVsZW1lbnRTa2VsZXRvblRpdGxlID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogRWxlbWVudFNrZWxldG9uLnByb3BzLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgcmV0dXJuIGgoRWxlbWVudFNrZWxldG9uLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6ICd2ay1za2VsZXRvbi10aXRsZScsXG4gICAgICBwcm9wczogcHJvcHNcbiAgICB9KSlcbiAgfVxufVxuXG52YXIgc2tlbGV0b25JbWFnZSA9IHtcbiAgbmFtZTogJ1ZrU2tlbGV0b25JbWFnZScsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBFbGVtZW50U2tlbGV0b25JbWFnZS5wcm9wcyxcbiAgcmVuZGVyOiBFbGVtZW50U2tlbGV0b25JbWFnZS5yZW5kZXJcbn1cblxudmFyIHNrZWxldG9uVGV4dCA9IHtcbiAgbmFtZTogJ1ZrU2tlbGV0b25UZXh0JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnRTa2VsZXRvblRleHQucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudFNrZWxldG9uVGV4dC5yZW5kZXJcbn1cblxudmFyIHNrZWxldG9uVGl0bGUgPSB7XG4gIG5hbWU6ICdWa1NrZWxldG9uVGl0bGUnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogRWxlbWVudFNrZWxldG9uVGl0bGUucHJvcHMsXG4gIHJlbmRlcjogRWxlbWVudFNrZWxldG9uVGl0bGUucmVuZGVyXG59XG5cbnZhciBJY29uJDIgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gKGgsIGN0eCkge1xuICAgIHZhciBwcm9wcyA9IGN0eC5wcm9wcztcbiAgICB2YXIgcmF0aW8gPSBwcm9wcy5yYXRpbyB8fCAxO1xuICAgIHZhciB3aWR0aCA9IHByb3BzLndpZHRoIHx8IDMwO1xuICAgIHZhciBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgMzA7XG4gICAgdmFyIHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94IHx8ICcwIDAgMzAgMzAnO1xuICAgIGlmIChyYXRpbyAhPT0gMSkge1xuICAgICAgd2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogcmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoKCdzdmcnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB2ZXJzaW9uOiAnMS4xJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdmlld0JveDogdmlld0JveFxuICAgICAgfSxcbiAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgIGlubmVySFRNTDogJzxjaXJjbGUgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCIjMDAwXCIgY3g9XCIxNVwiIGN5PVwiMTVcIiByPVwiMTRcIi8+J1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRTcGlubmVyID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHJhdGlvOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgcmV0dXJuIGgoJ2RpdicsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogWyd1ay1pY29uJywgJ3VrLXNwaW5uZXInXVxuICAgIH0pLCBbXG4gICAgICBoKEljb24kMiwgeyBwcm9wczogcHJvcHMgfSlcbiAgICBdKVxuICB9XG59XG5cbnZhciBzcGlubmVyID0ge1xuICBuYW1lOiAnVmtTcGlubmVyJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnRTcGlubmVyLnByb3BzLFxuICByZW5kZXI6IEVsZW1lbnRTcGlubmVyLnJlbmRlclxufVxuXG52YXIgQUNUSVZFID0gJ2FjdGl2ZSc7XG52YXIgSU5BQ1RJVkUgPSAnaW5hY3RpdmUnO1xuXG52YXIgc3RpY2t5ID0ge1xuICBuYW1lOiAnVmtTdGlja3knLFxuICBhYnN0cmFjdDogdHJ1ZSxcbiAgbWl4aW5zOiBbRXZlbnRzTWl4aW4sIE1peGluRmFzdGRvbV0sXG4gIHByb3BzOiB7XG4gICAgdG9wOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBvZmZzZXQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIHdpZHRoRWxlbWVudDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHNob3dPblVwOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG1lZGlhOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddXG4gICAgfSxcbiAgICBzZWxUYXJnZXQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgdGFyZ2V0OiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBCb29sZWFuXSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICBjbGFzc01hcHBpbmc6IHtcbiAgICBjbHNGaXhlZDogJ3VrLXN0aWNreS1maXhlZCcsXG4gICAgY2xzQmVsb3c6ICd1ay1zdGlja3ktYmVsb3cnLFxuICAgIGNsc0FjdGl2ZTogJ3VrLWFjdGl2ZScsXG4gICAgY2xzSW5hY3RpdmU6ICcnXG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgaXNBY3RpdmU6IGZhbHNlXG4gIH0pOyB9LFxuICBjb21wdXRlZDoge1xuICAgIG91dGVySGVpZ2h0OiBmdW5jdGlvbiBvdXRlckhlaWdodCAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuaXNBY3RpdmUgPyB0aGlzLiRyZWZzLnBsYWNlaG9sZGVyIDogdGhpcy4kZWwpLm9mZnNldEhlaWdodFxuICAgIH0sXG4gICAgJHNlbFRhcmdldDogZnVuY3Rpb24gJHNlbFRhcmdldCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxUYXJnZXRcbiAgICAgICAgPyAkKHRoaXMuc2VsVGFyZ2V0LCB0aGlzLiRlbClcbiAgICAgICAgOiB0aGlzLiRlbFxuICAgIH1cbiAgfSxcbiAgZmFzdGRvbTogW1xuICAgIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSAoKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLiRyZWZzO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByZWYucGxhY2Vob2xkZXI7XG4gICAgICAgIHZhciB3aWR0aEVsZW1lbnQgPSByZWYud2lkdGhFbGVtZW50O1xuICAgICAgICB2YXIgb3V0ZXJIZWlnaHQgPSAodGhpcy5pc0FjdGl2ZSA/IHBsYWNlaG9sZGVyIDogdGhpcy4kZWwpLm9mZnNldEhlaWdodDtcbiAgICAgICAgY3NzKHBsYWNlaG9sZGVyLCBhc3NpZ24oXG4gICAgICAgICAge2hlaWdodDogY3NzKHRoaXMuJGVsLCAncG9zaXRpb24nKSAhPT0gJ2Fic29sdXRlJyA/IG91dGVySGVpZ2h0IDogJyd9LFxuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgWydtYXJnaW5Ub3AnLCAnbWFyZ2luQm90dG9tJywgJ21hcmdpbkxlZnQnLCAnbWFyZ2luUmlnaHQnXSlcbiAgICAgICAgKSk7XG4gICAgICAgIGlmICghd2l0aGluKHBsYWNlaG9sZGVyLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICBhZnRlcih0aGlzLiRlbCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIGF0dHIocGxhY2Vob2xkZXIsICdoaWRkZW4nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cih3aWR0aEVsZW1lbnQsICdoaWRkZW4nLCBudWxsKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgYXR0cih3aWR0aEVsZW1lbnQsICdoaWRkZW4nLCB0aGlzLmlzQWN0aXZlID8gbnVsbCA6ICcnKTtcbiAgICAgICAgdGhpcy50b3BPZmZzZXQgPSBvZmZzZXQodGhpcy5pc0FjdGl2ZSA/IHBsYWNlaG9sZGVyIDogdGhpcy4kZWwpLnRvcDtcbiAgICAgICAgdGhpcy5ib3R0b21PZmZzZXQgPSB0aGlzLnRvcE9mZnNldCArIG91dGVySGVpZ2h0O1xuICAgICAgICB2YXIgYm90dG9tID0gcGFyc2VQcm9wKCdib3R0b20nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zdGlja0F0ID0gTWF0aC5tYXgodG9GbG9hdChwYXJzZVByb3AoJ3RvcCcsIHRoaXMpKSwgdGhpcy50b3BPZmZzZXQpIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHRoaXMuc3RpY2tVbnRpbCA9IGJvdHRvbSAmJiBib3R0b20gLSBvdXRlckhlaWdodDtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZSA9IHRoaXMubWVkaWEgJiYgIXdpbmRvdy5tYXRjaE1lZGlhKHRvTWVkaWEodGhpcy5tZWRpYSkpLm1hdGNoZXM7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czogWydsb2FkJywgJ3Jlc2l6ZSddXG4gICAgfSxcbiAgICB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkIChfLCByZWYpIHtcbiAgICAgICAgdmFyIHNjcm9sbFkgPSByZWYuc2Nyb2xsWTsgaWYgKCBzY3JvbGxZID09PSB2b2lkIDAgKSBzY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbFk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2Nyb2xsOiBzY3JvbGxZLFxuICAgICAgICAgIHZpc2libGU6IGlzVmlzaWJsZSh0aGlzLiRlbClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSAocmVmLCByZWYkMSkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgdmFyIHZpc2libGUgPSByZWYudmlzaWJsZTtcbiAgICAgICAgdmFyIHNjcm9sbCA9IHJlZi5zY3JvbGw7XG4gICAgICAgIGlmICggcmVmJDEgPT09IHZvaWQgMCApIHJlZiQxID0ge307XG4gICAgICAgIHZhciBkaXIgPSByZWYkMS5kaXI7XG4gICAgICAgIGlmIChzY3JvbGwgPCAwIHx8ICF2aXNpYmxlIHx8IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5zaG93T25VcCAmJiAhZGlyKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5hY3RpdmUgfHxcbiAgICAgICAgICBzY3JvbGwgPCB0aGlzLnN0aWNrQXQgfHxcbiAgICAgICAgICB0aGlzLnNob3dPblVwICYmIChzY3JvbGwgPD0gdGhpcy5zdGlja0F0IHx8IGRpciA9PT0gJ2Rvd24nIHx8IGRpciA9PT0gJ3VwJyAmJiAhdGhpcy5pc0FjdGl2ZSAmJiBzY3JvbGwgPD0gdGhpcy5ib3R0b21PZmZzZXQpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb24gJiYgc2Nyb2xsID4gdGhpcy50b3BPZmZzZXQpIHtcbiAgICAgICAgICAgIEFuaW1hdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgICAgQW5pbWF0aW9uLm91dCh0aGlzLiRlbCwgKFwidWstYW5pbWF0aW9uLVwiICsgKHRoaXMuYW5pbWF0aW9uKSkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmhpZGUoKTsgfSwgbm9vcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgIEFuaW1hdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgIEFuaW1hdGlvbi5pbih0aGlzLiRlbCwgKFwidWstYW5pbWF0aW9uLVwiICsgKHRoaXMuYW5pbWF0aW9uKSkpLmNhdGNoKG5vb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRzOiBbJ3Njcm9sbCddXG4gICAgfVxuICBdLFxuICBtZXRob2RzOiB7XG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICBhdHRyKHRoaXMuJHJlZnMucGxhY2Vob2xkZXIsICdoaWRkZW4nLCBudWxsKTtcbiAgICB9LFxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUgKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXMuJG9wdGlvbnMuY2xhc3NNYXBwaW5nO1xuICAgICAgdmFyIGNsc0ZpeGVkID0gcmVmLmNsc0ZpeGVkO1xuICAgICAgdmFyIGNsc0JlbG93ID0gcmVmLmNsc0JlbG93O1xuICAgICAgdmFyIGNsc0FjdGl2ZSA9IHJlZi5jbHNBY3RpdmU7XG4gICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgaGFzQ2xhc3ModGhpcy4kc2VsVGFyZ2V0LCBjbHNBY3RpdmUpKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoSU5BQ1RJVkUpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIGNsc0ZpeGVkLCBjbHNCZWxvdyk7XG4gICAgICBjc3ModGhpcy4kZWwsIHsgcG9zaXRpb246ICcnLCB0b3A6ICcnLCB3aWR0aDogJycgfSk7XG4gICAgICBhdHRyKHRoaXMuJHJlZnMucGxhY2Vob2xkZXIsICdoaWRkZW4nLCAnJyk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcy4kb3B0aW9ucy5jbGFzc01hcHBpbmc7XG4gICAgICB2YXIgY2xzRml4ZWQgPSByZWYuY2xzRml4ZWQ7XG4gICAgICB2YXIgY2xzQmVsb3cgPSByZWYuY2xzQmVsb3c7XG4gICAgICB2YXIgY2xzQWN0aXZlID0gcmVmLmNsc0FjdGl2ZTtcbiAgICAgIHZhciBhY3RpdmUgPSB0aGlzLnN0aWNrQXQgIT09IDAgfHwgdGhpcy5zY3JvbGwgPiB0aGlzLnN0aWNrQXQ7XG4gICAgICB2YXIgdG9wID0gTWF0aC5tYXgoMCwgdGhpcy5vZmZzZXQpO1xuICAgICAgaWYgKHRoaXMuc3RpY2tVbnRpbCAmJiB0aGlzLnNjcm9sbCA+IHRoaXMuc3RpY2tVbnRpbCAtIHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRvcCA9IHRoaXMuc3RpY2tVbnRpbCAtIHRoaXMuc2Nyb2xsO1xuICAgICAgfVxuICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICB0b3A6ICh0b3AgKyBcInB4XCIpLFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aFxuICAgICAgfSk7XG4gICAgICBpZiAoaGFzQ2xhc3ModGhpcy4kc2VsVGFyZ2V0LCBjbHNBY3RpdmUpKSB7XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdChJTkFDVElWRSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoQUNUSVZFKTtcbiAgICAgIH1cbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCBjbHNCZWxvdywgdGhpcy5zY3JvbGwgPiB0aGlzLmJvdHRvbU9mZnNldCk7XG4gICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgY2xzRml4ZWQpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHRoaXMuJG9wdGlvbnMuY2xhc3NNYXBwaW5nO1xuICAgIHZhciBjbHNBY3RpdmUgPSByZWYuY2xzQWN0aXZlO1xuICAgIHZhciBjbHNJbmFjdGl2ZSA9IHJlZi5jbHNJbmFjdGl2ZTtcbiAgICB0aGlzLiRvbihBQ1RJVkUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcGxhY2VDbGFzcyh0aGlzJDEuJHNlbFRhcmdldCwgY2xzSW5hY3RpdmUsIGNsc0FjdGl2ZSk7IH0pO1xuICAgIHRoaXMuJG9uKElOQUNUSVZFLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXBsYWNlQ2xhc3ModGhpcyQxLiRzZWxUYXJnZXQsIGNsc0FjdGl2ZSwgY2xzSW5hY3RpdmUpOyB9KTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1zdGlja3knKTtcbiAgICB0aGlzLiRyZWZzLnBsYWNlaG9sZGVyID0gJCgnPGRpdiBjbGFzcz1cInVrLXN0aWNreS1wbGFjZWhvbGRlclwiPjwvZGl2PicpO1xuICAgIHRoaXMuJHJlZnMud2lkdGhFbGVtZW50ID0gKHRoaXMud2lkdGhFbGVtZW50ICYmIHF1ZXJ5KHRoaXMud2lkdGhFbGVtZW50KSkgfHwgdGhpcy4kcmVmcy5wbGFjZWhvbGRlcjtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfSxcbiAgZG9tUmVhZHk6IGZ1bmN0aW9uIGRvbVJlYWR5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoISh0aGlzLnRhcmdldCAmJiBsb2NhdGlvbi5oYXNoICYmIHdpbmRvdy5wYWdlWU9mZnNldCA+IDApKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHRhcmdldCA9ICQobG9jYXRpb24uaGFzaCk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgZmFzdGRvbS5yZWFkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZiA9IG9mZnNldCh0YXJnZXQpO1xuICAgICAgICB2YXIgdG9wID0gcmVmLnRvcDtcbiAgICAgICAgdmFyIGVsVG9wID0gb2Zmc2V0KHRoaXMkMS4kZWwpLnRvcDtcbiAgICAgICAgdmFyIGVsSGVpZ2h0ID0gdGhpcyQxLiRlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmIChlbFRvcCArIGVsSGVpZ2h0ID49IHRvcCAmJiBlbFRvcCA8PSB0b3AgKyB0YXJnZXQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHRvcCAtIGVsSGVpZ2h0IC0gdGhpcyQxLnRhcmdldCAtIHRoaXMkMS5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLmNsYXNzTWFwcGluZztcbiAgICB2YXIgY2xzSW5hY3RpdmUgPSByZWYuY2xzSW5hY3RpdmU7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kc2VsVGFyZ2V0LCBjbHNJbmFjdGl2ZSk7XG4gICAgfVxuICAgIHJlbW92ZSh0aGlzLiRyZWZzLnBsYWNlaG9sZGVyKTtcbiAgICB0aGlzLiRyZWZzLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICB0aGlzLiRyZWZzLndpZHRoRWxlbWVudCA9IG51bGw7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2hpbGRyZW4gPSBmaWx0ZXJPdXRUZXh0Tm9kZXMoY2hpbGRyZW4pO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2Fybigndmstc3RpY2t5IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCcsIHRoaXMuJHBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblswXVxuICB9XG59XG5mdW5jdGlvbiBwYXJzZVByb3AgKHByb3AsIHJlZikge1xuICB2YXIgJHByb3BzID0gcmVmLiRwcm9wcztcbiAgdmFyICRlbCA9IHJlZi4kZWw7XG4gIHZhciBwcm9wT2Zmc2V0ID0gcmVmWyhwcm9wICsgXCJPZmZzZXRcIildO1xuICB2YXIgdmFsdWUgPSAkcHJvcHNbcHJvcF07XG4gIHZhbHVlID0gaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlID09PSAnJ1xuICAgID8gdHJ1ZVxuICAgIDogdmFsdWU7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNOdW1lcmljKHZhbHVlKSkge1xuICAgIHJldHVybiBwcm9wT2Zmc2V0ICsgdG9GbG9hdCh2YWx1ZSlcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgL14tP1xcZCt2aCQvLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGhlaWdodCh3aW5kb3cpICogdG9GbG9hdCh2YWx1ZSkgLyAxMDBcbiAgfSBlbHNlIHtcbiAgICB2YXIgZWwgPSB2YWx1ZSA9PT0gdHJ1ZSA/ICRlbC5wYXJlbnROb2RlIDogcXVlcnkodmFsdWUsICRlbCk7XG4gICAgaWYgKGVsKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0KGVsKS50b3AgKyBlbC5vZmZzZXRIZWlnaHRcbiAgICB9XG4gIH1cbn1cblxudmFyIEVsZW1lbnRTdWJuYXYgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgZGl2aWRlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBwaWxsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGRpdmlkZWQgPSBwcm9wcy5kaXZpZGVkO1xuICAgIHZhciBwaWxsID0gcHJvcHMucGlsbDtcbiAgICByZXR1cm4gaCgndWwnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IFsndWstc3VibmF2Jywge1xuICAgICAgICAndWstc3VibmF2LWRpdmlkZXInOiBkaXZpZGVkLFxuICAgICAgICAndWstc3VibmF2LXBpbGwnOiBwaWxsXG4gICAgICB9XVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudFN1Ym5hdkl0ZW0gPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBhY3RpdmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGxpc3RlbmVycyA9IHJlZi5saXN0ZW5lcnM7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIGFjdGl2ZSA9IHByb3BzLmFjdGl2ZTtcbiAgICB2YXIgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICBkZWxldGUgZGF0YS5vbjtcbiAgICByZXR1cm4gaCgnbGknLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ3VrLWFjdGl2ZSc6IGFjdGl2ZSAmJiAhZGlzYWJsZWQsXG4gICAgICAgICd1ay1kaXNhYmxlZCc6IGRpc2FibGVkXG4gICAgICB9XG4gICAgfSksIFsgZGlzYWJsZWRcbiAgICAgID8gaCgnc3BhbicsIHRpdGxlKVxuICAgICAgOiBoKCdhJywgeyBvbjogbGlzdGVuZXJzIH0sIHRpdGxlKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRTdWJuYXZJdGVtRHJvcGRvd24gPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgIHZhciB0aXRsZSA9IHByb3BzLnRpdGxlO1xuICAgIHJldHVybiBoKCdsaScsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczoge1xuICAgICAgICAndWstZGlzYWJsZWQnOiBkaXNhYmxlZFxuICAgICAgfVxuICAgIH0pLCBbXG4gICAgICBkaXNhYmxlZFxuICAgICAgICA/IGgoJ3NwYW4nLCB0aXRsZSlcbiAgICAgICAgOiBjaGlsZHJlblxuICAgIF0pXG4gIH1cbn1cblxudmFyIHN1Ym5hdiA9IHtcbiAgbmFtZTogJ1ZrU3VibmF2JyxcbiAgcHJvcHM6IGFzc2lnbih7fSwgRWxlbWVudFN1Ym5hdi5wcm9wcywge1xuICAgIGFjdGl2ZUl0ZW06IHt9XG4gIH0pLFxuICBkYXRhOiBmdW5jdGlvbiAodm0pIHsgcmV0dXJuICh7XG4gICAgc3RhdGU6IHtcbiAgICAgIGFjdGl2ZUl0ZW06IHZtLmFjdGl2ZUl0ZW0gfHwgZmlsdGVySXRlbXModm0pLnNoaWZ0KCkuZGF0YS5rZXkgfHwgMFxuICAgIH1cbiAgfSk7IH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zICgpIHtcbiAgICAgIHJldHVybiAodGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRhZzsgfSlcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgYWN0aXZlSXRlbTogZnVuY3Rpb24gYWN0aXZlSXRlbSAodmFsKSB7XG4gICAgICB0aGlzLnN0YXRlLmFjdGl2ZUl0ZW0gPSB2YWw7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdHJpZ2dlclVwZGF0ZTogZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZSAodmFsKSB7XG4gICAgICB0aGlzLnN0YXRlLmFjdGl2ZUl0ZW0gPSB2YWw7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6YWN0aXZlSXRlbScsIHZhbCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHJldHVybiBoKEVsZW1lbnRTdWJuYXYsIHtcbiAgICAgIHByb3BzOiB0aGlzLiRwcm9wc1xuICAgIH0sIGZpbHRlckl0ZW1zKHRoaXMpLm1hcChmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFub2RlLmZuT3B0aW9ucykge1xuICAgICAgICB3YXJuKCd2ay1zdWJ2bmF2IC0+IGNvbXBvbmVudHMgbXVzdCBiZSBmdW5jdGlvbmFsJywgdGhpcyQxKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSBnZXQobm9kZSwgJ2RhdGEua2V5JywgaW5kZXgpO1xuICAgICAgcmV0dXJuIG5vZGUuZGF0YS5yZXJlbmRlclxuICAgICAgICA/IGgobm9kZS5mbk9wdGlvbnMsIG1lcmdlRGF0YSh7fSwgbm9kZS5kYXRhLCB7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgcmVyZW5kZXJpbmc6IHRydWUsXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGFjdGl2ZTogSlNPTi5zdHJpbmdpZnkoa2V5KSA9PT0gSlNPTi5zdHJpbmdpZnkodGhpcyQxLnN0YXRlLmFjdGl2ZUl0ZW0pXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgbm9kZS5jaGlsZHJlbilcbiAgICAgICAgOiBub2RlXG4gICAgfSkpXG4gIH1cbn1cbmZ1bmN0aW9uIGZpbHRlckl0ZW1zICh2bSkge1xuICByZXR1cm4gdm0uJHNsb3RzLmRlZmF1bHQuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRhZzsgfSlcbn1cblxudmFyIHN1Ym5hdl9JdGVtID0ge1xuICBuYW1lOiAnVmtTdWJuYXZJdGVtJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IEVsZW1lbnRTdWJuYXZJdGVtLnByb3BzLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgaWYgKGRhdGEucmVyZW5kZXJpbmcpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmNsYXNzO1xuICAgIH1cbiAgICByZXR1cm4gaChFbGVtZW50U3VibmF2SXRlbSwgbWVyZ2VEYXRhKGRhdGEsIHsgcHJvcHM6IHByb3BzIH0sIHtcbiAgICAgIHJlcmVuZGVyOiB0cnVlLFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHBhcmVudC50cmlnZ2VyVXBkYXRlKGRhdGEua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbnZhciBJY29uVHJpYW5nZURvd24gPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gKGgsIHJlZikge1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCB8fCAyMDtcbiAgICB2YXIgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8IDIwO1xuICAgIHZhciB2aWV3Qm94ID0gcHJvcHMudmlld0JveCB8fCAnMCAwIDIwIDIwJztcbiAgICByZXR1cm4gaCgnc3ZnJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdmVyc2lvbjogJzEuMScsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHZpZXdCb3g6IHZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBkb21Qcm9wczoge1xuICAgICAgICBpbm5lckhUTUw6ICc8cG9seWdvbiBwb2ludHM9XCI1IDcgMTUgNyAxMCAxMlwiIC8+J1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudmFyIHN1Ym5hdl9JdGVtRHJvcGRvd24gPSB7XG4gIG5hbWU6ICdWa1N1Ym5hdkl0ZW1Ecm9wZG93bicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBhc3NpZ24oe30sIEVsZW1lbnRTdWJuYXZJdGVtRHJvcGRvd24ucHJvcHMsIERyb3Bkb3duLnByb3BzLCB7XG4gICAgbW9kZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgIH1cbiAgfSksXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciB0aXRsZSA9IHByb3BzLnRpdGxlO1xuICAgIHJldHVybiBoKEVsZW1lbnRTdWJuYXZJdGVtRHJvcGRvd24sIHsgcHJvcHM6IHByb3BzIH0sIFtcbiAgICAgIGgoJ2EnLCB7XG4gICAgICAgIGNsYXNzOiBbJ3VrLWljb24nXVxuICAgICAgfSwgW1xuICAgICAgICB0aXRsZSArICcgJyxcbiAgICAgICAgaChJY29uVHJpYW5nZURvd24pXG4gICAgICBdKSxcbiAgICAgIGgoRHJvcGRvd24sIHtcbiAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICB9LCBbXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICBdKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIE1peGluU29ydCA9IHtcbiAgcHJvcHM6IHtcbiAgICBzb3J0ZWRCeToge1xuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfVxuICB9XG59XG5cbnZhciBST1dfSUQgPSAnX192a1RhYmxlX3Jvd0lkJztcbnZhciBST1dfTEVWRUwgPSAnX192a1RhYmxlX3Jvd0xldmVsJztcbnZhciBST1dfQ0hJTERSRU5fQ09VTlQgPSAnX192a1RhYmxlX3Jvd0NoaWxkcmVuQ291bnQnO1xudmFyIFJPV19DTElDS19QUkVWRU5URUQgPSAnX192a1RhYmxlX3Jvd0NsaWNrUHJldmVudGVkJztcbnZhciBPTl9DTElDS19ST1cgPSAnY2xpY2stcm93JztcbnZhciBVUERBVEVfU09SVEVEQlkgPSAndXBkYXRlOnNvcnRlZEJ5JztcbnZhciBVUERBVEVfRVhQQU5ERURST1dTID0gJ3VwZGF0ZTpleHBhbmRlZFJvd3MnO1xudmFyIFVQREFURV9TRUxFQ1RFRFJPV1MgPSAndXBkYXRlOnNlbGVjdGVkUm93cyc7XG5cbnZhciBNaXhpblNlbGVjdCA9IHtcbiAgcHJvcHM6IHtcbiAgICBzZWxlY3RlZFJvd3M6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH1cbiAgICB9LFxuICAgIHJvd1NlbGVjdGFibGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgcm93c1NlbGVjdGFibGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNlbGVjdFJvdzogZnVuY3Rpb24gc2VsZWN0Um93IChyb3cpIHtcbiAgICAgIHZhciBpZCA9IHJvd1tST1dfSURdO1xuICAgICAgaWYgKHRoaXMucm93U2VsZWN0YWJsZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJvd1NlbGVjdGlvbihbaWRdKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gW10uY29uY2F0KCB0aGlzLnNlbGVjdGVkUm93cyApO1xuICAgICAgc2VsZWN0ZWRSb3dzLnB1c2goaWQpO1xuICAgICAgdGhpcy51cGRhdGVSb3dTZWxlY3Rpb24oc2VsZWN0ZWRSb3dzKTtcbiAgICB9LFxuICAgIHVuc2VsZWN0Um93OiBmdW5jdGlvbiB1bnNlbGVjdFJvdyAocm93KSB7XG4gICAgICB2YXIgaWQgPSByb3dbUk9XX0lEXTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuc2VsZWN0ZWRSb3dzLmluZGV4T2YoaWQpO1xuICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IFtdLmNvbmNhdCggdGhpcy5zZWxlY3RlZFJvd3MgKTtcbiAgICAgIHNlbGVjdGVkUm93cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy51cGRhdGVSb3dTZWxlY3Rpb24oc2VsZWN0ZWRSb3dzKTtcbiAgICB9LFxuICAgIHRvZ2dsZVJvd1NlbGVjdGlvbjogZnVuY3Rpb24gdG9nZ2xlUm93U2VsZWN0aW9uIChyb3cpIHtcbiAgICAgIHRoaXMuaXNSb3dTZWxlY3RlZChyb3cpXG4gICAgICAgID8gdGhpcy51bnNlbGVjdFJvdyhyb3cpXG4gICAgICAgIDogdGhpcy5zZWxlY3RSb3cocm93KTtcbiAgICB9LFxuICAgIHRvZ2dsZVJvd3NTZWxlY3Rpb246IGZ1bmN0aW9uIHRvZ2dsZVJvd3NTZWxlY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLmFsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZFJvd3MgPSB0aGlzLnJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd1tST1dfSURdOyB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUm93U2VsZWN0aW9uKHNlbGVjdGVkUm93cyk7XG4gICAgfSxcbiAgICBpc1Jvd1NlbGVjdGVkOiBmdW5jdGlvbiBpc1Jvd1NlbGVjdGVkIChyb3cpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc2VsZWN0ZWRSb3dzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShpZCkgPT09IEpTT04uc3RyaW5naWZ5KHJvd1tST1dfSURdKTsgfSkubGVuZ3RoKVxuICAgIH0sXG4gICAgdXBkYXRlUm93U2VsZWN0aW9uOiBmdW5jdGlvbiB1cGRhdGVSb3dTZWxlY3Rpb24gKHNlbGVjdGVkUm93cykge1xuICAgICAgdGhpcy4kZW1pdChVUERBVEVfU0VMRUNURURST1dTLCBzZWxlY3RlZFJvd3MpO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBhbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uIGFsbFJvd3NTZWxlY3RlZCAoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZFJvd3MgJiYgdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoIDwgdGhpcy5yb3dzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMucm93cy5maWx0ZXIodGhpcy5pc1Jvd1NlbGVjdGVkKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZC5sZW5ndGggPT09IHRoaXMucm93cy5sZW5ndGhcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIGlmICh0aGlzLnJvd3NTZWxlY3RhYmxlIHx8IHRoaXMucm93U2VsZWN0YWJsZSkge1xuICAgICAgdGhpcy4kb24oT05fQ0xJQ0tfUk9XLCB0aGlzLnRvZ2dsZVJvd1NlbGVjdGlvbik7XG4gICAgfVxuICB9XG59XG5cbnZhciBFbGVtZW50VGFibGUgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgZGl2aWRlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIG5hcnJvd2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNlbGxNaWRkbGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc3RyaXBlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBob3ZlcmFibGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAganVzdGlmaWVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJlc3BvbnNpdmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICByZXR1cm4gaCgndGFibGUnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IFsndWstdGFibGUnLCB7XG4gICAgICAgICd1ay10YWJsZS1zbWFsbCc6IHByb3BzLm5hcnJvd2VkLFxuICAgICAgICAndWstdGFibGUtaG92ZXInOiBwcm9wcy5ob3ZlcmFibGUsXG4gICAgICAgICd1ay10YWJsZS1taWRkbGUnOiBwcm9wcy5jZWxsTWlkZGxlLFxuICAgICAgICAndWstdGFibGUtZGl2aWRlcic6IHByb3BzLmRpdmlkZWQsXG4gICAgICAgICd1ay10YWJsZS1zdHJpcGVkJzogcHJvcHMuc3RyaXBlZCxcbiAgICAgICAgJ3VrLXRhYmxlLWp1c3RpZnknOiBwcm9wcy5qdXN0aWZpZWQsXG4gICAgICAgICd1ay10YWJsZS1yZXNwb25zaXZlJzogcHJvcHMucmVzcG9uc2l2ZVxuICAgICAgfV1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRUYWJsZVRkID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGNlbGxNaWRkbGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc2hyaW5rZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZXhwYW5kZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBsaW5rZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdHJ1bmNhdGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHVud3JhcHBlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGNlbGxNaWRkbGUgPSBwcm9wcy5jZWxsTWlkZGxlO1xuICAgIHZhciBzaHJpbmtlZCA9IHByb3BzLnNocmlua2VkO1xuICAgIHZhciBleHBhbmRlZCA9IHByb3BzLmV4cGFuZGVkO1xuICAgIHZhciB3aWR0aCA9IHByb3BzLndpZHRoO1xuICAgIHZhciBsaW5rZWQgPSBwcm9wcy5saW5rZWQ7XG4gICAgdmFyIHRydW5jYXRlZCA9IHByb3BzLnRydW5jYXRlZDtcbiAgICB2YXIgdW53cmFwcGVkID0gcHJvcHMudW53cmFwcGVkO1xuICAgIHJldHVybiBoKCd0ZCcsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogKCBvYmogPSB7XG4gICAgICAgICd1ay10YWJsZS1saW5rJzogbGlua2VkLFxuICAgICAgICAndWstdGFibGUtbWlkZGxlJzogY2VsbE1pZGRsZSxcbiAgICAgICAgJ3VrLXRhYmxlLXNocmluayc6IHNocmlua2VkLFxuICAgICAgICAndWstdGFibGUtZXhwYW5kJzogZXhwYW5kZWQsXG4gICAgICAgICd1ay10ZXh0LW5vd3JhcCc6IHVud3JhcHBlZCxcbiAgICAgICAgJ3VrLXRleHQtdHJ1bmNhdGUnOiB0cnVuY2F0ZWRcbiAgICAgIH0sIG9ialsoXCJ1ay13aWR0aC1cIiArIHdpZHRoKV0gPSB3aWR0aCwgb2JqKVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudFRhYmxlVHIgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGFjdGl2ZSA9IHByb3BzLmFjdGl2ZTtcbiAgICByZXR1cm4gaCgndHInLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ3VrLWFjdGl2ZSc6IGFjdGl2ZVxuICAgICAgfVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudFRhYmxlVGggPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgc2hyaW5rZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZXhwYW5kZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgc2hyaW5rZWQgPSBwcm9wcy5zaHJpbmtlZDtcbiAgICB2YXIgZXhwYW5kZWQgPSBwcm9wcy5leHBhbmRlZDtcbiAgICByZXR1cm4gaCgndGgnLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ3VrLXRhYmxlLXNocmluayc6IHNocmlua2VkLFxuICAgICAgICAndWstdGFibGUtZXhwYW5kJzogZXhwYW5kZWRcbiAgICAgIH1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRUYWJsZVRoU29ydCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IGFzc2lnbih7fSwgRWxlbWVudFRhYmxlVGgucHJvcHMsIHtcbiAgICBvcmRlcjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfVxuICB9KSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgb3JkZXIgPSBwcm9wcy5vcmRlcjtcbiAgICByZXR1cm4gaChFbGVtZW50VGFibGVUaCwgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiAndmstdGFibGUtY29sdW1uLXNvcnQgdWstdmlzaWJsZS1ob3Zlci1pbmxpbmUnXG4gICAgfSksIFtcbiAgICAgIGgoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICd1ay10ZXh0LW5vd3JhcCB1ay1wb3NpdGlvbi1yZWxhdGl2ZSdcbiAgICAgIH0sIFtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGgoJ3NwYW4nLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgICAgIGNsYXNzOiBbJ3ZrLXRhYmxlLWNvbHVtbi1zb3J0X19hcnJvdyB1ay1wb3NpdGlvbi1hYnNvbHV0ZScsIHtcbiAgICAgICAgICAgICd1ay1pbnZpc2libGUnOiAhb3JkZXIsXG4gICAgICAgICAgICAndmstdGFibGUtY29sdW1uLXNvcnRfX2Fycm93LS1yb3RhdGVkJzogIW9yZGVyIHx8IG9yZGVyID09PSAnYXNjJ1xuICAgICAgICAgIH1dXG4gICAgICAgIH0pKVxuICAgICAgXSlcbiAgICBdKVxuICB9XG59XG5cbnZhciBSb3cgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgJHJvdyA9IGRhdGEuJHJvdztcbiAgICByZXR1cm4gaChFbGVtZW50VGFibGVUciwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYWN0aXZlOiBwYXJlbnQuaXNSb3dTZWxlY3RlZCgkcm93KVxuICAgICAgfSxcbiAgICAgIGNsYXNzOiByZXNvbHZlQ2xhc3MocGFyZW50LnJvd0NsYXNzLCAkcm93KSxcbiAgICAgIG9uOiB7XG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpc1ByZXZlbnRlZCA9IGVbUk9XX0NMSUNLX1BSRVZFTlRFRF07XG4gICAgICAgICAgdmFyIGlzSWdub3JlZFRhZyA9IC9eKEF8QlVUVE9OKSQvLnRlc3QoZS50YXJnZXQudGFnTmFtZSk7XG4gICAgICAgICAgaWYgKGlzUHJldmVudGVkIHx8IGlzSWdub3JlZFRhZykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC4kZW1pdChPTl9DTElDS19ST1csICRyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgY2hpbGRyZW4pXG4gIH1cbn07XG5mdW5jdGlvbiBSZW5kZXIgKGgsIHJlZikge1xuICB2YXIgcm93cyA9IHJlZi5yb3dzO1xuICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gIHZhciBjb2x1bW5zID0gcmVmLmNvbHVtbnM7XG4gIHZhciB0YWJsZSA9IHJlZi50YWJsZTtcbiAgY29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGlzVmFsaWQgPSBub2RlLmZuT3B0aW9ucyAmJiBub2RlLmZuT3B0aW9ucy5oZWFkUmVuZGVyICYmIG5vZGUuZm5PcHRpb25zLmNlbGxSZW5kZXI7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzVmFsaWQpIHtcbiAgICAgIHdhcm4oJ3ZrLXRhYmxlIC0+IHNvbWUgb2YgdGhlIGNvbHVtbnMgd2VyZSBmaWx0ZXJlZCBvdXQgYmVjYXVzZSB0aGV5IHdlcmUgbWlzc2luZyBhIGhlYWQgb3IgY2VsbCByZW5kZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkXG4gIH0pO1xuICB2YXIgaXNIZWFkbGVzcyA9ICFjb2x1bW5zLnNvbWUoXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRyZW4gfHwgZ2V0KG5vZGUsICdkYXRhLnByb3BzLnRpdGxlJykgfHwgZ2V0KG5vZGUsICdkYXRhLnByb3BzLmhlYWQnKTsgfVxuICApO1xuICByZXR1cm4gaChFbGVtZW50VGFibGUsIHsgcHJvcHM6IHByb3BzIH0sIFtcbiAgICBpc0hlYWRsZXNzIHx8IGgoJ3RoZWFkJywgW1xuICAgICAgaChFbGVtZW50VGFibGVUciwgY29sdW1ucy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGZuT3B0aW9ucyA9IG5vZGUuZm5PcHRpb25zO1xuICAgICAgICBkZWxldGUgbm9kZS5kYXRhLmNsYXNzO1xuICAgICAgICByZXR1cm4gaCh7XG4gICAgICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICAgICAgICByZW5kZXI6IGZuT3B0aW9ucy5oZWFkUmVuZGVyXG4gICAgICAgIH0sIG5vZGUuZGF0YSlcbiAgICAgIH0pKVxuICAgIF0pLFxuICAgIGgoJ3Rib2R5Jywgcm93cy5tYXAoZnVuY3Rpb24gKCRyb3csIGluZGV4KSB7XG4gICAgICByZXR1cm4gaChSb3csIHsgJHJvdzogJHJvdyB9LFxuICAgICAgICBjb2x1bW5zLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciByZWYgPSBub2RlLmRhdGE7XG4gICAgICAgICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgICAgICAgIHZhciBzbG90cyA9IHJlZi5zbG90cztcbiAgICAgICAgICB2YXIgc2NvcGVkU2xvdHMgPSByZWYuc2NvcGVkU2xvdHM7XG4gICAgICAgICAgdmFyIGZuT3B0aW9ucyA9IG5vZGUuZm5PcHRpb25zO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFmbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHdhcm4oJ3ZrLXRhYmxlIC0+IGNvbHVtbiBtdXN0IGJlIGEgZnVuY3Rpb25hbCBjb21wb25lbnQnLCB0YWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFmbk9wdGlvbnMuY2VsbFJlbmRlcikge1xuICAgICAgICAgICAgd2FybigndmstdGFibGUgLT4gY29sdW1uIGRlZmluaXRpb24gaXMgbWlzc2luZyBjZWxsUmVuZGVyJywgdGFibGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaCh7XG4gICAgICAgICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgcmVuZGVyOiBmbk9wdGlvbnMuY2VsbFJlbmRlclxuICAgICAgICAgIH0sIHsgJHJvdzogJHJvdywgcHJvcHM6IHByb3BzLCBzbG90czogc2xvdHMsIHNjb3BlZFNsb3RzOiBzY29wZWRTbG90cyB9KVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pKVxuICBdKVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzIChyb3dDbGFzcywgcm93KSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHJvd0NsYXNzKVxuICAgID8gcm93Q2xhc3Mocm93KVxuICAgIDogcm93Q2xhc3Ncbn1cblxudmFyIFRhYmxlID0ge1xuICBuYW1lOiAnVmtUYWJsZScsXG4gIG1peGluczogWyBNaXhpblNlbGVjdCwgTWl4aW5Tb3J0IF0sXG4gIGluaGVyaXRBdHRyczogZmFsc2UsXG4gIHByb3BzOiBhc3NpZ24oe30sIEVsZW1lbnRUYWJsZS5wcm9wcywge1xuICAgIGRhdGE6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHJvd0tleToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2lkJ1xuICAgIH0sXG4gICAgcm93Q2xhc3M6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uXG4gICAgfVxuICB9KSxcbiAgY29tcHV0ZWQ6IHtcbiAgICByb3dzOiBmdW5jdGlvbiByb3dzICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKF9yb3csIGluZGV4KSB7XG4gICAgICAgIHZhciByb3cgPSBhc3NpZ24oe30sIF9yb3cpO1xuICAgICAgICByb3dbUk9XX0lEXSA9IHJvd1t0aGlzJDEucm93S2V5XSB8fCBpbmRleDtcbiAgICAgICAgcmV0dXJuIHJvd1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIGNvbHVtbnMgPSBnZXQodGhpcywgJyRzbG90cy5kZWZhdWx0JywgW10pLmZpbHRlcihmdW5jdGlvbiAobikgeyByZXR1cm4gbi50YWc7IH0pO1xuICAgIHJldHVybiBSZW5kZXIoaCwge1xuICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgIHRhYmxlOiB0aGlzLFxuICAgICAgcm93czogdGhpcy5yb3dzLFxuICAgICAgcHJvcHM6IHRoaXMuJHByb3BzXG4gICAgfSlcbiAgfVxufVxuXG52YXIgdGFibGVUcmVlID0ge1xuICBuYW1lOiAnVmtUYWJsZVRyZWUnLFxuICBleHRlbmRzOiBUYWJsZSxcbiAgcHJvcHM6IHtcbiAgICBleHBhbmRlZFJvd3M6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH1cbiAgICB9LFxuICAgIGNoaWxkcmVuS2V5OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnY2hpbGRyZW4nXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHJvd3M6IGZ1bmN0aW9uIHJvd3MgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSwgcGFyZW50KSB7XG4gICAgICAgIGlmICggcGFyZW50ID09PSB2b2lkIDAgKSBwYXJlbnQgPSB7fTtcbiAgICAgICAgdmFyIGlkQ291bnQgPSAwO1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKF9yb3cpIHtcbiAgICAgICAgICB2YXIgcm93ID0gYXNzaWduKHt9LCBfcm93KTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSByb3dbdGhpcyQxLmNoaWxkcmVuS2V5XTtcbiAgICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgcm93W1JPV19MRVZFTF0gPSBwYXJlbnRbUk9XX0xFVkVMXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHBhcmVudFtST1dfTEVWRUxdICsgMVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICAgIHJvd1tST1dfSURdID0gcm93W3RoaXMkMS5yb3dLZXldXG4gICAgICAgICAgICA/IHJvd1t0aGlzJDEucm93S2V5XVxuICAgICAgICAgICAgOiByb3dbUk9XX0xFVkVMXSA9PT0gMFxuICAgICAgICAgICAgICA/IChcIlwiICsgKGlkQ291bnQrKykpXG4gICAgICAgICAgICAgIDogKChwYXJlbnRbUk9XX0lEXSkgKyBcIl9cIiArIChpZENvdW50KyspKTtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBpZiAoaGFzQ2hpbGRyZW4gJiYgdGhpcyQxLmlzRXhwYW5kZWQocm93KSkge1xuICAgICAgICAgICAgZmxhdHRlbihjaGlsZHJlbiwgcm93KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICByb3dbUk9XX0NISUxEUkVOX0NPVU5UXSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGRlbGV0ZSByb3dbdGhpcyQxLmNoaWxkcmVuS2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGZsYXR0ZW4odGhpcy5kYXRhKTtcbiAgICAgIHJldHVybiByb3dzXG4gICAgfSxcbiAgICB0aGVyZUFyZVN1YkxldmVsczogZnVuY3Rpb24gdGhlcmVBcmVTdWJMZXZlbHMgKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm93cy5zb21lKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd1tST1dfQ0hJTERSRU5fQ09VTlRdOyB9KVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGlzRXhwYW5kZWQ6IGZ1bmN0aW9uIGlzRXhwYW5kZWQgKHJvdykge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5leHBhbmRlZFJvd3NcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlkKSA9PT0gSlNPTi5zdHJpbmdpZnkocm93W1JPV19JRF0pOyB9KS5sZW5ndGgpXG4gICAgfSxcbiAgICB0b2dnbGVFeHBhbmQ6IGZ1bmN0aW9uIHRvZ2dsZUV4cGFuZCAocm93KSB7XG4gICAgICB2YXIgaWQgPSByb3dbUk9XX0lEXTtcbiAgICAgIHZhciBleHBhbmRlZFJvd3MgPSBbXS5jb25jYXQoIHRoaXMuZXhwYW5kZWRSb3dzICk7XG4gICAgICB2YXIgaW5kZXggPSBleHBhbmRlZFJvd3MuaW5kZXhPZihpZCk7XG4gICAgICB2YXIgaXNFeHBhbmRlZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgIGlzRXhwYW5kZWRcbiAgICAgICAgPyBleHBhbmRlZFJvd3Muc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICA6IGV4cGFuZGVkUm93cy5wdXNoKGlkKTtcbiAgICAgIHRoaXMuJGVtaXQoVVBEQVRFX0VYUEFOREVEUk9XUywgZXhwYW5kZWRSb3dzKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIGNvbHVtbnMgPSAodGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRhZzsgfSk7XG4gICAgcmV0dXJuIFJlbmRlcihoLCB7XG4gICAgICBjb2x1bW5zOiBjb2x1bW5zLFxuICAgICAgdGFibGU6IHRoaXMsXG4gICAgICByb3dzOiB0aGlzLnJvd3MsXG4gICAgICBwcm9wczogdGhpcy4kcHJvcHNcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIFJlbmRlckNlbGwgKGgsIGN0eCwgZGVmYXVsdENvbnRlbnQpIHtcbiAgdmFyIHByb3BzID0gY3R4LnByb3BzO1xuICB2YXIgZGF0YSA9IGN0eC5kYXRhO1xuICB2YXIgJHJvdyA9IGRhdGEuJHJvdztcbiAgdmFyIGNlbGwgPSBwcm9wcy5jZWxsO1xuICB2YXIgY2VsbENsYXNzID0gcHJvcHMuY2VsbENsYXNzO1xuICB2YXIgY2VsbFZhbHVlID0gZ2V0KCRyb3csIGNlbGwpO1xuICB2YXIgaXNFbXB0eSA9ICFpc1VuZGVmaW5lZChjZWxsKSAmJiBpc1VuZGVmaW5lZChjZWxsVmFsdWUpO1xuICB2YXIgc2NvcGUgPSBnZXRDZWxsU2NvcGUoY3R4KTtcbiAgdmFyIHNsb3RzID0gZ2V0Q2VsbFNsb3RzKGN0eCk7XG4gIHZhciBzbG90ID0gaXNFbXB0eSAmJiBzbG90cy5lbXB0eVxuICAgID8gc2xvdHMuZW1wdHlcbiAgICA6IHNsb3RzLmRlZmF1bHQgfHwgZGVmYXVsdENvbnRlbnQ7XG4gIHJldHVybiBoKEVsZW1lbnRUYWJsZVRkLCB7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNsYXNzOiBjZWxsQ2xhc3NcbiAgfSwgW1xuICAgIHNsb3Qoc2NvcGUpXG4gIF0pXG59XG5mdW5jdGlvbiBnZXRDZWxsU2NvcGUgKHJlZikge1xuICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICB2YXIgJHJvdyA9IGRhdGEuJHJvdztcbiAgdmFyIGNlbGwgPSBwcm9wcy5jZWxsO1xuICB2YXIgY2VsbFZhbHVlID0gZ2V0KCRyb3csIGNlbGwpO1xuICB2YXIgc2VsZWN0ZWQgPSBwYXJlbnQuaXNSb3dTZWxlY3RlZCgkcm93KTtcbiAgdmFyIGFsbFNlbGVjdGVkID0gcGFyZW50LmFsbFJvd3NTZWxlY3RlZDtcbiAgcmV0dXJuIHsgY2VsbDogY2VsbFZhbHVlLCByb3c6ICRyb3csIHNlbGVjdGVkOiBzZWxlY3RlZCwgYWxsU2VsZWN0ZWQ6IGFsbFNlbGVjdGVkIH1cbn1cbmZ1bmN0aW9uIGdldENlbGxTbG90cyAocmVmKSB7XG4gIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gIHZhciBkZWZhdWx0U2xvdCA9IGdldChkYXRhLCAnc2xvdHMuZGVmYXVsdCcpXG4gICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXQoZGF0YSwgJ3Nsb3RzLmRlZmF1bHQnKTsgfVxuICAgIDogZ2V0KGRhdGEsICdzY29wZWRTbG90cy5kZWZhdWx0Jyk7XG4gIHZhciBlbXB0eVNsb3QgPSBnZXQoZGF0YSwgJ3Nsb3RzLmVtcHR5JylcbiAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldChkYXRhLCAnc2xvdHMuZW1wdHknKTsgfVxuICAgIDogZ2V0KGRhdGEsICdzY29wZWRTbG90cy5lbXB0eScpO1xuICByZXR1cm4ge1xuICAgIGRlZmF1bHQ6IGRlZmF1bHRTbG90LFxuICAgIGVtcHR5OiBlbXB0eVNsb3RcbiAgfVxufVxuXG52YXIgQ29sdW1uID0ge1xuICBuYW1lOiAnVmtUYWJsZUNvbHVtbicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBhc3NpZ24oe30sIEVsZW1lbnRUYWJsZVRoLnByb3BzLCBFbGVtZW50VGFibGVUZC5wcm9wcywge1xuICAgIGNlbGw6IFN0cmluZyxcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGNlbGxDbGFzczogU3RyaW5nXG4gIH0pLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHNsb3RzID0gcmVmLnNsb3RzO1xuICAgIGRhdGEuc2xvdHMgPSBzbG90cygpO1xuICAgIHJldHVybiBoKCdkaXYnLCBtZXJnZURhdGEoe30sIGRhdGEsIHsgcHJvcHM6IHByb3BzIH0pKVxuICB9LFxuICBoZWFkUmVuZGVyOiBmdW5jdGlvbiBoZWFkUmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICByZXR1cm4gaChFbGVtZW50VGFibGVUaCwgbWVyZ2VEYXRhKHt9LCBkYXRhLCB7XG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBjbGFzczogJ3ZrLXRhYmxlLWNvbHVtbidcbiAgICB9KSwgcHJvcHMudGl0bGUpXG4gIH0sXG4gIGNlbGxSZW5kZXI6IGZ1bmN0aW9uIGNlbGxSZW5kZXIgKGgsIGN0eCkge1xuICAgIHJldHVybiBSZW5kZXJDZWxsKGgsIGN0eCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGNlbGwgPSByZWYuY2VsbDtcbiAgICAgIHJldHVybiBjZWxsO1xuICAgIH0pXG4gIH1cbn1cblxudmFyIHRhYmxlX0NvbHVtblNvcnQgPSB7XG4gIG5hbWU6ICdWa1RhYmxlQ29sdW1uU29ydCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBhc3NpZ24oe30sIENvbHVtbi5wcm9wcywgRWxlbWVudFRhYmxlVGhTb3J0LCB7XG4gICAgY2VsbDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0pLFxuICByZW5kZXI6IENvbHVtbi5yZW5kZXIsXG4gIGNlbGxSZW5kZXI6IENvbHVtbi5jZWxsUmVuZGVyLFxuICBoZWFkUmVuZGVyOiBmdW5jdGlvbiBoZWFkUmVuZGVyIChoLCByZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXBhcmVudC5zb3J0ZWRCeSkge1xuICAgICAgd2FybihcInZrLXRhYmxlLWNvbHVtbi1zb3J0IC0+IHRoZSB0YWJsZSAnc29ydGVkQnknIHByb3AgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyB0aGlzIGNvbHVtbi5cIiwgcGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGgoRWxlbWVudFRhYmxlVGhTb3J0LCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgcHJvcHM6IGFzc2lnbih7XG4gICAgICAgIG9yZGVyOiBnZXQocGFyZW50LCAoXCJzb3J0ZWRCeS5cIiArIChwcm9wcy5jZWxsKSkpXG4gICAgICB9LCBwcm9wcyksXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgc29ydGVkQnkgPSBnZXROZXdTb3J0T3JkZXIocGFyZW50LnNvcnRlZEJ5LCBwcm9wcy5jZWxsLCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgICBwYXJlbnQuJGVtaXQoVVBEQVRFX1NPUlRFREJZLCBzb3J0ZWRCeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgdGl0bGUgfHwgY2hpbGRyZW4pXG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5ld1NvcnRPcmRlciAoY3VycmVudFNvcnQsIGJ5LCBtdWx0aSkge1xuICB2YXIgc29ydCA9IHt9O1xuICB2YXIgb3JkZXIgPSBjdXJyZW50U29ydFtieV0gPT09ICdhc2MnXG4gICAgPyAnZGVzYydcbiAgICA6ICdhc2MnO1xuICBzb3J0W2J5XSA9IG9yZGVyO1xuICByZXR1cm4gbXVsdGlcbiAgICA/IGFzc2lnbih7fSwgY3VycmVudFNvcnQsIHNvcnQpXG4gICAgOiBzb3J0XG59XG5cbnZhciBFbGVtZW50Q2hlY2tib3ggPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBbJ2NoZWNrZWQnXSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBsaXN0ZW5lcnMgPSByZWYubGlzdGVuZXJzO1xuICAgIHZhciBkZWYgPSB7XG4gICAgICBzdGF0aWNDbGFzczogJ3VrLWNoZWNrYm94JyxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHR5cGU6ICdjaGVja2JveCdcbiAgICAgIH0sXG4gICAgICBkb21Qcm9wczoge1xuICAgICAgICBjaGVja2VkOiBwcm9wcy5jaGVja2VkXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgY2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUudGFyZ2V0LmNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaCgnaW5wdXQnLCBtZXJnZURhdGEoZGF0YSwgZGVmKSlcbiAgfVxufVxuXG52YXIgdGFibGVfQ29sdW1uU2VsZWN0ID0ge1xuICBuYW1lOiAnVmtUYWJsZUNvbHVtblNlbGVjdCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBhc3NpZ24oe30sIEVsZW1lbnRUYWJsZVRoLnByb3BzLCB7XG4gICAgY2VsbENsYXNzOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGhlYWRsZXNzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHNocmlua2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfSksXG4gIHJlbmRlcjogQ29sdW1uLnJlbmRlcixcbiAgaGVhZFJlbmRlcjogZnVuY3Rpb24gaGVhZFJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG4gICAgdmFyIGNvbnRlbnQgPSBwcm9wcy5oZWFkbGVzcyB8fCBoKCdzcGFuJywge1xuICAgICAgY2xhc3M6ICd1ay1mb3JtIHVrLXRleHQtY2VudGVyJ1xuICAgIH0sIFtcbiAgICAgIGgoRWxlbWVudENoZWNrYm94LCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2hlY2tlZDogcGFyZW50LmFsbFJvd3NTZWxlY3RlZFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gcGFyZW50LnRvZ2dsZVJvd3NTZWxlY3Rpb24oKTsgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pO1xuICAgIHJldHVybiBoKEVsZW1lbnRUYWJsZVRoLCBtZXJnZURhdGEoZGF0YSwge1xuICAgICAgcHJvcHM6IHsgc2hyaW5rZWQ6IHRydWUgfSxcbiAgICAgIGNsYXNzOiAndmstdGFibGUtY29sdW1uLXNlbGVjdCdcbiAgICB9KSwgWyBjb250ZW50IF0pXG4gIH0sXG4gIGNlbGxSZW5kZXI6IGZ1bmN0aW9uIGNlbGxSZW5kZXIgKGgsIGN0eCkge1xuICAgIHZhciBwYXJlbnQgPSBjdHgucGFyZW50O1xuICAgIHJldHVybiBSZW5kZXJDZWxsKGgsIGN0eCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIHJvdyA9IHJlZi5yb3c7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSByZWYuc2VsZWN0ZWQ7XG4gICAgICByZXR1cm4gaCgnc3BhbicsIHtcbiAgICAgIGNsYXNzOiAndWstZm9ybSB1ay10ZXh0LWNlbnRlcidcbiAgICB9LCBbXG4gICAgICBoKEVsZW1lbnRDaGVja2JveCwge1xuICAgICAgICBwcm9wczogeyBjaGVja2VkOiBzZWxlY3RlZCB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gcGFyZW50LnRvZ2dsZVJvd1NlbGVjdGlvbihyb3cpOyB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXSk7XG4gICAgfSlcbiAgfVxufVxuXG52YXIgVHJlZUFycm93ID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczogWydyb3RhdGVkJ10sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGgsIHJlZikge1xuICAgIHZhciBsaXN0ZW5lcnMgPSByZWYubGlzdGVuZXJzO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICByZXR1cm4gaCgnc3BhbicsIHtcbiAgICAgIG9uOiBsaXN0ZW5lcnMsXG4gICAgICBjbGFzczogWyd2ay10YWJsZS1jb2x1bW4tdHJlZV9fYXJyb3cnLCB7XG4gICAgICAgICd2ay10YWJsZS1jb2x1bW4tdHJlZV9fYXJyb3ctLXJvdGF0ZWQnOiBwcm9wcy5yb3RhdGVkXG4gICAgICB9XVxuICAgIH0pXG4gIH1cbn07XG52YXIgVHJlZUluZGVudCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgcmVmKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiBoKCdzcGFuJywgeyBjbGFzczogJ3ZrLXRhYmxlLWNvbHVtbi10cmVlX19pbmRlbnQnIH0sIGNoaWxkcmVuKVxuICB9XG59O1xudmFyIHRhYmxlX0NvbHVtblRyZWUgPSB7XG4gIG5hbWU6ICdWa1RhYmxlVHJlZUNvbHVtbicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiBhc3NpZ24oe30sIENvbHVtbi5wcm9wcyksXG4gIHJlbmRlcjogQ29sdW1uLnJlbmRlcixcbiAgaGVhZFJlbmRlcjogQ29sdW1uLmhlYWRSZW5kZXIsXG4gIGNlbGxSZW5kZXI6IGZ1bmN0aW9uIGNlbGxSZW5kZXIgKGgsIGN0eCkge1xuICAgIHZhciBwYXJlbnQgPSBjdHgucGFyZW50O1xuICAgIHJldHVybiBSZW5kZXJDZWxsKGgsIGN0eCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIHJvdyA9IHJlZi5yb3c7XG4gICAgICB2YXIgY2VsbCA9IHJlZi5jZWxsO1xuICAgICAgcmV0dXJuIFtcbiAgICAgIEFycmF5KHJvd1tST1dfTEVWRUxdKS5maWxsKGgoVHJlZUluZGVudCkpLFxuICAgICAgcGFyZW50LnRoZXJlQXJlU3ViTGV2ZWxzICYmIGgoVHJlZUluZGVudCwgW1xuICAgICAgICByb3dbUk9XX0NISUxEUkVOX0NPVU5UXSAmJiBoKFRyZWVBcnJvdywge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICByb3RhdGVkOiBwYXJlbnQuaXNFeHBhbmRlZChyb3cpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGVbUk9XX0NMSUNLX1BSRVZFTlRFRF0gPSB0cnVlO1xuICAgICAgICAgICAgICBwYXJlbnQudG9nZ2xlRXhwYW5kKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBoKCdzcGFuJywgY2VsbClcbiAgICBdO1xuICAgIH0pXG4gIH1cbn1cblxudmFyIFRBQl9JRCA9ICdfX3ZrVGFic19pZCc7XG5cbnZhciBpc05vdFByb2QkMSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG52YXIgY29yZSQyID0ge1xuICBwcm9wczoge1xuICAgIGFjdGl2ZVRhYjoge30sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG4gICAga2VlcEFsaXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICh2bSkgeyByZXR1cm4gKHtcbiAgICBzdGF0ZToge1xuICAgICAgYWN0aXZlVGFiOiB2bS5hY3RpdmVUYWIgfHwgZmlsdGVyVGFicyh2bSkuc2hpZnQoKS5kYXRhLmtleSB8fCAwXG4gICAgfVxuICB9KTsgfSxcbiAgd2F0Y2g6IHtcbiAgICBhY3RpdmVUYWI6IGZ1bmN0aW9uIGFjdGl2ZVRhYiAodmFsKSB7XG4gICAgICB0aGlzLnN0YXRlLmFjdGl2ZVRhYiA9IHZhbDtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYWN0aXZlVGFiQ29udGVudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEgKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZpbHRlclRhYnModGhpcylcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0aGlzJDEuaXNBY3RpdmUobm9kZS5kYXRhW1RBQl9JRF0pOyB9KVswXVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGdldFRhYnM6IGZ1bmN0aW9uIGdldFRhYnMgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICByZXR1cm4gZmlsdGVyVGFicyh0aGlzKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgICAgICAgIGlmICghbm9kZS5jb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAgICAgICBpc05vdFByb2QkMSAmJiB3YXJuKChcInZrLXRhYnMgLT4gZmFpbGVkIHRvIHByb2Nlc3MgJ1wiICsgKG5vZGUudGFnKSArIFwiJywgc2VlbXMgaXMgbm90IGEgc3RhdGVmdWwgY29tcG9uZW50XCIpLCB0aGlzJDEpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUua2V5ID0gZ2V0KG5vZGUsICdkYXRhLmtleScsIGluZGV4KTtcbiAgICAgICAgICBub2RlLmRhdGFbVEFCX0lEXSA9IG5vZGUua2V5O1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBzZXRBY3RpdmVUYWI6IGZ1bmN0aW9uIHNldEFjdGl2ZVRhYiAoaWQpIHtcbiAgICAgIHRoaXMuc3RhdGUuYWN0aXZlVGFiID0gaWQ7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6YWN0aXZlVGFiJywgaWQpO1xuICAgIH0sXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlIChpZCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuc3RhdGUuYWN0aXZlVGFiKSA9PT0gSlNPTi5zdHJpbmdpZnkoaWQpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJUYWJzICh2bSkge1xuICByZXR1cm4gdm0uJHNsb3RzLmRlZmF1bHQuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRhZzsgfSlcbn1cblxudmFyIEVsZW1lbnRUYWJzID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbGVmdCcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICF2YWwgfHwgL14obGVmdHxyaWdodHxjZW50ZXJ8anVzdGlmeSkkLy50ZXN0KHZhbCk7IH1cbiAgICB9LFxuICAgIGZsaXBwZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgcmVmKSB7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgdmFyIGZsaXBwZWQgPSBwcm9wcy5mbGlwcGVkO1xuICAgIHJldHVybiBoKCd1bCcsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczogWyd1ay10YWInLCAoIG9iaiA9IHtcbiAgICAgICAgJ3VrLXRhYi1ib3R0b20nOiBmbGlwcGVkLFxuICAgICAgICAndWstY2hpbGQtd2lkdGgtZXhwYW5kJzogYWxpZ24gPT09ICdqdXN0aWZ5J1xuICAgICAgfSwgb2JqWyhcInVrLWZsZXgtXCIgKyBhbGlnbildID0gL14ocmlnaHR8Y2VudGVyKSQvLnRlc3QoYWxpZ24pLCBvYmopXVxuICAgIH0pLCBjaGlsZHJlbilcbiAgfVxufVxuXG52YXIgRWxlbWVudFRhYnNWZXJ0aWNhbCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBhbGlnbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2xlZnQnLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAhdmFsIHx8IC9eKGxlZnR8cmlnaHQpJC8udGVzdCh2YWwpOyB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChoLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIGFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgcmV0dXJuIGgoJ3VsJywgbWVyZ2VEYXRhKGRhdGEsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLXRhYicsIChcInVrLXRhYi1cIiArIGFsaWduKV1cbiAgICB9KSwgY2hpbGRyZW4pXG4gIH1cbn1cblxudmFyIEVsZW1lbnRUYWJzSXRlbSA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiB7fSxcbiAgICB0aXRsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGFjdGl2ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdmFyIGxpc3RlbmVycyA9IHJlZi5saXN0ZW5lcnM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBhY3RpdmUgPSBwcm9wcy5hY3RpdmU7XG4gICAgdmFyIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGU7XG4gICAgdmFyIGljb24kJDEgPSBwcm9wcy5pY29uO1xuICAgIGRlbGV0ZSBkYXRhLm9uO1xuICAgIHJldHVybiBoKCdsaScsIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBjbGFzczoge1xuICAgICAgICAndWstYWN0aXZlJzogYWN0aXZlICYmICFkaXNhYmxlZCxcbiAgICAgICAgJ3VrLWRpc2FibGVkJzogZGlzYWJsZWRcbiAgICAgIH1cbiAgICB9KSwgW1xuICAgICAgaCgnYScsIHsgb246IGxpc3RlbmVycyB9LCBbXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBpY29uJCQxICYmIGgoRWxlbWVudEljb24sIHtcbiAgICAgICAgICBjbGFzczogJ3VrLW1hcmdpbi1zbWFsbC1sZWZ0J1xuICAgICAgICB9LCBbIGljb24kJDEgXSlcbiAgICAgIF0pLFxuICAgICAgY2hpbGRyZW5cbiAgICBdKVxuICB9XG59XG5cbnZhciB0YWJzID0ge1xuICBuYW1lOiAnVmtUYWJzJyxcbiAgZXh0ZW5kczogY29yZSQyLFxuICBtaXhpbnM6IFtFdmVudHNNaXhpbl0sXG4gIHByb3BzOiBFbGVtZW50VGFicy5wcm9wcyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZmxpcHBlZCA9IHJlZi5mbGlwcGVkO1xuICAgIHZhciBhbmltYXRpb24gPSByZWYuYW5pbWF0aW9uO1xuICAgIHZhciBrZWVwQWxpdmUgPSByZWYua2VlcEFsaXZlO1xuICAgIHZhciAkcHJvcHMgPSByZWYuJHByb3BzO1xuICAgIHZhciBUYWJzID0gdGhpcy5nZXRUYWJzKCk7XG4gICAgVGFicyA9IFRhYnMubWFwKGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgICAgdmFyIG9iajtcbiAgICAgIHZhciBUYWIgPSB7XG4gICAgICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgICAgIHJlbmRlcjogbm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iub3B0aW9ucy50YWJSZW5kZXJcbiAgICAgIH07XG4gICAgICByZXR1cm4gaChUYWIsICggb2JqID0ge30sIG9ialtUQUJfSURdID0gbm9kZS5kYXRhW1RBQl9JRF0sIG9iai5wcm9wcyA9IGFzc2lnbih7fSwgbm9kZS5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSwge1xuICAgICAgICAgIGFjdGl2ZTogdGhpcyQxLmlzQWN0aXZlKG5vZGUuZGF0YVtUQUJfSURdKVxuICAgICAgICB9KSwgb2JqKSlcbiAgICB9KTtcbiAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ3VrLWZsZXggdWstZmxleC1jb2x1bW4tcmV2ZXJzZSc6IGZsaXBwZWRcbiAgICAgIH1cbiAgICB9LCBbXG4gICAgICBoKEVsZW1lbnRUYWJzLCB7IHByb3BzOiAkcHJvcHMgfSwgVGFicyksXG4gICAgICBoKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiB7ICd1ay1tYXJnaW4nOiBmbGlwcGVkIH1cbiAgICAgIH0sIFtcbiAgICAgICAgaChUcmFuc2l0aW9uJDEsIHtcbiAgICAgICAgICBwcm9wczogeyBuYW1lOiBhbmltYXRpb24gfVxuICAgICAgICB9LCBbXG4gICAgICAgICAga2VlcEFsaXZlXG4gICAgICAgICAgICA/IGgoJ2tlZXAtYWxpdmUnLCBbIHRoaXMuYWN0aXZlVGFiQ29udGVudCBdKVxuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZVRhYkNvbnRlbnRcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgfVxufVxuXG52YXIgdGFic1ZlcnRpY2FsID0ge1xuICBuYW1lOiAnVmtUYWJzVmVydGljYWwnLFxuICBleHRlbmRzOiBjb3JlJDIsXG4gIHByb3BzOiBFbGVtZW50VGFic1ZlcnRpY2FsLnByb3BzLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBhbGlnbiA9IHJlZi5hbGlnbjtcbiAgICB2YXIgYW5pbWF0aW9uID0gcmVmLmFuaW1hdGlvbjtcbiAgICB2YXIga2VlcEFsaXZlID0gcmVmLmtlZXBBbGl2ZTtcbiAgICB2YXIgJHByb3BzID0gcmVmLiRwcm9wcztcbiAgICB2YXIgVGFicyA9IHRoaXMuZ2V0VGFicygpLm1hcChmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgIHZhciBvYmo7XG4gICAgICB2YXIgVGFiID0ge1xuICAgICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgICAgICByZW5kZXI6IG5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yLm9wdGlvbnMudGFiUmVuZGVyXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGgoVGFiLCAoIG9iaiA9IHt9LCBvYmpbVEFCX0lEXSA9IG5vZGUuZGF0YVtUQUJfSURdLCBvYmoucHJvcHMgPSBhc3NpZ24oe30sIG5vZGUuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsIHtcbiAgICAgICAgICBhY3RpdmU6IHRoaXMkMS5pc0FjdGl2ZShub2RlLmRhdGFbVEFCX0lEXSlcbiAgICAgICAgfSksIG9iaikpXG4gICAgfSk7XG4gICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgIGNsYXNzOiBbJ3VrLWdyaWQnLCB7XG4gICAgICAgICd1ay1mbGV4IHVrLWZsZXgtcm93LXJldmVyc2UnOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgfV1cbiAgICB9LCBbXG4gICAgICBoKCdkaXYnLCB7IGNsYXNzOiAndWstd2lkdGgtYXV0bycgfSwgW1xuICAgICAgICBoKEVsZW1lbnRUYWJzVmVydGljYWwsIHsgcHJvcHM6ICRwcm9wcyB9LCBUYWJzKVxuICAgICAgXSksXG4gICAgICBoKCdkaXYnLCB7IGNsYXNzOiAndWstd2lkdGgtZXhwYW5kJyB9LCBbXG4gICAgICAgIGgoVHJhbnNpdGlvbiQxLCB7XG4gICAgICAgICAgcHJvcHM6IHsgbmFtZTogYW5pbWF0aW9uIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgIGtlZXBBbGl2ZVxuICAgICAgICAgICAgPyBoKCdrZWVwLWFsaXZlJywgWyB0aGlzLmFjdGl2ZVRhYkNvbnRlbnQgXSlcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVUYWJDb250ZW50XG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIHRhYnNfSXRlbSA9IHtcbiAgbmFtZTogJ1ZrVGFic0l0ZW0nLFxuICBwcm9wczogYXNzaWduKHt9LCBFbGVtZW50VGFic0l0ZW0ucHJvcHMsIHtcbiAgICBpY29uOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9XG4gIH0pLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHJldHVybiBoKCdkaXYnLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9LFxuICB0YWJSZW5kZXI6IGZ1bmN0aW9uIHRhYlJlbmRlciAoaCwgcmVmKSB7XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHByb3BzLmljb24gPSBwcm9wcy5pY29uICYmIGgoKFwidmstaWNvbnMtXCIgKyAocHJvcHMuaWNvbikpKTtcbiAgICByZXR1cm4gaChFbGVtZW50VGFic0l0ZW0sIG1lcmdlRGF0YShkYXRhLCB7XG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcGFyZW50LnNldEFjdGl2ZVRhYihkYXRhW1RBQl9JRF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIGNoaWxkcmVuKVxuICB9XG59XG5cblxuXG52YXIgY29tcG9uZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbkJyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG5CcmVhZGNydW1iSXRlbTogYnJlYWRjcnVtYl9JdGVtLFxuQnV0dG9uOiBidXR0b24sXG5CdXR0b25MaW5rOiBidXR0b25MaW5rLFxuQnV0dG9uR3JvdXA6IGJ1dHRvbkdyb3VwLFxuQ2FyZDogY2FyZCxcbkNhcmRUaXRsZTogY2FyZF9UaXRsZSxcbkRyb3A6IERyb3AsXG5Ecm9wZG93bjogRHJvcGRvd24sXG5HcmlkOiBHcmlkLFxuSWNvbjogaWNvbixcbkljb25MaW5rOiBpY29uTGluayxcbkljb25CdXR0b246IGljb25CdXR0b24sXG5JY29uSW1hZ2U6IGljb25JbWFnZSxcbkljb25uYXY6IGljb25uYXYsXG5JY29ubmF2VmVydGljYWw6IGljb25uYXZWZXJ0aWNhbCxcbkljb25uYXZJdGVtOiBpY29ubmF2X0l0ZW0sXG5MYWJlbDogbGFiZWwsXG5Nb2RhbDogbW9kYWwsXG5Nb2RhbEZ1bGw6IG1vZGFsRnVsbCxcbk1vZGFsQ2xvc2U6IG1vZGFsX0Nsb3NlLFxuTW9kYWxGdWxsQ2xvc2U6IG1vZGFsRnVsbF9DbG9zZSxcbk1vZGFsVGl0bGU6IG1vZGFsX1RpdGxlLFxuTmF2OiBuYXYkMSxcbk5hdkRyb3Bkb3duOiBuYXZEcm9wZG93bixcbk5hdkl0ZW06IG5hdl9JdGVtLFxuTmF2SXRlbURpdmlkZXI6IG5hdl9JdGVtRGl2aWRlcixcbk5hdkl0ZW1IZWFkZXI6IG5hdl9JdGVtSGVhZGVyLFxuTmF2SXRlbVBhcmVudDogbmF2X0l0ZW1QYXJlbnQsXG5OYXZiYXI6IG5hdmJhcixcbk5hdmJhckZ1bGw6IG5hdmJhckZ1bGwsXG5OYXZiYXJEcm9wYmFyOiBuYXZiYXJEcm9wYmFyLFxuTmF2YmFySXRlbTogbmF2YmFyX0l0ZW0sXG5OYXZiYXJMb2dvOiBuYXZiYXJfTG9nbyxcbk5hdmJhclRvZ2dsZTogbmF2YmFyX1RvZ2dsZSxcbk5hdmJhck5hdjogbmF2YmFyX05hdixcbk5hdmJhck5hdkl0ZW06IG5hdmJhcl9OYXZfSXRlbSxcbk5hdmJhck5hdkRyb3Bkb3duOiBuYXZiYXJfTmF2X0Ryb3Bkb3duLFxuTmF2YmFyTmF2RHJvcGRvd25OYXY6IG5hdmJhcl9OYXZfRHJvcGRvd25fTmF2LFxuTm90aWZpY2F0aW9uOiBub3RpZmljYXRpb24sXG5PZmZjYW52YXM6IG9mZmNhbnZhcyxcbk9mZmNhbnZhc0NvbnRlbnQ6IG9mZmNhbnZhc0NvbnRlbnQsXG5PZmZjYW52YXNCYXI6IG9mZmNhbnZhc19CYXIsXG5PZmZjYW52YXNDbG9zZTogb2ZmY2FudmFzX0Nsb3NlLFxuUGFnaW5hdGlvbjogcGFnaW5hdGlvbixcblBhZ2luYXRpb25QYWdlczogcGFnaW5hdGlvbl9QYWdlcyxcblBhZ2luYXRpb25QYWdlRmlyc3Q6IHBhZ2luYXRpb25fUGFnZUZpcnN0LFxuUGFnaW5hdGlvblBhZ2VQcmV2OiBwYWdpbmF0aW9uX1BhZ2VQcmV2LFxuUGFnaW5hdGlvblBhZ2VOZXh0OiBwYWdpbmF0aW9uX1BhZ2VOZXh0LFxuUGFnaW5hdGlvblBhZ2VMYXN0OiBwYWdpbmF0aW9uX1BhZ2VMYXN0LFxuU2Nyb2xsc3B5OiBzY3JvbGxzcHksXG5TY3JvbGxzcHlOYXY6IHNjcm9sbHNweU5hdixcblNrZWxldG9uSW1hZ2U6IHNrZWxldG9uSW1hZ2UsXG5Ta2VsZXRvblRleHQ6IHNrZWxldG9uVGV4dCxcblNrZWxldG9uVGl0bGU6IHNrZWxldG9uVGl0bGUsXG5TcGlubmVyOiBzcGlubmVyLFxuU3RpY2t5OiBzdGlja3ksXG5TdWJuYXY6IHN1Ym5hdixcblN1Ym5hdkl0ZW06IHN1Ym5hdl9JdGVtLFxuU3VibmF2SXRlbURyb3Bkb3duOiBzdWJuYXZfSXRlbURyb3Bkb3duLFxuVGFibGU6IFRhYmxlLFxuVGFibGVUcmVlOiB0YWJsZVRyZWUsXG5UYWJsZUNvbHVtbjogQ29sdW1uLFxuVGFibGVDb2x1bW5Tb3J0OiB0YWJsZV9Db2x1bW5Tb3J0LFxuVGFibGVDb2x1bW5TZWxlY3Q6IHRhYmxlX0NvbHVtblNlbGVjdCxcblRhYmxlQ29sdW1uVHJlZTogdGFibGVfQ29sdW1uVHJlZSxcblRhYnM6IHRhYnMsXG5UYWJzVmVydGljYWw6IHRhYnNWZXJ0aWNhbCxcblRhYnNJdGVtOiB0YWJzX0l0ZW1cbn0pO1xuXG52YXIgTkFNRVNQQUNFJDMgPSAnX192a1Njcm9sbCc7XG52YXIgaW5kZXgkMSA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCQkMSAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbTkFNRVNQQUNFJDNdID0ge307XG4gIH0sXG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbTkFNRVNQQUNFJDNdLm9wdGlvbnMgPSBnZXRPcHRpb25zJDMoeyBiaW5kaW5nOiBiaW5kaW5nLCB2bm9kZTogdm5vZGUgfSk7XG4gICAgZWxbTkFNRVNQQUNFJDNdLnVuYmluZCA9IG9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIG9wdHMgPSBlbFtOQU1FU1BBQ0UkM10ub3B0aW9ucztcbiAgICAgIHZhciBpc0FuY2hvciA9IGUudGFyZ2V0Lm5vZGVOYW1lID09PSAnQSc7XG4gICAgICBpZiAoIWlzQW5jaG9yIHx8IChlLmRlZmF1bHRQcmV2ZW50ZWQgJiYgIW9wdHMuZm9yY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCB8fCBtYXRjaGVzJDEoZWwsIGUudGFyZ2V0LCBvcHRzLnRhcmdldCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzY3JvbGxUbyhlbCwgZS50YXJnZXQsIGVzY2FwZShlLnRhcmdldC5oYXNoKS5zdWJzdHIoMSksIG9wdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFtOQU1FU1BBQ0UkM10ub3B0aW9ucyA9IGdldE9wdGlvbnMkMyh7IGJpbmRpbmc6IGJpbmRpbmcsIHZub2RlOiB2bm9kZSB9KTtcbiAgfSxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKGVsKSB7XG4gICAgaWYgKCFlbFtOQU1FU1BBQ0UkM10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbFtOQU1FU1BBQ0UkM10udW5iaW5kKCk7XG4gICAgZGVsZXRlIGVsW05BTUVTUEFDRSQzXTtcbiAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsVG8gKGVsLCBmcm9tRWwsIHRvRWwsIG9wdGlvbnMpIHtcbiAgdG9FbCA9ICh0b0VsICYmICQodG9FbCkpIHx8IGRvY3VtZW50LmJvZHk7XG4gIHZhciBkb2NIZWlnaHQgPSBoZWlnaHQoZG9jdW1lbnQpO1xuICB2YXIgd2luSGVpZ2h0ID0gaGVpZ2h0KHdpbmRvdyk7XG4gIHZhciB0YXJnZXQgPSBvZmZzZXQodG9FbCkudG9wIC0gb3B0aW9ucy5vZmZzZXQ7XG4gIGlmICh0YXJnZXQgKyB3aW5IZWlnaHQgPiBkb2NIZWlnaHQpIHtcbiAgICB0YXJnZXQgPSBkb2NIZWlnaHQgLSB3aW5IZWlnaHQ7XG4gIH1cbiAgaWYgKCF0cmlnZ2VyKGVsLCAnYmVmb3JlU2Nyb2xsJywgeyBmcm9tOiBmcm9tRWwsIHRvOiB0b0VsIH0pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgdmFyIHN0YXJ0WSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRZID0gc3RhcnRZICsgKHRhcmdldCAtIHN0YXJ0WSkgKiBlYXNlKFxuICAgICAgY2xhbXAoKERhdGUubm93KCkgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uKVxuICAgICk7XG4gICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5wYWdlWE9mZnNldCwgY3VycmVudFkpO1xuICAgIGlmIChjdXJyZW50WSAhPT0gdGFyZ2V0KSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIoZWwsICdhZnRlclNjcm9sbCcsIHsgZnJvbTogZnJvbUVsLCB0bzogdG9FbCB9KTtcbiAgICB9XG4gIH07XG4gIHN0ZXAoKTtcbn1cbmZ1bmN0aW9uIGVhc2UgKGspIHtcbiAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKVxufVxuZnVuY3Rpb24gZ2V0T3B0aW9ucyQzIChjdHgpIHtcbiAgdmFyIHJlZiA9IGN0eC5iaW5kaW5nO1xuICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSByZWYubW9kaWZpZXJzO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB7IHRhcmdldDogdmFsdWUgfTtcbiAgfVxuICByZXR1cm4gYXNzaWduKHtcbiAgICBvZmZzZXQ6IDAsXG4gICAgdGFyZ2V0OiAnYScsXG4gICAgZm9yY2U6IGZhbHNlLFxuICAgIGR1cmF0aW9uOiAxMDAwXG4gIH0sIG1vZGlmaWVycywgdmFsdWUpXG59XG5mdW5jdGlvbiBtYXRjaGVzJDEgKGVsLCB0YXJnZXQsIHNlbGVjdG9yKSB7XG4gIHZhciBtYXRjaGVzJCQxID0gJCQoKFwiXCIgKyBzZWxlY3RvciksIGVsKTtcbiAgdmFyIGkgPSBtYXRjaGVzJCQxLmxlbmd0aDtcbiAgd2hpbGUgKC0taSA+PSAwICYmIG1hdGNoZXMkJDFbaV0gIT09IHRhcmdldCkge31cbiAgcmV0dXJuIGkgPiAtMVxufVxuXG52YXIgTkFNRVNQQUNFJDQgPSAnX192a1Rvb2x0aXAnO1xudmFyIGluZGV4JDIgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQkJDEgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW05BTUVTUEFDRSQ0XSA9IHtcbiAgICAgIHZub2RlOiB2bm9kZSxcbiAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgb3B0aW9uczogZ2V0T3B0aW9ucyQ0KHsgYmluZGluZzogYmluZGluZyB9KVxuICAgIH07XG4gICAgaWYgKGhhc0F0dHIoZWwsICd0aXRsZScpKSB7XG4gICAgICBlbFtOQU1FU1BBQ0UkNF0uYXR0clRpdGxlID0gYXR0cihlbCwgJ3RpdGxlJyk7XG4gICAgICBhdHRyKGVsLCB7IHRpdGxlOiAnJyB9KTtcbiAgICB9XG4gICAgZWxbTkFNRVNQQUNFJDRdLnRpdGxlID0gZWxbTkFNRVNQQUNFJDRdLm9wdGlvbnMudGl0bGUgfHwgZWxbTkFNRVNQQUNFJDRdLmF0dHJUaXRsZTtcbiAgfSxcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBiaW5kRXZlbnRzKGVsKTtcbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbTkFNRVNQQUNFJDRdLm9wdGlvbnMgPSBnZXRPcHRpb25zJDQoeyBiaW5kaW5nOiBiaW5kaW5nIH0pO1xuICAgIGVsW05BTUVTUEFDRSQ0XS50aXRsZSA9IGVsW05BTUVTUEFDRSQ0XS5vcHRpb25zLnRpdGxlIHx8IGVsW05BTUVTUEFDRSQ0XS5hdHRyVGl0bGU7XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAoIWVsW05BTUVTUEFDRSQ0XSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIF9oaWRlKGVsKTtcbiAgICBhdHRyKGVsLCB7IHRpdGxlOiBlbFtOQU1FU1BBQ0UkNF0uYXR0clRpdGxlIHx8IG51bGwgfSk7XG4gICAgZWxbTkFNRVNQQUNFJDRdLnVuYmluZEV2ZW50cygpO1xuICAgIGRlbGV0ZSBlbFtOQU1FU1BBQ0UkNF07XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRFdmVudHMgKGVsKSB7XG4gIHZhciBldmVudHMgPSBbXG4gICAgb24oZWwsIChcImZvY3VzIFwiICsgcG9pbnRlckVudGVyICsgXCIgXCIgKyBwb2ludGVyRG93biksIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS50eXBlICE9PSBwb2ludGVyRG93biB8fCAhaXNUb3VjaChlKSkge1xuICAgICAgICBzaG93KGVsKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBvbihlbCwgJ2JsdXInLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGlkZShlbCk7IH0pLFxuICAgIG9uKGVsLCBwb2ludGVyTGVhdmUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgaGlkZShlbCk7XG4gICAgICB9XG4gICAgfSlcbiAgXTtcbiAgZWxbTkFNRVNQQUNFJDRdLnVuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh1bmJpbmQpIHsgcmV0dXJuIHVuYmluZCgpOyB9KTsgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUluIChlbCkge1xuICB2YXIgcmVmID0gZWxbTkFNRVNQQUNFJDRdLm9wdGlvbnM7XG4gIHZhciBjbHMgPSByZWYuY2xzO1xuICB2YXIgcG9zaXRpb24kJDEgPSByZWYucG9zaXRpb247XG4gIHZhciBhbmltYXRpb24gPSByZWYuYW5pbWF0aW9uO1xuICB2YXIgZHVyYXRpb24gPSByZWYuZHVyYXRpb247XG4gIGlmICghdHJpZ2dlcihlbCwgJ2JlZm9yZVNob3cnKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpXG4gIH1cbiAgdmFyIG9yaWdpbiA9IGVsW05BTUVTUEFDRSQ0XS5vcmlnaW4gPSBnZXRPcmlnaW4ocG9zaXRpb24kJDEpO1xuICB2YXIgdG9vbHRpcCA9IGVsW05BTUVTUEFDRSQ0XS50b29sdGlwID0gY3JlYXRlVG9vbHRpcChlbCk7XG4gIHBvc2l0aW9uVG9vbHRpcChlbCk7XG4gIGFkZENsYXNzKHRvb2x0aXAsIGNscyk7XG4gIGVsW05BTUVTUEFDRSQ0XS5oaWRlVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc1Zpc2libGUoZWwpKSB7XG4gICAgICBoaWRlKGVsKTtcbiAgICB9XG4gIH0sIDE1MCk7XG4gIGVsW05BTUVTUEFDRSQ0XS5zdGF0ZSA9ICdpbic7XG4gIHRyaWdnZXIoZWwsICdzaG93Jyk7XG4gIHJldHVybiBBbmltYXRpb25cbiAgICAuaW4odG9vbHRpcCwgKFwidWstYW5pbWF0aW9uLVwiICsgKGFuaW1hdGlvblswXSkpLCBkdXJhdGlvbiwgb3JpZ2luKVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsW05BTUVTUEFDRSQ0XS5zdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgdHJpZ2dlcihlbCwgJ3Nob3duJyk7XG4gICAgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24gKCkge30pXG59XG5mdW5jdGlvbiB0b2dnbGVPdXQgKGVsKSB7XG4gIHZhciByZWYgPSBlbFtOQU1FU1BBQ0UkNF07XG4gIHZhciB0b29sdGlwID0gcmVmLnRvb2x0aXA7XG4gIHZhciByZWYkMSA9IGVsW05BTUVTUEFDRSQ0XS5vcHRpb25zO1xuICB2YXIgYW5pbWF0aW9uID0gcmVmJDEuYW5pbWF0aW9uO1xuICB2YXIgZHVyYXRpb24gPSByZWYkMS5kdXJhdGlvbjtcbiAgaWYgKCF0cmlnZ2VyKGVsLCAnYmVmb3JlSGlkZScpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KClcbiAgfVxuICBBbmltYXRpb24uY2FuY2VsKHRvb2x0aXApO1xuICBlbFtOQU1FU1BBQ0UkNF0uc3RhdGUgPSAnb3V0JztcbiAgdHJpZ2dlcihlbCwgJ2hpZGUnKTtcbiAgaWYgKCFhbmltYXRpb25bMV0pIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfaGlkZShlbCk7IH0pXG4gIH1cbiAgcmV0dXJuIEFuaW1hdGlvblxuICAgIC5vdXQodG9vbHRpcCwgKFwidWstYW5pbWF0aW9uLVwiICsgKGFuaW1hdGlvblsxXSkpLCBkdXJhdGlvbiwgb3JpZ2luKVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9oaWRlKGVsKTsgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24gKCkge30pXG59XG5mdW5jdGlvbiBzaG93IChlbCkge1xuICB2YXIgcmVmID0gZWxbTkFNRVNQQUNFJDRdLm9wdGlvbnM7XG4gIHZhciBkZWxheSA9IHJlZi5kZWxheTtcbiAgdmFyIHJlZiQxID0gZWxbTkFNRVNQQUNFJDRdO1xuICB2YXIgc3RhdGUgPSByZWYkMS5zdGF0ZTtcbiAgdmFyIHRpdGxlID0gcmVmJDEudGl0bGU7XG4gIGlmICghdGl0bGUgfHwgc3RhdGUgPT09ICdhY3RpdmUnIHx8IGVsW05BTUVTUEFDRSQ0XS5zaG93VGltZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoc3RhdGUgPT09ICdvdXQnKSB7XG4gICAgQW5pbWF0aW9uLmNhbmNlbChlbCk7XG4gICAgX2hpZGUoZWwpO1xuICB9XG4gIGVsW05BTUVTUEFDRSQ0XS5zaG93VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvZ2dsZUluKGVsKTsgfSwgZGVsYXkpO1xufVxuZnVuY3Rpb24gaGlkZSAoZWwpIHtcbiAgaWYgKCFlbFtOQU1FU1BBQ0UkNF0pIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVmID0gZWxbTkFNRVNQQUNFJDRdO1xuICB2YXIgc3RhdGUgPSByZWYuc3RhdGU7XG4gIGNsZWFyQWxsVGltZXJzKGVsKTtcbiAgaWYgKHN0YXRlID09PSAnb3V0JyB8fCAobWF0Y2hlcyhlbCwgJ2lucHV0JykgJiYgaXNGb2N1c2VkKGVsKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB0b2dnbGVPdXQoZWwpO1xufVxuZnVuY3Rpb24gX2hpZGUgKGVsKSB7XG4gIGlmICghZWxbTkFNRVNQQUNFJDRdKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlZiA9IGVsW05BTUVTUEFDRSQ0XTtcbiAgdmFyIHRvb2x0aXAgPSByZWYudG9vbHRpcDtcbiAgdmFyIHJlZiQxID0gZWxbTkFNRVNQQUNFJDRdLm9wdGlvbnM7XG4gIHZhciBjbHMgPSByZWYkMS5jbHM7XG4gIGF0dHIoZWwsICdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICByZW1vdmVDbGFzcyh0b29sdGlwLCBjbHMpO1xuICB0b29sdGlwICYmIHJlbW92ZSh0b29sdGlwKTtcbiAgZWxbTkFNRVNQQUNFJDRdLnN0YXRlID0gbnVsbDtcbiAgZWxbTkFNRVNQQUNFJDRdLnRvb2x0aXAgPSBudWxsO1xuICB0cmlnZ2VyKGVsLCAnaGlkZGVuJyk7XG59XG5mdW5jdGlvbiBjbGVhckFsbFRpbWVycyAoZWwpIHtcbiAgY2xlYXJUaW1lb3V0KGVsW05BTUVTUEFDRSQ0XS5zaG93VGltZXIpO1xuICBjbGVhclRpbWVvdXQoZWxbTkFNRVNQQUNFJDRdLmhpZGVUaW1lcik7XG4gIGVsW05BTUVTUEFDRSQ0XS5zaG93VGltZXIgPSBudWxsO1xuICBlbFtOQU1FU1BBQ0UkNF0uaGlkZVRpbWVyID0gbnVsbDtcbn1cbmZ1bmN0aW9uIHBvc2l0aW9uVG9vbHRpcCAoZWwpIHtcbiAgdmFyIHRhcmdldCA9IGVsO1xuICB2YXIgcmVmID0gZWxbTkFNRVNQQUNFJDRdO1xuICB2YXIgdG9vbHRpcCA9IHJlZi50b29sdGlwO1xuICB2YXIgcmVmJDEgPSBlbFtOQU1FU1BBQ0UkNF0ub3B0aW9ucztcbiAgdmFyIGNsc1BvcyA9IHJlZiQxLmNsc1BvcztcbiAgdmFyIHBvc2l0aW9uJCQxID0gcmVmJDEucG9zaXRpb247XG4gIHZhciByZWYkMiA9IGVsW05BTUVTUEFDRSQ0XS5vcHRpb25zO1xuICB2YXIgb2Zmc2V0JCQxID0gcmVmJDIub2Zmc2V0O1xuICB2YXIgbm9kZTtcbiAgdmFyIHJlZiQzID0gcG9zaXRpb24kJDEuc3BsaXQoJy0nKTtcbiAgdmFyIGRpciA9IHJlZiQzWzBdO1xuICB2YXIgYWxpZ24gPSByZWYkM1sxXTsgaWYgKCBhbGlnbiA9PT0gdm9pZCAwICkgYWxpZ24gPSAnY2VudGVyJztcbiAgcmVtb3ZlQ2xhc3Nlcyh0b29sdGlwLCAoY2xzUG9zICsgXCItKHRvcHxib3R0b218bGVmdHxyaWdodCkoLVthLXpdKyk/XCIpKTtcbiAgY3NzKHRvb2x0aXAsIHsgdG9wOiAnJywgbGVmdDogJycgfSk7XG4gIHZhciBheGlzID0gZ2V0QXhpcyQxKHBvc2l0aW9uJCQxKTtcbiAgb2Zmc2V0JCQxID0gaXNOdW1lcmljKG9mZnNldCQkMSlcbiAgICA/IG9mZnNldCQkMVxuICAgIDogKG5vZGUgPSAkKG9mZnNldCQkMSkpXG4gICAgICA/IG9mZnNldChub2RlKVtheGlzID09PSAneCcgPyAnbGVmdCcgOiAndG9wJ10gLSBvZmZzZXQodGFyZ2V0KVtheGlzID09PSAneCcgPyAncmlnaHQnIDogJ2JvdHRvbSddXG4gICAgICA6IDA7XG4gIHZhciBlbEF0dGFjaCA9IGF4aXMgPT09ICd4J1xuICAgID8gKChmbGlwUG9zaXRpb24oZGlyKSkgKyBcIiBcIiArIGFsaWduKVxuICAgIDogKGFsaWduICsgXCIgXCIgKyAoZmxpcFBvc2l0aW9uKGRpcikpKTtcbiAgdmFyIHRhcmdldEF0dGFjaCA9IGF4aXMgPT09ICd4J1xuICAgID8gKGRpciArIFwiIFwiICsgYWxpZ24pXG4gICAgOiAoYWxpZ24gKyBcIiBcIiArIGRpcik7XG4gIHZhciBlbE9mZnNldCA9IGF4aXMgPT09ICd4J1xuICAgID8gKFwiXCIgKyAoZGlyID09PSAnbGVmdCcgPyAtMSAqIG9mZnNldCQkMSA6IG9mZnNldCQkMSkpXG4gICAgOiAoXCJcIiArIChkaXIgPT09ICd0b3AnID8gLTEgKiBvZmZzZXQkJDEgOiBvZmZzZXQkJDEpKTtcbiAgdmFyIHRhcmdldE9mZnNldCA9IG51bGw7XG4gIHZhciByZWYkNCA9IHBvc2l0aW9uQXQoXG4gICAgdG9vbHRpcCxcbiAgICB0YXJnZXQsXG4gICAgZWxBdHRhY2gsXG4gICAgdGFyZ2V0QXR0YWNoLFxuICAgIGVsT2Zmc2V0LFxuICAgIHRhcmdldE9mZnNldCxcbiAgICB0cnVlXG4gICkudGFyZ2V0O1xuICB2YXIgeCA9IHJlZiQ0Lng7XG4gIHZhciB5ID0gcmVmJDQueTtcbiAgZGlyID0gYXhpcyA9PT0gJ3gnID8geCA6IHk7XG4gIGFsaWduID0gYXhpcyA9PT0gJ3gnID8geSA6IHg7XG4gIHRvZ2dsZUNsYXNzKHRvb2x0aXAsIChjbHNQb3MgKyBcIi1cIiArIGRpciArIFwiLVwiICsgYWxpZ24pLCBlbFtOQU1FU1BBQ0UkNF0ub3B0aW9ucy5vZmZzZXQgPT09IGZhbHNlKTtcbiAgcmV0dXJuIHtcbiAgICBkaXI6IGRpcixcbiAgICBhbGlnbjogYWxpZ25cbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3B0aW9ucyQ0IChjdHgpIHtcbiAgdmFyIHJlZiA9IGN0eC5iaW5kaW5nO1xuICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSByZWYubW9kaWZpZXJzO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB7IHRpdGxlOiB2YWx1ZSB9O1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhtb2RpZmllcnMpLmxlbmd0aCkge1xuICAgIHZhciBmaXJzdEtleSA9IE9iamVjdC5rZXlzKG1vZGlmaWVycylbMF07XG4gICAgbW9kaWZpZXJzID0geyBwb3NpdGlvbjogZmlyc3RLZXkgfTtcbiAgfVxuICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7XG4gICAgZGVsYXk6IDAsXG4gICAgdGl0bGU6ICcnLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgZHVyYXRpb246IDEwMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgY29udGFpbmVyOiB0cnVlLFxuICAgIGNsczogJ3VrLWFjdGl2ZScsXG4gICAgY2xzUG9zOiAndWstdG9vbHRpcCcsXG4gICAgYW5pbWF0aW9uOiAnc2NhbGUtdXAnXG4gIH0sIG1vZGlmaWVycywgdmFsdWUpO1xuICBvcHRpb25zLnBvc2l0aW9uID0gaHlwaGVuYXRlKG9wdGlvbnMucG9zaXRpb24pO1xuICBvcHRpb25zLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLnNwbGl0KCcgJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaWYgKCEoL14odG9wfGJvdHRvbSktKGxlZnR8cmlnaHQpJC8udGVzdChwb3MpIHx8IC9eKHRvcHxib3R0b218bGVmdHxyaWdodCkkLy50ZXN0KHBvcykpKSB7XG4gICAgICB3YXJuKChcInYtdmstdG9vbHRpcCAtPiAnXCIgKyBwb3MgKyBcIicgaXMgbm90IGEgdmFsaWQgcG9zaXRpb24gdmFsdWVcIiksIGN0eC52bm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5mdW5jdGlvbiBnZXRBeGlzJDEgKHBvc2l0aW9uJCQxKSB7XG4gIHZhciByZWYgPSBwb3NpdGlvbiQkMS5zcGxpdCgnLScpO1xuICB2YXIgZGlyID0gcmVmWzBdO1xuICByZXR1cm4gZGlyID09PSAndG9wJyB8fCBkaXIgPT09ICdib3R0b20nID8gJ3knIDogJ3gnXG59XG5mdW5jdGlvbiBnZXRDb250YWluZXIgKGVsKSB7XG4gIHZhciByZWYgPSBlbFtOQU1FU1BBQ0UkNF07XG4gIHZhciB2bm9kZSA9IHJlZi52bm9kZTtcbiAgdmFyIHJlZiQxID0gZWxbTkFNRVNQQUNFJDRdLm9wdGlvbnM7XG4gIHZhciBjb250YWluZXIgPSByZWYkMS5jb250YWluZXI7XG4gIHJldHVybiAoY29udGFpbmVyID09PSB0cnVlICYmIHZub2RlLmNvbnRleHQuJHJvb3QuJGVsKSB8fCAoY29udGFpbmVyICYmICQoY29udGFpbmVyKSlcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXAgKGVsKSB7XG4gIHZhciByZWYgPSBlbFtOQU1FU1BBQ0UkNF07XG4gIHZhciB0aXRsZSA9IHJlZi50aXRsZTtcbiAgdmFyIHJlZiQxID0gZWxbTkFNRVNQQUNFJDRdLm9wdGlvbnM7XG4gIHZhciBjbHNQb3MgPSByZWYkMS5jbHNQb3M7XG4gIHJldHVybiBhcHBlbmQoZ2V0Q29udGFpbmVyKGVsKSwgKFwiPGRpdiBjbGFzcz1cXFwiXCIgKyBjbHNQb3MgKyBcIlxcXCIgYXJpYS1oaWRkZW4+XFxuICAgIDxkaXYgY2xhc3M9XFxcIlwiICsgY2xzUG9zICsgXCItaW5uZXJcXFwiPlwiICsgdGl0bGUgKyBcIjwvZGl2PlxcbiAgPC9kaXY+XCIpKVxufVxuZnVuY3Rpb24gZ2V0T3JpZ2luIChwb3NpdGlvbiQkMSkge1xuICB2YXIgZGlyID0gcG9zaXRpb24kJDFbMF07XG4gIHZhciBhbGlnbiA9IHBvc2l0aW9uJCQxWzFdO1xuICByZXR1cm4gZ2V0QXhpcyQxKHBvc2l0aW9uJCQxKSA9PT0gJ3knXG4gICAgPyAoKGZsaXBQb3NpdGlvbihkaXIpKSArIFwiLVwiICsgYWxpZ24pXG4gICAgOiAoYWxpZ24gKyBcIi1cIiArIChmbGlwUG9zaXRpb24oZGlyKSkpXG59XG5mdW5jdGlvbiBpc0ZvY3VzZWQgKGVsKSB7XG4gIHJldHVybiBlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxufVxuXG52YXIgTkFNRVNQQUNFJDUgPSAnX192a0hlaWdodE1hdGNoJztcbnZhciBpbmRleCQzID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kJCQxIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFtOQU1FU1BBQ0UkNV0gPSB7fTtcbiAgfSxcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICB2bm9kZS5jb250ZXh0LiRuZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGUkMyhlbCwgeyBiaW5kaW5nOiBiaW5kaW5nLCB2bm9kZTogdm5vZGUgfSk7IH1cbiAgICApO1xuICAgIGVsW05BTUVTUEFDRSQ1XS51bmJpbmQgPSBvbih3aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGUkMyhlbCwgeyBiaW5kaW5nOiBiaW5kaW5nLCB2bm9kZTogdm5vZGUgfSk7IH1cbiAgICApO1xuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICB2bm9kZS5jb250ZXh0LiRuZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGUkMyhlbCwgeyBiaW5kaW5nOiBiaW5kaW5nLCB2bm9kZTogdm5vZGUgfSk7IH1cbiAgICApO1xuICB9LFxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoZWwpIHtcbiAgICBpZiAoIWVsW05BTUVTUEFDRSQ1XSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsW05BTUVTUEFDRSQ1XS51bmJpbmQoKTtcbiAgICBkZWxldGUgZWxbTkFNRVNQQUNFJDVdO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGUkMyAoZWwsIGN0eCkge1xuICB2YXIgb3B0cyA9IGdldE9wdGlvbnMkNShjdHgpO1xuICB2YXIgZWxlbWVudHMgPSAkJChvcHRzLnRhcmdldCwgZWwpO1xuICBjc3MoZWxlbWVudHMsICdtaW5IZWlnaHQnLCAnJyk7XG4gIHZhciByb3dzID0gZ2V0Um93cyQxKGVsZW1lbnRzLCBvcHRzLnJvdyk7XG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAoZWxzKSB7XG4gICAgdmFyIHJlZiA9IG1hdGNoKGVscyk7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIGVsZW1lbnRzID0gcmVmLmVsZW1lbnRzO1xuICAgIGNzcyhlbGVtZW50cywgJ21pbkhlaWdodCcsIGhlaWdodCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0T3B0aW9ucyQ1IChjdHgpIHtcbiAgdmFyIHJlZiA9IGN0eC5iaW5kaW5nO1xuICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHsgdGFyZ2V0OiB2YWx1ZSB9O1xuICB9XG4gIHJldHVybiBhc3NpZ24oe1xuICAgIHRhcmdldDogJz4gKicsXG4gICAgcm93OiB0cnVlXG4gIH0sIHZhbHVlKVxufVxuZnVuY3Rpb24gZ2V0Um93cyQxIChlbGVtZW50cywgcm93KSB7XG4gIGlmICghcm93KSB7XG4gICAgcmV0dXJuIFsgZWxlbWVudHMgXVxuICB9XG4gIHZhciBsYXN0T2Zmc2V0ID0gZmFsc2U7XG4gIHJldHVybiBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJvd3MsIGVsKSB7XG4gICAgaWYgKGxhc3RPZmZzZXQgIT09IGVsLm9mZnNldFRvcCkge1xuICAgICAgcm93cy5wdXNoKFtlbF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3dzW3Jvd3MubGVuZ3RoIC0gMV0ucHVzaChlbCk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBlbC5vZmZzZXRUb3A7XG4gICAgcmV0dXJuIHJvd3NcbiAgfSwgW10pXG59XG5mdW5jdGlvbiBtYXRjaCAoZWxlbWVudHMpIHtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgbWF4ID0gMDtcbiAgdmFyIGhlaWdodHMgPSBbXTtcbiAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIGhpZGRlbjtcbiAgICBpZiAoIWlzVmlzaWJsZShlbCkpIHtcbiAgICAgIHN0eWxlID0gYXR0cihlbCwgJ3N0eWxlJyk7XG4gICAgICBoaWRkZW4gPSBhdHRyKGVsLCAnaGlkZGVuJyk7XG4gICAgICBhdHRyKGVsLCB7XG4gICAgICAgIHN0eWxlOiAoKHN0eWxlIHx8ICcnKSArIFwiO2Rpc3BsYXk6YmxvY2sgIWltcG9ydGFudDtcIiksXG4gICAgICAgIGhpZGRlbjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIG1heCA9IE1hdGgubWF4KG1heCwgZWwub2Zmc2V0SGVpZ2h0KTtcbiAgICBoZWlnaHRzLnB1c2goZWwub2Zmc2V0SGVpZ2h0KTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHN0eWxlKSkge1xuICAgICAgYXR0cihlbCwge3N0eWxlOiBzdHlsZSwgaGlkZGVuOiBoaWRkZW59KTtcbiAgICB9XG4gIH0pO1xuICBlbGVtZW50cyA9IGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWwsIGkpIHsgcmV0dXJuIGhlaWdodHNbaV0gPCBtYXg7IH0pO1xuICByZXR1cm4geyBoZWlnaHQ6IG1heCwgZWxlbWVudHM6IGVsZW1lbnRzIH1cbn1cblxuXG5cbnZhciBkaXJlY3RpdmVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuTWFyZ2luOiBWa01hcmdpbixcblNjcm9sbDogaW5kZXgkMSxcblRvb2x0aXA6IGluZGV4JDIsXG5IZWlnaHRNYXRjaDogaW5kZXgkMyxcbkhlaWdodFZpZXdwb3J0OiBWa0hlaWdodFZpZXdwb3J0XG59KTtcblxudmFyIFZ1aWtpdCA9IHtcbiAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gICAgZWFjaChjb21wb25lbnRzLCBmdW5jdGlvbiAoZGVmLCBuYW1lKSB7XG4gICAgICBWdWUuY29tcG9uZW50KChcIlZrXCIgKyBuYW1lKSwgZGVmKTtcbiAgICB9KTtcbiAgICBlYWNoKGRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkZWYsIG5hbWUpIHtcbiAgICAgIFZ1ZS5kaXJlY3RpdmUoKFwiVmtcIiArIG5hbWUpLCBkZWYpO1xuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBWdWlraXQ7XG5leHBvcnQgeyBicmVhZGNydW1iIGFzIEJyZWFkY3J1bWIsIGJyZWFkY3J1bWJfSXRlbSBhcyBCcmVhZGNydW1iSXRlbSwgYnV0dG9uIGFzIEJ1dHRvbiwgYnV0dG9uTGluayBhcyBCdXR0b25MaW5rLCBidXR0b25Hcm91cCBhcyBCdXR0b25Hcm91cCwgY2FyZCBhcyBDYXJkLCBjYXJkX1RpdGxlIGFzIENhcmRUaXRsZSwgRHJvcCwgRHJvcGRvd24sIEdyaWQsIGljb24gYXMgSWNvbiwgaWNvbkxpbmsgYXMgSWNvbkxpbmssIGljb25CdXR0b24gYXMgSWNvbkJ1dHRvbiwgaWNvbkltYWdlIGFzIEljb25JbWFnZSwgaWNvbm5hdiBhcyBJY29ubmF2LCBpY29ubmF2VmVydGljYWwgYXMgSWNvbm5hdlZlcnRpY2FsLCBpY29ubmF2X0l0ZW0gYXMgSWNvbm5hdkl0ZW0sIGxhYmVsIGFzIExhYmVsLCBtb2RhbCBhcyBNb2RhbCwgbW9kYWxGdWxsIGFzIE1vZGFsRnVsbCwgbW9kYWxfQ2xvc2UgYXMgTW9kYWxDbG9zZSwgbW9kYWxGdWxsX0Nsb3NlIGFzIE1vZGFsRnVsbENsb3NlLCBtb2RhbF9UaXRsZSBhcyBNb2RhbFRpdGxlLCBuYXYkMSBhcyBOYXYsIG5hdkRyb3Bkb3duIGFzIE5hdkRyb3Bkb3duLCBuYXZfSXRlbSBhcyBOYXZJdGVtLCBuYXZfSXRlbURpdmlkZXIgYXMgTmF2SXRlbURpdmlkZXIsIG5hdl9JdGVtSGVhZGVyIGFzIE5hdkl0ZW1IZWFkZXIsIG5hdl9JdGVtUGFyZW50IGFzIE5hdkl0ZW1QYXJlbnQsIG5hdmJhciBhcyBOYXZiYXIsIG5hdmJhckZ1bGwgYXMgTmF2YmFyRnVsbCwgbmF2YmFyRHJvcGJhciBhcyBOYXZiYXJEcm9wYmFyLCBuYXZiYXJfSXRlbSBhcyBOYXZiYXJJdGVtLCBuYXZiYXJfTG9nbyBhcyBOYXZiYXJMb2dvLCBuYXZiYXJfVG9nZ2xlIGFzIE5hdmJhclRvZ2dsZSwgbmF2YmFyX05hdiBhcyBOYXZiYXJOYXYsIG5hdmJhcl9OYXZfSXRlbSBhcyBOYXZiYXJOYXZJdGVtLCBuYXZiYXJfTmF2X0Ryb3Bkb3duIGFzIE5hdmJhck5hdkRyb3Bkb3duLCBuYXZiYXJfTmF2X0Ryb3Bkb3duX05hdiBhcyBOYXZiYXJOYXZEcm9wZG93bk5hdiwgbm90aWZpY2F0aW9uIGFzIE5vdGlmaWNhdGlvbiwgb2ZmY2FudmFzIGFzIE9mZmNhbnZhcywgb2ZmY2FudmFzQ29udGVudCBhcyBPZmZjYW52YXNDb250ZW50LCBvZmZjYW52YXNfQmFyIGFzIE9mZmNhbnZhc0Jhciwgb2ZmY2FudmFzX0Nsb3NlIGFzIE9mZmNhbnZhc0Nsb3NlLCBwYWdpbmF0aW9uIGFzIFBhZ2luYXRpb24sIHBhZ2luYXRpb25fUGFnZXMgYXMgUGFnaW5hdGlvblBhZ2VzLCBwYWdpbmF0aW9uX1BhZ2VGaXJzdCBhcyBQYWdpbmF0aW9uUGFnZUZpcnN0LCBwYWdpbmF0aW9uX1BhZ2VQcmV2IGFzIFBhZ2luYXRpb25QYWdlUHJldiwgcGFnaW5hdGlvbl9QYWdlTmV4dCBhcyBQYWdpbmF0aW9uUGFnZU5leHQsIHBhZ2luYXRpb25fUGFnZUxhc3QgYXMgUGFnaW5hdGlvblBhZ2VMYXN0LCBzY3JvbGxzcHkgYXMgU2Nyb2xsc3B5LCBzY3JvbGxzcHlOYXYgYXMgU2Nyb2xsc3B5TmF2LCBza2VsZXRvbkltYWdlIGFzIFNrZWxldG9uSW1hZ2UsIHNrZWxldG9uVGV4dCBhcyBTa2VsZXRvblRleHQsIHNrZWxldG9uVGl0bGUgYXMgU2tlbGV0b25UaXRsZSwgc3Bpbm5lciBhcyBTcGlubmVyLCBzdGlja3kgYXMgU3RpY2t5LCBzdWJuYXYgYXMgU3VibmF2LCBzdWJuYXZfSXRlbSBhcyBTdWJuYXZJdGVtLCBzdWJuYXZfSXRlbURyb3Bkb3duIGFzIFN1Ym5hdkl0ZW1Ecm9wZG93biwgVGFibGUsIHRhYmxlVHJlZSBhcyBUYWJsZVRyZWUsIENvbHVtbiBhcyBUYWJsZUNvbHVtbiwgdGFibGVfQ29sdW1uU29ydCBhcyBUYWJsZUNvbHVtblNvcnQsIHRhYmxlX0NvbHVtblNlbGVjdCBhcyBUYWJsZUNvbHVtblNlbGVjdCwgdGFibGVfQ29sdW1uVHJlZSBhcyBUYWJsZUNvbHVtblRyZWUsIHRhYnMgYXMgVGFicywgdGFic1ZlcnRpY2FsIGFzIFRhYnNWZXJ0aWNhbCwgdGFic19JdGVtIGFzIFRhYnNJdGVtLCBWa01hcmdpbiBhcyBNYXJnaW4sIGluZGV4JDEgYXMgU2Nyb2xsLCBpbmRleCQyIGFzIFRvb2x0aXAsIGluZGV4JDMgYXMgSGVpZ2h0TWF0Y2gsIFZrSGVpZ2h0Vmlld3BvcnQgYXMgSGVpZ2h0Vmlld3BvcnQgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7QUFNQTs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBMUJBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFUQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFWQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUE3Q0E7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBLHlHQThFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEsZUFFQTtBQUNBO0FBQUEsZUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBLGVBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWxCQTtBQUNBO0FBb0JBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBNURBO0FBQ0E7QUE2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQXpDQTtBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQVJBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBVkE7QUFMQTtBQWtCQTtBQUNBO0FBNUNBO0FBK0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUZBO0FBeEJBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVFBO0FBdkVBO0FBQ0E7QUF3RUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0NBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpGQTtBQW9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBSEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFiQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQW5DQTtBQXNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBcEJBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQSxlQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUZBO0FBRkE7QUFjQTtBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQTlCQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBSUE7QUF4QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQWZBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFqQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQWpDQTtBQUxBO0FBQ0E7QUF3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXREQTtBQXdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFKQTtBQVFBO0FBckJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBUEE7QUFXQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBUEE7QUFXQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7QUFHQTtBQTdCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7QUFHQTtBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBaEJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFqQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBZEE7QUFpQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQURBO0FBUUE7QUFDQTtBQUFBO0FBRkE7QUFRQTtBQUNBO0FBOUVBO0FBaUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEsZUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUpBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBTEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQXpCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFSQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBREE7QUFJQTtBQURBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBSUE7QUF6Q0E7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFJQTtBQURBO0FBSUE7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBYkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFPQTtBQXRCQTtBQUNBO0FBd0JBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFEQTtBQUlBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBREE7QUFLQTtBQUFBO0FBQUE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQURBO0FBREE7QUFNQTtBQURBO0FBS0E7QUFqQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBakJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBUEE7QUFXQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFLQTtBQURBO0FBSUE7QUE3QkE7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQVZBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQVFBO0FBNUNBO0FBK0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFOQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU9BO0FBcEVBO0FBdUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBYkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFuQkE7QUFnQ0E7QUFEQTtBQUtBO0FBQUE7QUFLQTtBQWhJQTtBQW1JQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTFCQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFoQkE7QUFOQTtBQXlCQTtBQUNBO0FBaENBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBTUE7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFLQTtBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFUQTtBQVdBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQXRDQTtBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFQQTtBQWFBO0FBSUE7QUFwR0E7QUF1R0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQTVEQTtBQThEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUdBO0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUFKQTtBQStCQTtBQUNBO0FBckNBO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhDQTtBQUpBO0FBK0NBO0FBQ0E7QUFyREE7QUF3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFKQTtBQTBDQTtBQUNBO0FBaERBO0FBbURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQ0E7QUFKQTtBQTJDQTtBQUNBO0FBakRBO0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBakJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUEsaUJBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQVlBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUEzREE7QUFDQTtBQTREQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBT0E7QUFBQTtBQUVBO0FBMUJBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQURBO0FBUkE7QUFZQTtBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFUQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUFBO0FBR0E7QUFDQTtBQURBO0FBREE7QUFPQTtBQXZDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFEQTtBQVJBO0FBWUE7QUF4QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBVEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFBQTtBQUVBO0FBQ0E7QUFEQTtBQURBO0FBUUE7QUF2Q0E7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBYkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQURBO0FBSUE7QUFDQTtBQTVEQTtBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBTEE7QUFVQTtBQUNBO0FBMUJBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBTkE7QUFVQTtBQXpCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQU5BO0FBVUE7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFOQTtBQVVBO0FBekJBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBTkE7QUFVQTtBQXpCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpEQTtBQTJEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUEvRUE7QUFrRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUF4QkE7QUE2QkE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkRBO0FBc0RBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUEsaUJBRUE7QUFDQTtBQUFBO0FBQ0E7QUF0SEE7QUF5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBYkE7QUFrQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQSxpQkFFQTtBQUNBO0FBQUE7QUFDQTtBQTNGQTtBQThGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFUQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUpBO0FBVUE7QUFEQTtBQUlBO0FBcENBO0FBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBUEE7QUFXQTtBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFFQTtBQWZBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBOUJBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQVJBO0FBVUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBOEJBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUNBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUExQ0E7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQSxpQkFFQTtBQUNBO0FBQUE7QUFDQTtBQTVPQTtBQUNBO0FBNk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQVRBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQUE7QUFFQTtBQWpDQTtBQW9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBU0E7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBLG1CQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBUUE7QUFDQTtBQTdDQTtBQUNBO0FBOENBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFGQTtBQVNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBREE7QUFQQTtBQVdBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFEQTtBQU9BO0FBREE7QUFNQTtBQTFCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQVRBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcENBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxFQTtBQXFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQXpCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBREE7QUFXQTtBQS9DQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQXpCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFEQTtBQVVBO0FBdERBO0FBeURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBUUE7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVJBO0FBTEE7QUFnQkE7QUF2QkE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEsaUJBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUdBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBLG1CQUVBO0FBQ0E7QUFBQSxtQkFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBVEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFuQ0E7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWxDQTtBQW9DQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQXpFQTtBQUNBO0FBMkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBLGlCQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUpBO0FBV0E7QUEvQkE7QUFDQTtBQWdDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFSQTtBQWNBO0FBQ0E7QUF0QkE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUpBO0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUZBO0FBT0E7QUFDQTtBQXREQTtBQXlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBSkE7QUFjQTtBQUNBO0FBN0JBO0FBZ0NBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTkE7QUFXQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFOQTtBQURBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBaENBO0FBQ0E7QUFzREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQU5BO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQTFCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFIQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBakJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBVkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQUE7QUFHQTtBQURBO0FBTUE7QUF6Q0E7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUFBO0FBQUE7QUFEQTtBQVNBO0FBekNBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFEQTtBQVNBO0FBdkNBO0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUZBO0FBU0E7QUF6QkE7QUE4QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckVBO0FBd0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUEzQkE7QUFDQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFIQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUFDQTtBQTZCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUFBLHlCQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXBCQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFhQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n")}}]);